{"meta":{"title":"得一","subtitle":null,"description":null,"author":"me","url":"https://mouzishuo.github.io","root":"/"},"pages":[{"title":"分类","date":"2018-08-13T08:03:32.000Z","updated":"2018-08-13T09:13:25.762Z","comments":true,"path":"categories/index.html","permalink":"https://mouzishuo.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-13T08:03:12.000Z","updated":"2018-08-13T09:12:51.958Z","comments":true,"path":"tags/index.html","permalink":"https://mouzishuo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android S packages.xml乱码的原因","slug":"Android S packages.xml乱码的原因","date":"2022-12-10T03:16:41.398Z","updated":"2022-12-10T03:45:50.020Z","comments":true,"path":"2022/12/10/Android S packages.xml乱码的原因/","link":"","permalink":"https://mouzishuo.github.io/2022/12/10/Android%20S%20packages.xml%E4%B9%B1%E7%A0%81%E7%9A%84%E5%8E%9F%E5%9B%A0/","excerpt":"","text":"问题背景客户项目遇到PackageManagerService扫描出现错误导致不停重启，然后进入recovery的问题。查看log是在开机读取Settings(packages.xml）中某个应用的签名信息时出错，系统构造了一个null的签名信息（数组）。导致之后比较签名数组长度时出现空指针。于是想把手机中的packages.xml做修改后模拟问题出现的原因。但是把这个文件pull出来之后发现里面是乱码，切换编码也没用。Android 11的模拟器没有这个问题，于是查看了这个文件的序列化过程，略作纪录。 Android S xml序列化变更以frameworks/base/services/core/java/com/android/server/pm/Settings.java中writeLPr方法中序列化过程为例，Android S中的序列化工具创建代码如下： 123456final FileOutputStream fstr = new FileOutputStream(mSettingsFilename);final TypedXmlSerializer serializer = Xml.resolveSerializer(fstr);serializer.startDocument(null, true);serializer.setFeature(&quot;http://xmlpull.org/v1/doc/features.html#indent-output&quot;, true);serializer.startTag(null, &quot;packages&quot;); Android R中代码如下: 12345678910FileOutputStream fstr = new FileOutputStream(mSettingsFilename);BufferedOutputStream str = new BufferedOutputStream(fstr);//XmlSerializer serializer = XmlUtils.serializerInstance();XmlSerializer serializer = new FastXmlSerializer();serializer.setOutput(str, StandardCharsets.UTF_8.name());serializer.startDocument(null, true);serializer.setFeature(&quot;http://xmlpull.org/v1/doc/features.html#indent-output&quot;, true);serializer.startTag(null, &quot;packages&quot;); 主要差别就在Xml Serializer的构建上，FastXmlSerializer序列化的xml文件可以正常查看，那TypedXmlSerializer有什么不同呢？先看下TypedXmlSerializer的注释： 123456789/** * Specialization of &#123;@link XmlSerializer&#125; which adds explicit methods to * support consistent and efficient conversion of primitive data types. * * @hide */ public interface TypedXmlSerializer extends XmlSerializer &#123; //…… &#125; 也就是所TypedXmlSerializer在序列化过程中会对原生数据类型进行转换。TypedXmlSerializer是个接口，具体构建的对象类型要看Xml.resolveSerializer的实现： 12345678910111213141516171819202122232425/** * Creates a new &#123;@link XmlSerializer&#125; which is optimized for use inside the * system, typically by supporting only a basic set of features. * &lt;p&gt; * This returned instance may be configured to write using an efficient * binary format instead of a human-readable text format, depending on * device feature flags. * &lt;p&gt; * To ensure that both formats are detected and transparently handled * correctly, you must shift to using both &#123;@link #resolveSerializer&#125; and * &#123;@link #resolvePullParser&#125;. * * @hide */public static @NonNull TypedXmlSerializer resolveSerializer(@NonNull OutputStream out) throws IOException &#123; final TypedXmlSerializer xml; if (ENABLE_BINARY_DEFAULT) &#123; xml = newBinarySerializer(); &#125; else &#123; xml = newFastSerializer(); &#125; xml.setOutput(out, StandardCharsets.UTF_8.name()); return xml;&#125; 从上述代码来看根据系统ENABLE_BINARY_DEFAULT的配置，可以选择构建BinarySerializer或是FastSerializer。ENABLE_BINARY_DEFAULT的定义如下： 12public static final boolean ENABLE_BINARY_DEFAULT = SystemProperties .getBoolean(&quot;persist.sys.binary_xml&quot;, true); 所以在调试的时候可以设置persist.sys.binary_xml的值为false然后重启来切换xml serializer并更新xml的内容。 BinarySerializer的注释如下： 12345678910111213141516171819202122/** * Serializer that writes XML documents using a custom binary wire protocol * which benchmarking has shown to be 4.3x faster and use 2.4x less disk space * than &#123;@code Xml.newFastSerializer()&#125; for a typical &#123;@code packages.xml&#125;. * &lt;p&gt; * The high-level design of the wire protocol is to directly serialize the event * stream, while efficiently and compactly writing strongly-typed primitives * delivered through the &#123;@link TypedXmlSerializer&#125; interface. * &lt;p&gt; * Each serialized event is a single byte where the lower half is a normal * &#123;@link XmlPullParser&#125; token and the upper half is an optional data type * signal, such as &#123;@link #TYPE_INT&#125;. * &lt;p&gt; * This serializer has some specific limitations: * &lt;ul&gt; * &lt;li&gt;Only the UTF-8 encoding is supported. * &lt;li&gt;Variable length values, such as &#123;@code byte[]&#125; or &#123;@link String&#125;, are * limited to 65,535 bytes in length. Note that &#123;@link String&#125; values are stored * as UTF-8 on the wire. * &lt;li&gt;Namespaces, prefixes, properties, and options are unsupported. * &lt;/ul&gt; */ 可见使用新的serializer的目的和Android资源编译的目的类似，一个是节省存储空间，一个是加快访问速度。 Wire protocol（传输协议）更多的是表达传输格式。因为代码层面的数据（链表、队列、二叉树）都是结构化的，但网络层看到的都是二进制流，所以把结构化的数据序列化为二进制流发送出去，并且对方也能以同样的格式反序列化出来，这就是wire protocol。跟把对象存储在文件里，重启后再从文件读出来有点类似。（https://www.zhihu.com/question/413112626）","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"}],"tags":[{"name":"PKMS","slug":"PKMS","permalink":"https://mouzishuo.github.io/tags/PKMS/"}]},{"title":"hexo博客The \"mode\" argument must be integer. Received an instance of Object问题","slug":"hexo博客The “mode“ argument must be integer. Received an instance of Object问题","date":"2022-12-09T09:13:15.756Z","updated":"2022-12-10T03:47:26.085Z","comments":true,"path":"2022/12/09/hexo博客The “mode“ argument must be integer. Received an instance of Object问题/","link":"","permalink":"https://mouzishuo.github.io/2022/12/09/hexo%E5%8D%9A%E5%AE%A2The%20%E2%80%9Cmode%E2%80%9C%20argument%20must%20be%20integer.%20Received%20an%20instance%20of%20Object%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题原因：hexo和node版本不兼容。 hexo和node版本对应关系参考https://hexo.io/zh-cn/docs/； 升级过程参考https://www.jianshu.com/p/802182c01b59： 1、全局升级hexo-cli，先hexo version查看当前版本，然后npm i hexo-cli -g，再次hexo version查看是否升级成功。 2、使用npm install -g npm-check和npm-check，检查系统中的插件是否有升级的，可以看到自己前面都安装了那些插件3、使用npm install -g npm-upgrade和npm-upgrade，升级系统中的插件4、使用npm update -g和npm update –save","categories":[{"name":"tool","slug":"tool","permalink":"https://mouzishuo.github.io/categories/tool/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://mouzishuo.github.io/tags/hexo/"}]},{"title":"hexo本地加载慢","slug":"hexo本地加载慢","date":"2022-12-09T09:11:39.834Z","updated":"2022-12-10T07:01:30.187Z","comments":true,"path":"2022/12/09/hexo本地加载慢/","link":"","permalink":"https://mouzishuo.github.io/2022/12/09/hexo%E6%9C%AC%E5%9C%B0%E5%8A%A0%E8%BD%BD%E6%85%A2/","excerpt":"","text":"hexo有一段时间没用之后发现博客无法部署了，而且本地打开hexo博客都要几分钟。部署的问题是因为hexo版本太老，升级后解决。hexo打开慢据网上的说法是因为主题中使用了google字体，但是具体是哪些字体，怎么修改没有说。这里记录下大概的解决过程。 查看加载慢的元素打开博客后，在Chrome浏览器的工具里打开开发者工具。然后选择Network选项。如图：刷新页面后可以看到每一个元素的加载时间。鼠标移到name和initiator项可以查看元素相关信息。 在hexo目录下搜索相关内容，进行修改，这里图省事只是把出现问题的字体去掉了。修改文件为Blog&#x2F;themes&#x2F;hiker&#x2F;layout&#x2F;_partial&#x2F;head.ejs和Blog&#x2F;themes&#x2F;hiker&#x2F;source&#x2F;css&#x2F;_variables.styl。另外可以在开发者工具中的Elements页面中搜索相关内容，查看有问题的是哪些元素。","categories":[{"name":"tool","slug":"tool","permalink":"https://mouzishuo.github.io/categories/tool/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://mouzishuo.github.io/tags/hexo/"}]},{"title":"am的一些用法","slug":"am.usage","date":"2022-12-09T08:14:00.433Z","updated":"2022-12-09T08:14:00.433Z","comments":true,"path":"2022/12/09/am.usage/","link":"","permalink":"https://mouzishuo.github.io/2022/12/09/am.usage/","excerpt":"","text":"start 启动activity； broadcast 可以用来发送广播 crash可以模拟apk crash； hang 可以触发watchdog; restart 上层重启; set-debug-app一般在AS中进行调试的时候都是先打断点，然后Attach debugger to Android process再进行调试，但是这种方法不适用于调试应用启动时的调试，如果需要在启动的地方调试则需要Run Debug app，但是这种凡是比较慢，尤其是大项目，因为包含编译等工作。另一种方式是使用adb shell am set-debug-app -w &lt;packagename&gt;命令，然后会弹出”Waiting For Debugger”的提示，此时打开AS的Attach debugger to Android process即可，此时我们就可以方便在app启动时的断点调试了。 kill force-stop get-uid-state:查看指定uid应用的状态比如：123456generic_x86_arm:/ # am get-uid-state 10099 19 (CACHED_EMPTY)generic_x86_arm:/ # am get-uid-state 10114 2 (TOP)generic_x86_arm:/ # am get-uid-state 10143 0 (PERSISTENT) get-config：123generic_x86_arm:/ # am get-configconfig: en-rUS-ldltr-sw348dp-w348dp-h662dp-normal-long-notround-nowidecg-lowdr-port-notnight-496dpi-finger-keysexposed-qwerty-navexposed-dpad-2055x1080-v30abi: x86,armeabi-v7a,armeabi","categories":[{"name":"debug","slug":"debug","permalink":"https://mouzishuo.github.io/categories/debug/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"},{"name":"debug","slug":"debug","permalink":"https://mouzishuo.github.io/tags/debug/"}]},{"title":"StatusBar显示到秒","slug":"StatusBar显示秒","date":"2022-12-09T08:12:13.592Z","updated":"2022-12-09T08:12:13.592Z","comments":true,"path":"2022/12/09/StatusBar显示秒/","link":"","permalink":"https://mouzishuo.github.io/2022/12/09/StatusBar%E6%98%BE%E7%A4%BA%E7%A7%92/","excerpt":"","text":"需要root权限 1234adb rootadb remountadb shell pm enable com.android.systemui/com.android.systemui.tuner.TunerActivityadb shell am start am start -n com.android.systemui/com.android.systemui.tuner.TunerActivity 启动System UI Tuner后在Status bar -&gt; time 中选择显示“小时，分钟，秒”。","categories":[{"name":"debug","slug":"debug","permalink":"https://mouzishuo.github.io/categories/debug/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"},{"name":"debug","slug":"debug","permalink":"https://mouzishuo.github.io/tags/debug/"}]},{"title":"kill的一些用法","slug":"kill的一些用法","date":"2022-12-09T08:10:11.575Z","updated":"2022-12-09T08:10:11.575Z","comments":true,"path":"2022/12/09/kill的一些用法/","link":"","permalink":"https://mouzishuo.github.io/2022/12/09/kill%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/","excerpt":"","text":"adb shell kill -3&#x2F;SIGQUIT &lt;pid&gt;可以在不发生ANR的情况下就打印指定进程的堆栈。如果嫌查找pid麻烦，可以使用adb shell killall -3 &lt;processname&gt;. 或者和pidof命令组合，比如打印Settings的堆栈可以使用如下命令：adb shell kill -3 `pidof com.android.settings`或者kill -3 $(pidof com.android.settings) 。产生的堆栈保存在&#x2F;data&#x2F;anr目录下。 adb shell kill -19&#x2F;SIGSTOP可以停止（暂停，并不是杀掉）进程，过一会儿就会产生ANR，可以发送18&#x2F;SIGCONT恢复执行。 adb shell kill -9&#x2F;SIGKILL杀掉进程。","categories":[{"name":"debug","slug":"debug","permalink":"https://mouzishuo.github.io/categories/debug/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"},{"name":"debug","slug":"debug","permalink":"https://mouzishuo.github.io/tags/debug/"}]},{"title":"trace中线程信息","slug":"trace中线程信息","date":"2022-11-29T08:29:08.000Z","updated":"2022-11-30T05:58:47.147Z","comments":true,"path":"2022/11/29/trace中线程信息/","link":"","permalink":"https://mouzishuo.github.io/2022/11/29/trace%E4%B8%AD%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF/","excerpt":"","text":"SampleGet trace info from /data/anr: &quot;main&quot; prio=5 tid=1 Native | group=&quot;main&quot; sCount=1 ucsCount=0 flags=1 obj=0x7161e500 self=0xf1e40e00 | sysTid=878 nice=0 cgrp=background sched=0/0 handle=0xf22b6470 | state=S schedstat=( 1446741865 981289649 3627 ) utm=94 stm=50 core=3 HZ=100 | stack=0xff4e9000-0xff4eb000 stackSize=8188KB 各字段含义 Thread’s information format – first line name – Thread name priority – Thread priority tid – Thread ID status – Thread status Thread’s information format – second line： group – Group name, sCount – Suspend count, dsCount – Debug suspend count, obj – Linux thread that we are associated with self – Self reference Thread’s information format – third line: sysTid – Linux thread ID nice – Linux “nice” priority (lower numbers indicate higher priority) sched – Scheduling priority cgrp – Scheduling group buffer handle – Thread handle Thread’s information format – fourth line Schedstat: This is CPU schedule statics data: Running time: CPU running time, unit: ns. Runnable time: RQ queue waiting time, unit: ns. Switch number: CPU scheduler switch times. utm: Thread run in user space time, unit: jiffies. jiffies defined by “sysconf(_SC_CLK_TCK)”. The default value is 10ms. stm: Thread run in kernel space time, unit: jiffies. The default value is 10ms. 线程状态对应上面trace信息中的Native的位置。 ZOMBIE − terminated thread RUNNABLE − runnable or running now TIMED_WAIT − timed waiting in Object.wait() MONITOR − blocked on a monitor WAIT − waiting in Object.wait() INITIALIZING − allocated, not yet running STARTING − started, not yet on thread list NATIVE − off in a JNI native method VMWAIT − waiting on a VM resource SUSPENDED − suspended, usually by GC or debugger UNKNOWN − thread is in the undefined state state包括有 R、S、D、T、Z、X六个状态。 状态 含义 R TASK_RUNNING，可执行状态,包括正在运行和可运行两种状态 S TASK_INTERRUPTIBLE， 可中断的睡眠状态。处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。 D TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。 T TASK_STOPPED or TASK_TRACED，暂停状态或跟踪状态。 向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。当进程正在被跟踪时，它处于TASK_TRACED这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于TASK_TRACED状态。 Z TASK_DEAD - EXIT_ZOMBIE，退出状态，进程成为僵尸进程。进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。 X TASK_DEAD - EXIT_DEAD，退出状态，进程即将被销毁。进程在退出过程中也可能不会保留它的task_struct。此时，进程将被置于EXIT_DEAD退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。 进程状态变迁 进程自创建以后，状态可能发生一系列的变化，直到进程退出。而尽管进程状态有好几种，但是进程状态的变迁却只有两个方向——从TASK_RUNNING状态变为非TASK_RUNNING状态、或者从非TASK_RUNNING状态变为TASK_RUNNING状态。也就是说，如果给一个TASK_INTERRUPTIBLE状态的进程发送SIGKILL信号，这个进程将先被唤醒（进入TASK_RUNNING状态），然后再响应SIGKILL信号而退出（变为TASK_DEAD状态）。并不会从TASK_INTERRUPTIBLE状态直接退出。 进程从非TASK_RUNNING状态变为TASK_RUNNING状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。执行唤醒的进程设置被唤醒进程的状态为TASK_RUNNING，然后将其task_struct结构加入到某个CPU的可执行队列中。于是被唤醒的进程将有机会被调度执行。 而进程从TASK_RUNNING状态变为非TASK_RUNNING状态，则有两种途径： 响应信号而进入TASK_STOPED状态、或TASK_DEAD状态； 执行系统调用主动进入TASK_INTERRUPTIBLE状态（如nanosleep系统调用）、或TASK_DEAD状态（如exit系统调用）；或由于执行系统调用需要的资源得不到满足，而进入TASK_INTERRUPTIBLE状态或TASK_UNINTERRUPTIBLE状态（如select系统调用）。显然，这两种情况都只能发生在进程正在CPU上执行的情况下。 Schedstat含义上面有大致介绍，详细内容见参考内容3.这个部分的内容在发生SWT时可以用到，SWT时两次trace的schedstat部分应该是一样的。 参考： 高通文档：Android Screen Freeze And Watchdog Issues Analysis Linux进程状态解析 之 R、S、D、T、Z、X linux调度器（十）——调度器&#x2F;proc信息解读","categories":[{"name":"debug","slug":"debug","permalink":"https://mouzishuo.github.io/categories/debug/"}],"tags":[{"name":"ANR","slug":"ANR","permalink":"https://mouzishuo.github.io/tags/ANR/"},{"name":"SWT","slug":"SWT","permalink":"https://mouzishuo.github.io/tags/SWT/"},{"name":"Linux","slug":"Linux","permalink":"https://mouzishuo.github.io/tags/Linux/"}]},{"title":"Android消息机制简介","slug":"Android消息机制","date":"2019-09-27T08:00:53.354Z","updated":"2019-09-27T08:00:23.246Z","comments":true,"path":"2019/09/27/Android消息机制/","link":"","permalink":"https://mouzishuo.github.io/2019/09/27/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/","excerpt":"","text":"相关类介绍先来看下相关类在源码中的注释。 Handler Handler类注释：Handler可以向与线程关联的MessageQueue中发送Message及Runnable对象，并可以处对这些Message及Runnable对象进行处理.每一个Handler都和一个线程以及该线程的MessageQueue关联。当创建一个Handler时，该Handler就会和创建该Handler的线程MessageQueue绑定–之后Handler将传递Message和runnable objects给该MessageQueue，并在它们从消息队列出队时处理它们。 Handler有两个作用：安排Message和runnables在将来某个点执行（延时执行）；将一个action入队到自己所有的另一个线程进行执行（线程切换）。 分发消息可以通过以下几个方法完成： post(Runnable),&#x2F;&#x2F;Runnable postAtTime(Runnable, long), postDelayed(Runnable, long), sendEmptyMessage(int), &#x2F;&#x2F;Message sendMessage(Message), sendMessageAtTime(Message, long), sendMessageDelayed(Message, long) post系列的方法用于enqueue runnables,setMessage系列的方法用来传递Message，Message可以通过Bundle传递数据，接收到Message后通过handleMessage方法进行处理。 在传递Message和Runnable时，可以选择在MessageQueue准备好后马上执行或者延时一定时间或者在某个时间点进行执行，后两者可以用来实现timeouts,ticks以及其他基于时间的行为。 应用的进程被创建后，主线程会维护一个消息队列用于管理顶层的应用对象（activities，broadcast receivers等）以及应用它们创建的所有窗口。可以创建自己的线程，通过Handler反过来和主线程进行沟通（post或者send）,发送的Message和runnable对象在主线程的handler中进行调度，并在合适的时机进行处理。 Message Message包含向Handler发送的描述信息和任意的数据对象，主要包含两个整数字段和一个额外的对象字段（不需要强制类型转换）。 在构造Message对象时，最好的方法是通过Message的obtain()方法或者Handler的obtainMessage()方法，两者的区别在于后者会自动设置Message的target为调用的Handler。 MessageQueue 用于保存待Looper分发的message列表的底层类。Message不是直接添加到MessageQueue中的，而是通过与Looper关联的Handler进行添加。 可以通过Looper#myQueue()方法获取当前线程的消息列表。 Looper 用于进行线程的消息循环。线程默认没有关联的Looper，要创建Looper可以通过调用Looper.prepare()和Looper.loop()。不过主线程例外，系统会为主线程创建Looper，该过程在ActivityThread的main方法中进行。常见的和message loop交互的方式是通过Handler类。 典型的Looper实现如下，通过Looper.prepare()和Looper.loop()初始化一个和Looper通信的Handler。 123456789101112class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125; ​ Message获取 Message获取方式 前面说了Message的获取主要有两种方式：通过Handler的obtainMessage()系列方法或者通过Message的obtain()系列方法。先来看看Handler的obtainMessage()系列方法： 123456789/** * Returns a new &#123;@link android.os.Message Message&#125; from the global message pool. More efficient than * creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this). * If you don&#x27;t want that facility, just call Message.obtain() instead. */public final Message obtainMessage()&#123; return Message.obtain(this);&#125; 1234public final Message obtainMessage(int what)&#123; return Message.obtain(this, what);&#125; 1234public final Message obtainMessage(int what, Object obj)&#123; return Message.obtain(this, what, obj);&#125; 1234public final Message obtainMessage(int what, int arg1, int arg2)&#123; return Message.obtain(this, what, arg1, arg2);&#125; 1234public final Message obtainMessage(int what, int arg1, int arg2, Object obj)&#123; return Message.obtain(this, what, arg1, arg2, obj);&#125; 从注释上可知，其实Handler获取Message最终还是通过Message的相关方法，只不过除了从Message对象池获取Message外，还将本身设为了Message的target。下面来看下Message的相关方法。 ​ 1234567891011121314151617/** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; 上面这个方法是其他几个方法的基础，另外几个方法（上图中第2~6个重载方法）都是在该方法的基础上对得到的Message属性（即Message携带的数据）进行了赋值。比如下面的方法，除了获取Message对象外，还将该对象的target设为了参数handler。 1234567891011/** * Same as &#123;@link #obtain()&#125;, but sets the value for the &lt;em&gt;target&lt;/em&gt; member on the Message returned. * @param h Handler to assign to the returned Message object&#x27;s &lt;em&gt;target&lt;/em&gt; member. * @return A Message object from the global pool. */public static Message obtain(Handler h) &#123; Message m = obtain(); m.target = h; return m;&#125; 而obtain(Message orig)生成新的Message并将orig的值复制到新的Message： 12345678910111213141516171819202122/** * Same as &#123;@link #obtain()&#125;, but copies the values of an existing * message (including its target) into the new one. * @param orig Original message to copy. * @return A Message object from the global pool. */public static Message obtain(Message orig) &#123; Message m = obtain(); m.what = orig.what; m.arg1 = orig.arg1; m.arg2 = orig.arg2; m.obj = orig.obj; m.replyTo = orig.replyTo; m.sendingUid = orig.sendingUid; if (orig.data != null) &#123; m.data = new Bundle(orig.data); &#125; m.target = orig.target; m.callback = orig.callback; return m;&#125; 另外有一个较特殊的一个重载方法： 1234567891011121314/** * Same as &#123;@link #obtain(Handler)&#125;, but assigns a callback Runnable on * the Message that is returned. * @param h Handler to assign to the returned Message object&#x27;s &lt;em&gt;target&lt;/em&gt; member. * @param callback Runnable that will execute when the message is handled. * @return A Message object from the global pool. */public static Message obtain(Handler h, Runnable callback) &#123; Message m = obtain(); m.target = h; m.callback = callback; return m;&#125; 该方法除了Handler外还接收了一个Runnable参数，该对象在消息进行处理时会优先进行执行，详细的后面的消息处理部分会介绍。 Message对象池的维护 在上面看到Message对象池的时候一直有个疑问，Message对象池是怎么维护的？再来看一下Message#obtain()方法： 1234567891011121314151617/** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. */public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; 从上面的代码中可以看出来，Message采用了链表的结构，每次取对象时将链表头部的元素取出并将指针向前移动一位，同时清除返回对象的in-use标志。在sPool为空的情况下，也就是对象池中没有可用的对象是才会重新构造Message对象。Message的构造方法如下： 1234/** Constructor (but the preferred way to get a Message is to call &#123;@link #obtain() Message.obtain()&#125;). */ public Message() &#123; &#125; 问题来了，开始的时候对象池为空，而且构造方法里什么也没做，那么构造的对象是怎么加入到对象池（链表）中的？查找一下引用sPool的地方: 对sPool进行修改的地方有两处，其中一处在obtain()方法中，这个排除，还有一处是在recycleUnchecked()方法中。 123456789101112131415161718192021222324252627/** * Recycles a Message that may be in-use. * Used internally by the MessageQueue and Looper when disposing of queued Messages. */void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123;//MAX_POOL_SIZE = 50 next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 可以看到，如果对象池没满，则调用该方法的Message对象会被放到链表的头部。 再来看一下上面的FLAG_IN_USE是干嘛的： 123456789/** If set message is in use. * This flag is set when the message is enqueued and remains set while it * is delivered and afterwards when it is recycled. The flag is only cleared * when a new message is created or obtained since that is the only time that * applications are allowed to modify the contents of the message. * * It is an error to attempt to enqueue or recycle a message that is already in use. *//*package*/ static final int FLAG_IN_USE = 1 &lt;&lt; 0; 从注释来看，在Message被enqueue后该标志就会一直存在，直到新的Messge被创建或者Message重新被obtain，因为只有在此时（消息发出去之前）才允许修改Message内容。 总结一下这一部分。Message用在在不同线程之间发送消息，是Handler和Looper沟通的媒介，消息内容可以是简单的int类型，也可以时Object类型，也可以是复杂的Bundle类型。Message获取有两种方式：通过Handler或者通过Message。通过Handler获取Message会将自身设为Message的target，发送消息时采用Message的sendToTarget()方法即可；通过Message获取的对象根据参数的不同可以采用sendTotarget()或者Handler的sendMessage()方法进行发送。 消息发送过程上面提到过，消息的发送也有两种方式，通过Message#sendTotarget()或者通过Handler的sendMessage()系列方法。Message#sendTotarget()代码如下： 1234567/** * Sends this Message to the Handler specified by &#123;@link #getTarget&#125;. * Throws a null pointer exception if this field has not been set. */public void sendToTarget() &#123; target.sendMessage(this);&#125; 其实就是调用Handler的sendMessage(Message msg)方法。 Handler发送消息的方法有以下几种重载方式： 几个sendEmptyMessage……的方法其实在方法内部通过obtain方法获取了Message对象，然后设置该对象的what值，最后调用对应的sendMessage……方法。而sendMessage()、sendMessageDelayed()最终都是调用的sendMessageAtTime()方法。 1234567891011121314151617181920212223242526272829/** * Enqueue a message into the message queue after all pending messages * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;. * &lt;b&gt;The time-base is &#123;@link android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt; * Time spent in deep sleep will add an additional delay to execution. * You will receive it in &#123;@link #handleMessage&#125;, in the thread attached * to this handler. * * @param uptimeMillis The absolute time at which the message should be * delivered, using the * &#123;@link android.os.SystemClock#uptimeMillis&#125; time-base. * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. Note that a * result of true does not mean the message will be processed -- if * the looper is quit before the delivery time of the message * occurs then the message will be dropped. */public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 从注释可知，放入消息队列中的Message是按照传递的uptimeMillis进行排列的，sendMessageAtTime()传递的是发送消息时的时间加上延时的时间（不包括休眠时间），而另一个方法sendMessageAtFrontOfQueue()与之类似，不过传递的绝对时间为0，这回导致该消息被放置到消息队列的最前面。 12345678910111213141516171819202122/** * Enqueue a message at the front of the message queue, to be processed on * the next iteration of the message loop. You will receive it in * &#123;@link #handleMessage&#125;, in the thread attached to this handler. * &lt;b&gt;This method is only for use in very special circumstances -- it * can easily starve the message queue, cause ordering problems, or have * other unexpected side-effects.&lt;/b&gt; * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. */public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0);&#125; 代码里提到该方法只有在特殊情况下才能使用，否则容易产生负面影响，具体用法尚不明确（用来插队的？）。 消息入队消息发送后最终都会通过Handler#enqueueMessage()方法将消息进行入队，该方法实现如下： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 可以看到，通过哪种方式获取Message对象，最终都会设置该Message的target。消息的异步与否先不去管，继续往下追代码，之后就进入到了MessageQueue的enqueueMessage()方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123;//obtain message的时候已经清除了in-use的标志 throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse();//添加in-use标志 msg.when = when;//预期处理时间 Message p = mMessages;//消息队列最前面的元素 boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123;//放到最前面 // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&#x27;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();//什么时候p.target会为null? Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123;//前面有异步消息的话不需要wake needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg;//插入队列 &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123;//native代码先不去了解 nativeWake(mPtr); &#125; &#125; return true;&#125; 从上面可以看到，如果队列为空传递过来的时间为0或者小于队列中第一个消息的时间，则将该消息放到队列最前面，否则按照时间顺序放到合适的位置。 消息循环处理上面已经大致介绍过，用来进行消息循环的类是Looper，线程默认是没有关联Looper的，典型的创建Looper上面已经提过了： 123456789101112class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125; 下面就来了解下，这样创建的Looper是怎么和线程绑定起来的，Handler又是怎么和Looper关联起来的以及Looper是怎么取到并处理MessageQueue中的消息的。首先来看下Looper#prepare()方法： 12345678910111213141516 /** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 该方法首先会判断sThreadLocal.get() 是否为null，如不是则抛出异常，从异常内容可以看到每个线程只能创建一个Looper，而且可以推测，Looper的关键在sThreadLocal这个变量。来看下该变量的定义： static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); ThreadLocal是线程局部变量的意思，用来存储和线程相关的变量，是一种实现多线程并发的方式。ThreadLocal中有一个静态内部类ThreadLocalMap，里面存储以ThreadLocal为键，以泛型为值的线程局部变量。Thread内部有一ThreadLocalMap的成员变量，而这个map是在ThreadLocal中维护的，借此Thread和ThreadLocal就发生了关联。 再来看看ThreadLocal#get()方法的内容： 123456789101112131415161718192021/** * Returns the value in the current thread&#x27;s copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread&#x27;s value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 创建Looper之前map为空，所以执行到setInitialValue(): 12345678910111213141516/** * Variant of set() to establish initialValue. Used instead * of set() in case user has overridden the set() method. * * @return the initial value */private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 其中initialValue()得到的结果为null,在该方法会通过createMap(t, null)创建map,并将该ThreadLocal和null关联: 12345678910/** * Create the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @param firstValue value for the initial entry of the map */void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 从上面可以看出prepare()方法中的get()返回值应为null,之后执行set()方法： 1234567891011121314151617/** * Sets the current thread&#x27;s copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread&#x27;s copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 这里的map已经不为null了，所以执行map.set(this, value);在该方法中会将ThreadLoacal关联的值更新为new Looper(quitAllowed),这里只关心Looper相关内容，ThreadLocal详细内容之后再做了解（可以参考这篇文章http://www.iteye.com/topic/103804）。来看下Looper的构造过程： 1234private Looper(boolean quitAllowed/*true*/) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 在Looper的构造方法中初始化了消息队列，而且可以看到Looper中也包含所在线程的引用。到这里Looper的创建就算完成了。 接下来就是Handler的创建了。现在有个疑问，Looper是在Looper.prepare()中创建的，并不是类的成员变量，H那么Handler是怎么和Looper关联起来的？来看下Handler的构造过程： 12345678910/** * Default constructor associates this handler with the &#123;@link Looper&#125; for the * current thread. * * If this thread does not have a looper, this handler won&#x27;t be able to receive messages * so an exception is thrown. */public Handler() &#123; this(null, false);&#125; 从注释可以了解到，没有Looper的线程创建Handler会抛出异常。继续往下追： 123456789101112131415161718192021222324252627282930313233343536/** * Use the &#123;@link Looper&#125; for the current thread with the specified callback interface * and set whether the handler should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */ public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; Handler泄露的代码暂不关心。 mLooper = Looper.myLooper();获取了当前线程的Looper： 1234567/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; mQueue = mLooper.mQueue;说明Handler中的mQueue和Looper中的mQueue对应的是同一个MessageQueue对象。到这里Looper、Handler、MessageQueue都已准备完成，前面也对消息入队的过程做了介绍，下面就可以开始进行消息的loop了，该过程通过Looper.loop()进行。 123456789101112131415161718192021222324252627282930 /** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue;//省略代码 for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123;//表明线程正在退出 // No message indicates that the message queue is quitting. return; &#125; //省略代码 try &#123; msg.target.dispatchMessage(msg); //省略代码 &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; //省略代码 msg.recycleUnchecked(); &#125; &#125; 该方法里建立了一个死循环来不断的获取消息，代码里的关键有三个地方： Message msg = queue.next();用来取消息 msg.target.dispatchMessage(msg);用来分发消息 msg.recycleUnchecked();用来回收消息 先来看看queue.next()的实现 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; //idler类型根据addIdleHandler添加的数据类型而定 //可以在没有消息的时候处理些其他的事情，比如GC等（ActivityThread.GcIdler） keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; 先看下Binder.flushPendingCommands()的注释： 1234567891011/** * Flush any Binder commands pending in the current thread to the kernel * driver. This can be * useful to call before performing an operation that may block for a long * time, to ensure that any pending object references have been released * in order to prevent the process from holding on to objects longer than * it needs to. * @apiSince 1 */public static final native void flushPendingCommands(); 也就是说把当前线程等待的Binder命令都送到Binder driver，以免被阻塞太长时间，具体的实现就先不关心了，这里只看和消息处理相关的内容。 现在的Android版本存在Java和Native两个消息队列。在next()方法中，首先通过nativePollOnce(ptr, nextPollTimeoutMillis);处理native层的messagequeue，其中ptr代表的就是native的Messagequeue，如果没什么要处理的就从java Messagequeue中取消息，如果没有消息或者最前面的消息还没到处理时间，就会给nextPollTimeoutMillis设置一个非零值，然后下一次循环native层就可以多处理会儿，直到取到一个java的Message，next()才会返回。Native层的处理推荐参考《深入理解Android 卷2》第2章中的内容。 在取Java Message时会创建一个死循环，根据now和msg和when字段判断是否取出首个消息，如果第一次循环时第一个消息的时间还没到，则处理IdleHandler，比如进行GC等操作。Binder.flushPendingCommands();尚不清楚是干嘛的，以后再做了解。next()直到取到消息才会返回，除非线程正在退出，此时返回null。 回到Looper的死循环中，消息取出后开始进行消息得分发：msg.target.dispatchMessage(msg); 。很明显，该方法位于Handler中： 123456789101112131415/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 调用顺序为msg.callback.handleCallback -&gt; handler.mCallback.handleMessage -&gt; handlet.handleMessage,其实效果都是一样的，这里只看Handler#handleMessage()方法： 12345/** * Subclasses must implement this to receive messages. */public void handleMessage(Message msg) &#123;&#125; 该方法的实现为空，需要在子类或者匿名内中进行重写。比如： 12345678private final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; //省略代码 &#125; &#125;&#125;; 到目前为止，消息已经得到了处理，整个流程差不多也结束了，之后就是些收尾的工作了。前面在介绍消息池的时候提到过，在消息得到处理后会进行回收，也就是Looper.loop()中的msg.recycleUnchecked();，该方法在前面介绍消息池的时候已经提过了，就不再提了。 总结Looper线程中创建和线程相关的Handler及MessageQueue，Handler在其他线程中发送消息，入队到Looper线程的MessageQueue中，同时Looper不断的从MessageQueue中去取消息，再交还给对应的Handler进行处理。 上面是消息处理的大致流程，之后会了解下Android应用启动的流程，顺便了解下MainThread的消息种类和处理流程。","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://mouzishuo.github.io/categories/Android%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"},{"name":"消息机制","slug":"消息机制","permalink":"https://mouzishuo.github.io/tags/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"}]},{"title":"Privileged Permission Whitelisting","slug":"Privileged Permission Whitelisting","date":"2019-09-26T16:59:23.000Z","updated":"2019-09-26T09:19:24.151Z","comments":true,"path":"2019/09/27/Privileged Permission Whitelisting/","link":"","permalink":"https://mouzishuo.github.io/2019/09/27/Privileged%20Permission%20Whitelisting/","excerpt":"","text":"原文地址：https://source.android.com/devices/tech/config/perms-whitelist 特权白名单Android特权应用指的是位于系统分区的priv-app目录下的应用，这个分区包括： Android 8.1及以下- /system Android 9及以上- /system/, product, /vendor 在过去，设备开发人员几乎无法控制可以向特权应用授予哪些signature|privileged权限。从Android 8.0开始，必须在&#x2F;partition&#x2F;etc&#x2F;permissions下的XML文件中显式的指定授予特权应用的权限，否则不会授给应用对应权限。而在Android 9中，必须显式grant或者deny所有的privileged权限，否则设备无法启动,此时会输出类似下面的log： 12309-21 11:19:46.394 5490 5490 E System : **************09-21 11:19:46.395 5490 5490 E System : **** Failure starting system services09-25 22:04:37.731 19857 19857 E System : java.lang.IllegalStateException: Signature|privileged permissions not in privapp-permissions whitelist: &#123;com.android.phone: android.permission.FORCE_STOP_PACKAGES&#125; privapp-permissions.xml文件只能grant或者deny相同分区下特权应用的权限。比如，vendor分区下的特权应用权限必须在&#x2F;vendor&#x2F;etc&#x2F;permissions下的XML中定义。 只用在‘’android“，也就是framework-res.apk中定义的权限才需要添加黑名单。设备制造商定义的privileged权限任然会被默认授给应用。privapp-permissions.xml中的应用如果不存在对应的分区，则对应的项会被忽略。 添加白名单系统原本的特权白名单定义在framework&#x2F;base&#x2F;data&#x2F;etc&#x2F;下，privapp-permissions-platform.xml中添加的是AOSP中应用的权限。其他应用的权限可以在项目中进行配置，只要保证最后拷贝到应用所在分区的etc&#x2F;permissions目录下即可。 生成白名单可以使用AOSP中的命令行工具development/tools/privapp_permissions/privapp_permissions.py自动生成应用的白名单。 编译系统映像： 123. build/envsetup.shlunch PRODUCT_NAMEmake -j 运行privapp_permissions.py脚本，生成privapp_permissions.py文件，如果设备的/partition/etc/permissions中已经包含白名单，则该工具只会打印出差异内容，也就是说只会打印缺少的signature|privileged权限。 将生成的文件复制到/partition/etc/permissions中，系统启动过程中会读取这些文件。 自定义白名单AOSP中应用的权限已经定义在/partition/etc/permissions/privapp-permissions-platform.xml 如果需要可以自定义。 privapp_permissions.py生成的结果会默认授予所用应用申请的权限，如果有的权限需要拒绝，可以在生成的结果中用deny-permission这个tag进行配置。 查找缺少的权限可以通过配置ro.control_privapp_permissions=log属性来查找确实的权限。此时违规行为会在日志中进行报告，但是仍然会授予权限，这样可以在查找违规行为的同时保证设备能正常工作。 错误消息格式如下： 1PackageManager: Privileged permission &#123;PERMISSION_NAME&#125; for package &#123;PACKAGE_NAME&#125; - not in privapp-permissions whitelist 所有违规行为必须加入白名单，如果未加入，即使这些应用位于priv-app中也不会被授予对应的权限，设备会无法启动。 强制执行白名单白名单设好后，可以通过设置属性ro.control_privapp_permissions=enforce来启用白名单。","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"},{"name":"权限","slug":"权限","permalink":"https://mouzishuo.github.io/tags/%E6%9D%83%E9%99%90/"}]},{"title":"高通ramdump抓取及解析","slug":"高通ramdump抓取及解析","date":"2019-06-25T08:29:08.000Z","updated":"2019-06-25T08:30:19.342Z","comments":true,"path":"2019/06/25/高通ramdump抓取及解析/","link":"","permalink":"https://mouzishuo.github.io/2019/06/25/%E9%AB%98%E9%80%9Aramdump%E6%8A%93%E5%8F%96%E5%8F%8A%E8%A7%A3%E6%9E%90/","excerpt":"","text":"问题场景在做一个高通7.1的SMR版本时，发现了STS中有三个失败项： Test Result Details android.security.sts.Poc16_08#testPocCVE_2014_9904 fail junit.framework.AssertionFailedError: Phone has had a hard reset android.security.sts.Poc16_09#testPocCVE_2016_3866 fail junit.framework.AssertionFailedError: Phone has had a hard reset android.security.sts.Poc17_08#testPocCVE_2017_0747 fail junit.framework.AssertionFailedError 其中PocCVE_2017_0747这项，经过查找对比发现是之前的补丁有遗漏，打上就好，补丁的查找在“查找CVE对应的补丁”中有说明。CVE_2014_9904这一项在JIRA中搜到了解决方法，另外还知道了失败的原因是Audio模块出现了panic，导致手机进入ramdump模式，当时手机的表现是黑屏、adb连接不上，但是用lsusb查看，手机的端口和开机时是一样的。 PocCVE_2016_3866这一失败项和CVE_2014_9904类似，也是Audio模块的panic造成的。在JIRA上没有找到解决方案，只能自己抓取dump信息，看是哪里出了问题。 抓取ramdump参考https://blog.csdn.net/forever_2015/article/details/77434580 ramdump解析参考：https://blog.csdn.net/forever_2015/article/details/70185313 , 在解析的时候，工具的路径最好用sdk里的，或者是Android项目里的，系统自带的可能解析会失败。 分析问题原因123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103[ 90.203334] Unable to handle kernel NULL pointer dereference at virtual address 000000e4[ 90.203352] pgd = ffffffc09fcf4000[ 90.203359] [000000e4] *pgd=0000000000000000, *pud=0000000000000000[ 90.203375] Internal error: Oops: 96000005 [#1] PREEMPT SMP[ 90.203382] Modules linked in: wlan(O)[ 90.203400] CPU: 7 PID: 5029 Comm: CVE-2016-3866 Tainted: G W O 3.18.31 #1[ 90.203406] Hardware name: Qualcomm Technologies, Inc. MSM8937-PMI8950 MTP (DT)[ 90.203414] task: ffffffc0a04f6040 ti: ffffffc054e64000 task.ti: ffffffc054e64000[ 90.203431] PC is at is_connected_output_ep+0x20/0x258[ 90.203442] LR is at snd_soc_dapm_dai_get_connected_widgets+0x4c/0x13c[ 90.203449] pc : [&lt;ffffffc000ae522c&gt;] lr : [&lt;ffffffc000ae8978&gt;] pstate: 60000145[ 90.203454] sp : ffffffc054e677e0[ 90.203460] x29: ffffffc054e677e0 x28: 0000000000000000 [ 90.203470] x27: 0000000000000001 x26: ffffffc09bfb0b00 [ 90.203481] x25: ffffffc00196a000 x24: ffffffc0a3978f00 [ 90.203491] x23: ffffffc09b028810 x22: 0000000000000000 [ 90.203501] x21: ffffffc00188c468 x20: 0000000000000000 [ 90.203511] x19: ffffffc00188c640 x18: 00000000ffffffff [ 90.203520] x17: 0000007f7ea97cb4 x16: ffffffc0001b9704 [ 90.203531] x15: 0000007f7eb1adac x14: 00000000000f4240 [ 90.203540] x13: 0000000000000000 x12: ffffffff0000000b [ 90.203550] x11: 0000001000000011 x10: ffffffc000abac20 [ 90.203560] x9 : 0000000000000000 x8 : ffffffc00d4d3480 [ 90.203570] x7 : 0000000000000000 x6 : 000000000000003f [ 90.203580] x5 : 0000000000000040 x4 : 000000000000000c [ 90.203589] x3 : 00000000ffffffff x2 : ffffffc00188c600 [ 90.203599] x1 : ffffffc054e678d0 x0 : 0000000000000000 [ 90.203610] [ 90.203610] PC: 0xffffffc000ae512c:[ 90.203617] 512c 4b030021 36f80081 91030000 f9406481 14000007 f9406084 d1030084 17ffffdb[ 90.203645] 514c f94004a1 91030000 aa0503e2 97e18302 a8c17bfd d65f03c0 a9be7bfd 910003fd[ 90.203671] 516c f9000bf3 aa0003f3 b9400000 35000200 b940b260 340001c0 f9404e60 b4000060[ 90.203698] 518c 52800081 97ea756f aa1303e0 52800021 97fffac3 2a0003e2 340000a0 f0004c61[ 90.203725] 51ac f9404e60 912b2821 97ea44e0 b940b260 71000c1f b9400260 54000081 71000c1f[ 90.203751] 51cc 54000081 1400000c 71000c1f 54000141 aa1303e0 52800041 97fffab1 2a0003e2[ 90.203778] 51ec 340000a0 f0004c61 f9404e60 912bb021 97ea44ce f9400bf3 a8c27bfd d65f03c0[ 90.203804] 520c a9ba7bfd 910003fd a90153f3 a9025bf5 a90363f7 a9046bf9 a90573fb aa0003f4[ 90.203831] 522c b940e400 36f810c0 f9401a80 f9405402 b9433440 11000400 b9033440 b9400293[ 90.203857] 524c 51004a75 710026bf 540000e8 d2800036 d28040e2 9ad522d5 52800000 ea0202bf[ 90.203884] 526c 54000ee1 aa0103f7 51001e61 7100483f 540001a8 d2800020 9ac12000 d2900021[ 90.203910] 528c f2a00081 ea01001f 540000e0 39419280 360800a0 aa1403e0 97fffa65 b900e680[ 90.203937] 52ac 14000067 39419280 361001a0 7100067f 54000041 3627ff00 51002e60 7100041f[ 90.203963] 52cc 54fffea9 7100367f 540000a1 f9405281 91028280 eb00003f 54fffde1 aa1403f9[ 90.203990] 52ec 910003e0 52800015 f0006efa 9272c416 5280081b f84b0f33 9000175c d100a273[ 90.204017] 530c 9100a260 eb19001f 54000780 f9401a80 f9405401 b9433820 11000400 b9033820[ 90.204045] [ 90.204045] LR: 0xffffffc000ae8878:[ 90.204052] 8878 6b1f02ff 1a9f07e1 5280003c 33000020 39006260 f9400660 97fff123 f9400a60[ 90.204078] 8898 97fff121 f9402673 d1012273 17ffffef 3400009c aa1503e0 52800001 97fffb1e[ 90.204105] 88b8 f901a2bf aa1b03e0 940b6475 3400007c aa1503e0 940019e9 f94047a2 2a1603e0[ 90.204131] 88d8 f9406b21 eb01005f 54000180 97d6e9e1 f9404f80 90004c61 91358421 91008282[ 90.204157] 88f8 f90033a4 f90037a3 97ea3752 f94037a3 f94033a4 17ffffa4 a94153f3 a9425bf5[ 90.204184] 8918 a94363f7 a9446bf9 a94573fb a8c97bfd d65f03c0 a9bb7bfd 910003fd a9025bf5[ 90.204210] 8938 a90153f3 f9001bf7 aa0003f4 2a0103f6 f90027a2 f9404413 9101e275 aa1503e0[ 90.204237] 8958 940b6553 aa1303e0 91094273 97ffec9f f94027a1 35000136 f9401e80 97fff226[ 90.204263] 8978 2a0003f7 f9401e81 aa1303e0 9102c021 97ffec5a 14000008 f9402280 97fff2b4[ 90.204290] 8998 2a0003f7 f9402281 aa1303e0 91028021 97ffec6b 90006ee1 9120a021 b9400820[ 90.204317] 89b8 6b1f001f 5400046d 910003e0 b0001724 9272c402 52800800 f9425084 b9405443[ 90.204344] 89d8 1ac00c60 937d7c00 f8606880 9ac32400 36000300 b9405040 11000400 b9005040[ 90.204370] 89f8 f9401033 b5000113 910003e0 9272c401 b9405020 51000400 b9005020 34000140[ 90.204397] 8a18 1400000c f9400263 2a1703e1 f9400660 2a1603e2 d63f0060 f8410e60 b5ffff40[ 90.204423] 8a38 17fffff2 f9400020 36080040 940b5ac6 aa1503e0 940b6412 2a1703e0 f9401bf7[ 90.204450] 8a58 a94153f3 a9425bf5 a8c57bfd d65f03c0 a9be7bfd 910003fd f9000bf3 aa0003f3[ 90.204477] [ 90.204477] SP: 0xffffffc054e676e0:[ 90.204484] 76e0 0000000c 00000000 00000040 00000000 0000003f 00000000 00000000 00000000[ 90.204510] 7700 0d4d3480 ffffffc0 00000000 00000000 00abac20 ffffffc0 00000011 00000010[ 90.204537] 7720 0000000b ffffffff 00000000 00000000 000f4240 00000000 7eb1adac 0000007f[ 90.204563] 7740 001b9704 ffffffc0 7ea97cb4 0000007f ffffffff 00000000 0188c640 ffffffc0[ 90.204589] 7760 00000000 00000000 0188c468 ffffffc0 00000000 00000000 9b028810 ffffffc0[ 90.204616] 7780 a3978f00 ffffffc0 0196a000 ffffffc0 9bfb0b00 ffffffc0 00000001 00000000[ 90.204642] 77a0 00000000 00000000 54e677e0 ffffffc0 00ae8978 ffffffc0 54e677e0 ffffffc0[ 90.204669] 77c0 00ae522c ffffffc0 60000145 00000000 0196a000 ffffffc0 9bfb0b00 ffffffc0[ 90.204695] 77e0 54e67840 ffffffc0 00ae8978 ffffffc0 0188c640 ffffffc0 a3978f00 ffffffc0[ 90.204721] 7800 0188c468 ffffffc0 00000000 00000000 9b028810 ffffffc0 a3978f00 ffffffc0[ 90.204748] 7820 0196a000 ffffffc0 9bfb0b00 ffffffc0 00000001 00000000 00000000 00000000[ 90.204774] 7840 54e67890 ffffffc0 00aed4b8 ffffffc0 00000000 00000000 0196a000 ffffffc0[ 90.204801] 7860 54e67970 ffffffc0 00000000 00000000 9b028810 ffffffc0 9bfb0b00 ffffffc0[ 90.204827] 7880 00000001 00000000 54e678d0 ffffffc0 54e678e0 ffffffc0 00aed914 ffffffc0[ 90.204854] 78a0 00000000 00000000 9b028810 ffffffc0 9b028810 ffffffc0 54e67a28 ffffffc0[ 90.204881] 78c0 00000000 00000000 000002a0 00000000 0d4d3400 ffffffc0 dc8cb01f cb88537f[ 90.204907] [ 90.204915] Process CVE-2016-3866 (pid: 5029, stack limit = 0xffffffc054e64058)[ 90.204921] Call trace:[ 90.204932] [&lt;ffffffc000ae522c&gt;] is_connected_output_ep+0x20/0x258[ 90.204941] [&lt;ffffffc000ae8978&gt;] snd_soc_dapm_dai_get_connected_widgets+0x4c/0x13c[ 90.204952] [&lt;ffffffc000aed4b8&gt;] dpcm_path_get+0x64/0xe4[ 90.204961] [&lt;ffffffc000aed914&gt;] dpcm_fe_dai_open+0x68/0x3d0[ 90.204972] [&lt;ffffffc000ac0bac&gt;] snd_pcm_open_substream+0x88/0x118[ 90.204982] [&lt;ffffffc000ac0cfc&gt;] snd_pcm_open+0xc0/0x1f0[ 90.204991] [&lt;ffffffc000ac0ed8&gt;] snd_pcm_playback_open+0x44/0x68[ 90.205002] [&lt;ffffffc000aad6dc&gt;] snd_open+0x134/0x14c[ 90.205013] [&lt;ffffffc0001be6e0&gt;] chrdev_open+0x140/0x188[ 90.205024] [&lt;ffffffc0001b7fb0&gt;] do_dentry_open+0x260/0x2d8[ 90.205034] [&lt;ffffffc0001b9270&gt;] vfs_open+0x60/0x6c[ 90.205044] [&lt;ffffffc0001c7b44&gt;] do_last+0x870/0xb58[ 90.205054] [&lt;ffffffc0001c806c&gt;] path_openat+0x240/0x5f0[ 90.205062] [&lt;ffffffc0001c8d48&gt;] do_filp_open+0x40/0xa8[ 90.205071] [&lt;ffffffc0001b962c&gt;] do_sys_open+0x174/0x224[ 90.205080] [&lt;ffffffc0001b9714&gt;] SyS_openat+0x10/0x18[ 90.205090] Code: a90363f7 a9046bf9 a90573fb aa0003f4 (b940e400) [ 90.205100] ---[ end trace 51c768fafb5d0cc0 ]---[ 90.205115] Kernel panic - not syncing: Fatal exception 从上面的log中可以看到出问题的类型是空指针造成的kernel panic，当前执行的函数是[ 90.203431] PC is at is_connected_output_ep+0x20/0x258，其中0x20是函数内部的偏移量。 之后要做的就是确认is_connected_output_ep+0x20对应的是哪一行代码。首先有个gdb加载vmlinux: 1gdb vmlinux 然后可以使用print查看is_connected_output_ep方法的信息： 1234(gdb) print is_connected_output_ep$1 = &#123;int (struct snd_soc_dapm_widget *, struct snd_soc_dapm_widget_list **)&#125; 0xffffffc000ae520c &lt;is_connected_output_ep&gt; 从上面的结果可以看到该方法的起始地址是0xffffffc000ae520c，加上0x20的偏移量就是0xffffffc000ae522c，最后再来看一下这个地址对应的是哪一行代码： 12345678910111213(gdb) list *0xffffffc000ae524c0xffffffc000ae524c is in is_connected_output_ep (/home/android/workdir/p7601/LA.UM.5.6/LINUX/android/kernel/msm-3.18/sound/soc/soc-dapm.c:857).warning: Source file is more recent than executable.857 if (widget-&gt;outputs &gt;= 0)858 return widget-&gt;outputs;859 860 DAPM_UPDATE_STAT(widget, path_checks);861 862 switch (widget-&gt;id) &#123;863 case snd_soc_dapm_supply:864 case snd_soc_dapm_regulator_supply:865 case snd_soc_dapm_clock_supply:866 case snd_soc_dapm_kcontrol: 从上面的内容来看，是soc-dapm.c的857行出了问题，也就是widget为NULL。 确认了出问题的代码，再根据调用栈及上下文做修改即可，调用栈可以在上面的log里看到。","categories":[{"name":"kernel panic","slug":"kernel-panic","permalink":"https://mouzishuo.github.io/categories/kernel-panic/"}],"tags":[{"name":"高通","slug":"高通","permalink":"https://mouzishuo.github.io/tags/%E9%AB%98%E9%80%9A/"}]},{"title":"编译Android内核时找不到openssl/bio.h","slug":"编译Android内核时找不到openssl的bio.sh ","date":"2019-06-24T09:13:55.000Z","updated":"2019-09-19T01:27:45.283Z","comments":true,"path":"2019/06/24/编译Android内核时找不到openssl的bio.sh /","link":"","permalink":"https://mouzishuo.github.io/2019/06/24/%E7%BC%96%E8%AF%91Android%E5%86%85%E6%A0%B8%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0openssl%E7%9A%84bio.sh%20/","excerpt":"","text":"参考：https://blog.csdn.net/qq_41533289/article/details/82985788 环境：Ubuntu 16.04 + Android P 最近重装了系统，从14.04换成了16.04，之后按照官网安装了Android的编译环境，但是在编译Android P的项目时内核部分出现了下面的错误： fatal error: openssl/bio.h: No such file or directory 代码里找不到什么问题，上网搜索得知出现fatal error: openssl&#x2F;×××.h: No such file or directory。是因为没有安装libssl-dev，libssl-dev包含libraries, header files and manpages，他是openssl的一部分，而openssl对ssl进行了实现～ 解决方案： 使用sudo apt-get install libssl-dev来安装libssl-dev即可","categories":[{"name":"编译","slug":"编译","permalink":"https://mouzishuo.github.io/categories/%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"}]},{"title":"查找CVE对应的补丁信息","slug":"查找CVE对应的补丁","date":"2019-06-24T06:03:56.000Z","updated":"2019-09-19T01:23:38.500Z","comments":true,"path":"2019/06/24/查找CVE对应的补丁/","link":"","permalink":"https://mouzishuo.github.io/2019/06/24/%E6%9F%A5%E6%89%BECVE%E5%AF%B9%E5%BA%94%E7%9A%84%E8%A1%A5%E4%B8%81/","excerpt":"","text":"首先查找CVE对应的内部bug号，这个可以查的网站好像挺多的，比如http://www3.cvedetails.com/index.php。查找CVE-2016-3866对应的Google和高通的内部bug号如下： The Qualcomm sound driver in Android before 2016-09-05 on Nexus 5X, 6, and 6P devices allows attackers to gain privileges via a crafted application, aka Android internal bug 28868303 and Qualcomm internal bug CR1032820. 接着查找patch修改的内容有两个方法；一个是在Googlepatch中的code_snippets下根据内部bug号进行查找，首先需要直到Google对应的修改是在哪个月的，在上面的网站查到：http://source.android.com/security/bulletin/2016-09-01.html，也就是说是在2016年9月的补丁，实际上查找后发现是在8月的补丁里。对应ANDROID-28868303这个文件；第二个方法是从高通https://createpoint.qti.qualcomm.com 查找CR1032820，下载一个pdf文件，上面有下载补丁的命令。如果直接从里面的链接下载的话，得到的patch文件打不开，得用文档里的命令，用openssl下载。比如，patch的地址为https://source.codeaurora.org/patches/quic/la/.PATCH_157942_security_patches_QPSIIR_261_20160712.tar.gz， 下载命令为： 1openssl enc -d -aes-256-cbc -in msm-3.18.git-139bc41ece02500c87feef60f14934c719588528.patch -out msm-3.18.git139bc41ece02500c87feef60f14934c719588528.patch.txt -pass &#x27;pass:QV&#125;]-z[NlJAXj!5xm(A0&#x27; 按照文档上得来就行，注意文件名别错了。","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"},{"name":"GMS","slug":"Android/GMS","permalink":"https://mouzishuo.github.io/categories/Android/GMS/"}],"tags":[]},{"title":"Android O项目首次刷机PackageInstaller无法安装和卸载应用","slug":"Android O项目首次刷机PackageInstaller无法安装和卸载应用","date":"2019-02-11T07:29:30.000Z","updated":"2019-02-13T06:39:25.119Z","comments":true,"path":"2019/02/11/Android O项目首次刷机PackageInstaller无法安装和卸载应用/","link":"","permalink":"https://mouzishuo.github.io/2019/02/11/Android%20O%E9%A1%B9%E7%9B%AE%E9%A6%96%E6%AC%A1%E5%88%B7%E6%9C%BAPackageInstaller%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD%E5%BA%94%E7%94%A8/","excerpt":"","text":"1.问题现象 Android O的项目，刷机后首次开机，在文件管理器中选择apk进行安装，packageinstaller闪退，可卸载应用也无法卸载。重启手机后问题消失。 2.问题log 应用安装的log： 12345678910111213141516171819202122232401-01 12:08:06.781 6599 6599 E AndroidRuntime: FATAL EXCEPTION: main01-01 12:08:06.781 6599 6599 E AndroidRuntime: Process: com.google.android.packageinstaller, PID: 659901-01 12:08:06.781 6599 6599 E AndroidRuntime: java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.google.android.packageinstaller/com.android.packageinstaller.InstallInstalling&#125;: java.lang.NullPointerException: Attempt to invoke virtual method &#x27;void android.app.AppOpsManager.checkPackage(int, java.lang.String)&#x27; on a null object reference01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2805)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2883)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.app.ActivityThread.-wrap11(Unknown Source:0)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1613)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.os.Handler.dispatchMessage(Handler.java:106)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.os.Looper.loop(Looper.java:164)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.app.ActivityThread.main(ActivityThread.java:6523)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at java.lang.reflect.Method.invoke(Native Method)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:857)01-01 12:08:06.781 6599 6599 E AndroidRuntime: Caused by: java.lang.NullPointerException: Attempt to invoke virtual method &#x27;void android.app.AppOpsManager.checkPackage(int, java.lang.String)&#x27; on a null object reference01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.os.Parcel.readException(Parcel.java:2019)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.os.Parcel.readException(Parcel.java:1959)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.content.pm.IPackageInstaller$Stub$Proxy.createSession(IPackageInstaller.java:254)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.content.pm.PackageInstaller.createSession(PackageInstaller.java:324)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at com.android.packageinstaller.InstallInstalling.onCreate(InstallInstalling.java:147)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.app.Activity.performCreate(Activity.java:7022)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.app.Activity.performCreate(Activity.java:7013)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1214)01-01 12:08:06.781 6599 6599 E AndroidRuntime: at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2758)01-01 12:08:06.781 6599 6599 E AndroidRuntime: ... 9 more 3.问题分析从来log上看问题的原因是在InstallInstalling启动过程中出现了NPE，问题出现在performLaunchActivity()方法进行binder通信的过程中，即IPackageInstaller$Stub$Proxy.createSession，对端代码为PackageInstallerService，问题出现在其createSession()方法： 123456789101112131415161718192021222324252627282930@Overridepublic int createSession(SessionParams params, String installerPackageName, int userId) &#123; try &#123; return createSessionInternal(params, installerPackageName, userId); &#125; catch (IOException e) &#123; throw ExceptionUtils.wrap(e); &#125;&#125;private int createSessionInternal(SessionParams params, String installerPackageName, int userId) throws IOException &#123; //…… if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) &#123; params.installFlags |= PackageManager.INSTALL_FROM_ADB; &#125; else &#123; // Only apps with INSTALL_PACKAGES are allowed to set an installer that is not the // caller. if (mContext.checkCallingOrSelfPermission(Manifest.permission.INSTALL_PACKAGES) != PackageManager.PERMISSION_GRANTED) &#123; mAppOps.checkPackage(callingUid, installerPackageName); &#125; //…… &#125; //…… return sessionId;&#125; 结合log来看，出问题的就是mAppOps.checkPackage(callingUid, installerPackageName);这行代码，问题原因是mAppOps为null。mAppOps为AppOpsManager的实例，相当于AppOpsService的封装。mAppOps的初始化是在PackageInstallerService中的systemReady()中进行的：mAppOps = mContext.getSystemService(AppOpsManager.class);。Context#getSystemService()获取的服务是在SystemServiceRegistry中注册的： 1234567891011121314151617/** * Manages all of the system services that can be returned by &#123;@link Context#getSystemService&#125;. * Used by &#123;@link ContextImpl&#125;. * @hide */public final class SystemServiceRegistry &#123; static&#123; registerService(Context.APP_OPS_SERVICE, AppOpsManager.class, new CachedServiceFetcher&lt;AppOpsManager&gt;() &#123; @Override public AppOpsManager createService(ContextImpl ctx) throws ServiceNotFoundException &#123; IBinder b = ServiceManager.getServiceOrThrow(Context.APP_OPS_SERVICE); IAppOpsService service = IAppOpsService.Stub.asInterface(b); return new AppOpsManager(ctx, service); &#125;&#125;); &#125;&#125; AppOpsManager是在SystemServiceRegistry的静态代码块中注册的，所以目前来看造成mAppOps为null的原因有以下几种： 有可能是SystemServiceRegistry加载出了问题； 服务或者注册出了问题 mAppOps没有初始化也就是PackageInstallerService的systemReady()没有执行（mAppOps的初始化是该方法的第一行代码）。 第一种可能基本可以排除，因为SystemServiceRegistry中同时注册了很过系统服务，如果这个类加载出了问题，表现出来的现象应该要严重得多。第三种可能性最大，为了进一步分析mAppOps为null的原因，需要抓下首次开机启动时的log，并开启MTK的PMS调试开关（adb shell dumpsys package log a on）。 在抓到的开机log中，发现了大量AppOpsService的log： 123456701-01 12:12:39.507 838 838 I AppOps : Pruning old package com.google.android.inputmethod.latin/com.android.server.AppOpsService$UidState@85b6b67: new uid=1006801-01 12:12:39.508 838 838 I AppOps : Pruning old package com.mediatek.mtklogger/com.android.server.AppOpsService$UidState@2504d14: new uid=1006901-01 12:12:39.508 838 838 I AppOps : Pruning old package com.google.android.tts/com.android.server.AppOpsService$UidState@52519bd: new uid=1006501-01 12:12:39.508 838 838 I AppOps : Pruning old package com.google.android.syncadapters.contacts/com.android.server.AppOpsService$UidState@3d1bbb2: new uid=1006201-01 12:12:39.508 838 838 I AppOps : Pruning old package com.google.android.calendar/com.android.server.AppOpsService$UidState@5295703: new uid=1005501-01 12:12:39.508 838 838 I AppOps : Pruning old package com.android.carrierdefaultapp/com.android.server.AppOpsService$UidState@a6f2680: new uid=1005401-01 12:12:39.508 838 838 I AppOps : Pruning old package com.bootup.receiveimage/com.android.server.AppOpsService$UidState@60e94b9: new uid=10051 说明该服务的注册也是没问题的，所以问题应该就是PackageInstallerService的systemReady()没有执行引起的。而该方法是在PackageManagerService的systemReady()方法中调用的，所以可能是在该方法被调用之前出现了什么异常，导致后面的代码没有执行，PackageManagerService的systemReady()是在SystemServer的startOtherService()中调用的： 1234567traceBeginAndSlog(&quot;MakePackageManagerServiceReady&quot;);try &#123; mPackageManagerService.systemReady();&#125; catch (Throwable e) &#123; reportWtf(&quot;making Package Manager Service ready&quot;, e);&#125;traceEnd(); 也就是说PackageManagerService的systemReady()是允许出现异常的，而且会有异常信息输出，在开机log中搜索“making Package Manager Service ready”（其实最开始搜索的是PackageManager,也找到了出错信息）： 123456789101112131415161701-01 12:12:39.489 838 838 W SystemServer: ***********************************************01-01 12:12:39.492 838 838 E SystemServer: BOOT FAILURE making Package Manager Service ready01-01 12:12:39.492 838 838 E SystemServer: java.lang.SecurityException: Permission android.permission.MANAGE_ACTIVITY_STACKS is not a changeable permission type01-01 12:12:39.492 838 838 E SystemServer: at com.android.server.pm.PackageManagerService.enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(PackageManagerService.java:5717)01-01 12:12:39.492 838 838 E SystemServer: at com.android.server.pm.PackageManagerService.grantRuntimePermission(PackageManagerService.java:5761)01-01 12:12:39.492 838 838 E SystemServer: at com.android.server.pm.PackageManagerService.grantRuntimePermission(PackageManagerService.java:5724)01-01 12:12:39.492 838 838 E SystemServer: at com.android.server.pm.DefaultPermissionGrantPolicy.grantRuntimePermissionsLPw(DefaultPermissionGrantPolicy.java:1066)01-01 12:12:39.492 838 838 E SystemServer: at com.android.server.pm.DefaultPermissionGrantPolicy.grantRuntimePermissionsLPw(DefaultPermissionGrantPolicy.java:1008)01-01 12:12:39.492 838 838 E SystemServer: at com.android.server.pm.DefaultPermissionGrantPolicy.grantDefaultPermissionExceptions(DefaultPermissionGrantPolicy.java:1143)01-01 12:12:39.492 838 838 E SystemServer: at com.android.server.pm.DefaultPermissionGrantPolicy.grantDefaultPermissions(DefaultPermissionGrantPolicy.java:224)01-01 12:12:39.492 838 838 E SystemServer: at com.android.server.pm.PackageManagerService.systemReady(PackageManagerService.java:22721)01-01 12:12:39.492 838 838 E SystemServer: at com.android.server.SystemServer.startOtherServices(SystemServer.java:1715)01-01 12:12:39.492 838 838 E SystemServer: at com.android.server.SystemServer.run(SystemServer.java:412)01-01 12:12:39.492 838 838 E SystemServer: at com.android.server.SystemServer.main(SystemServer.java:280)01-01 12:12:39.492 838 838 E SystemServer: at java.lang.reflect.Method.invoke(Native Method)01-01 12:12:39.492 838 838 E SystemServer: at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)01-01 12:12:39.492 838 838 E SystemServer: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:837) 从log上看，问题出在PackageManagerService的enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission()方法： 123456789101112private static void enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission( PackageParser.Package pkg, BasePermission bp) &#123; int index = pkg.requestedPermissions.indexOf(bp.name); if (index == -1) &#123; throw new SecurityException(&quot;Package &quot; + pkg.packageName + &quot; has not requested permission &quot; + bp.name); &#125; if (!bp.isRuntime() &amp;&amp; !bp.isDevelopment()) &#123; throw new SecurityException(&quot;Permission &quot; + bp.name + &quot; is not a changeable permission type&quot;); &#125;&#125; 从代码上看，满足条件!bp.isRuntime() &amp;&amp; !bp.isDevelopment()时会抛出上面log中的异常。来看下isRuntime()和isDevelopment()是什么含义： 12345678910public boolean isRuntime() &#123;//protectionLevel是dangerous return (protectionLevel &amp; PermissionInfo.PROTECTION_MASK_BASE) == PermissionInfo.PROTECTION_DANGEROUS;&#125;public boolean isDevelopment() &#123;//protectionLevel是PROTECTION_SIGNATURE | PROTECTION_FLAG_DEVELOPMENT return (protectionLevel &amp; PermissionInfo.PROTECTION_MASK_BASE) == PermissionInfo.PROTECTION_SIGNATURE &amp;&amp; (protectionLevel &amp; PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0;&#125; 从adb shell dumpsys package中可以看到android.permission.MANAGE_ACTIVITY_STACKS权限的信息如下： 12345Permission [android.permission.MANAGE_ACTIVITY_STACKS] (c6783bc): sourcePackage=android uid=1000 gids=null type=0 prot=signature|privileged perm=Permission&#123;19e8f45 android.permission.MANAGE_ACTIVITY_STACKS&#125; packageSetting=PackageSetting&#123;2fcec10 android/1000&#125; 从上面的信息来看，这个权限是在包名为android的package，也就是framework-res.apk中定义的，其protectionLevel为signature|privileged，不是runtime也不是development，所以会出现异常。 从dump信息中找到使用了该权限的应用一共有三个： android.uid.shell com.android.systemui com.emoji.keyboard.touchpal.go 前两个应用都是原生就有的，未做修改，所以可以排除。第三个是项目中预置的应用，而且用到了MANAGE_ACTIVITY_STACKS权限。 为什么用到这个权限会引起异常呢？继续看异常的调用栈，分析下出现异常时代码在干什么。从上面的调用栈可以看到，在PackageManagerService#systemReady()方法中调用了DefaultPermissionGrantPolicy#grantDefaultPermissions(): 1234// If we upgraded grant all default permissions before kicking off.for (int userId : grantPermissionsUserIds) &#123; mDefaultPermissionPolicy.grantDefaultPermissions(userId);//用于授予应用默认权限&#125; 而该代码正好在mInstallerService.systemReady();前面执行，所以该部分代码出异常后，mInstallerService的systemReady()方法未得到调用。继续看grantDefaultPermissions()代码： 123456789public void grantDefaultPermissions(int userId) &#123; if (mService.hasSystemFeature(PackageManager.FEATURE_EMBEDDED, 0)) &#123; grantAllRuntimePermissions(userId); &#125; else &#123;//走这个分支 grantPermissionsToSysComponentsAndPrivApps(userId);//授予priv-app默认运行时权限 grantDefaultSystemHandlerPermissions(userId);//授予一些系统核心应用默认的运行时权限，比如拨号，联系人等 grantDefaultPermissionExceptions(userId);//从xml中读取默认运行时权限，可fix，让用户无法修改，权限配置页面会看不到该权限 &#125;&#125; 问题出在grantDefaultPermissionExceptions()这个方法中，该方法用于从&#x2F;system&#x2F;etc&#x2F;default-permissions&#x2F;下的xml文件中读取应用的默认运行时权限，并授予应用。其写法如下： 12345678910111213141516171819202122&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27; standalone=&#x27;yes&#x27; ?&gt;&lt;!-- This file contains permissions to be granted by default. Default permissions are granted to special platform components and to apps that are approved to get default grants. The special components are apps that are expected to work out-of-the-box as they provide core use cases such as default dialer, default email, etc. These grants are managed by the platform. The apps that are additionally approved for default grants are ones that provide carrier specific functionality, ones legally required at some location, ones providing alternative disclosure and opt-out UI, ones providing highlight features of a dedicated device, etc. This file contains only the latter exceptions. Fixed permissions cannot be controlled by the user and need a special approval. Typically these are to ensure either legally mandated functions or the app is considered a part of the OS.--&gt;&lt;exceptions&gt; &lt;exception package=&quot;com.emoji.keyboard.touchpal.go&quot;&gt; &lt;permission name=&quot;android.permission.MANAGE_ACTIVITY_STACKS&quot; fixed=&quot;false&quot;/&gt; &lt;/exception&gt;&lt;/exceptions&gt; 其中的注释很好的说明了该文件的作用：默认权限有两种，一种被授予特殊的平台组件，比如默认dialer，默认email等，这些权限的授予是平台控制的（上面的grantDefaultSystemHandlerPermissions()方法）；另一种是厂商指定的，也就是在项目中配置的。这个文件只包含后者。 从代码上来看，授予默认权限指的都是运行时权限，&#x2F;system&#x2F;etc&#x2F;default-permissions&#x2F;的文件中也只能添加运行时权限或者development权限，否则就会出现异常，但是前面以及了解到android.permission.MANAGE_ACTIVITY_STACKS并不是运行时权限或者development权限，而com.emoji.keyboard.touchpal.go在&#x2F;system&#x2F;etc&#x2F;default-permissions&#x2F;下添加了该权限所以会出现异常。至于为什么重启后该问题会消失，是因为第一次启动虽然产生了异常，但是该权限还是被授予了应用，之后启动就不会走到相同的流程。 4.问题修改只需要将&#x2F;system&#x2F;etc&#x2F;default-permissions&#x2F;中添加的android.permission.MANAGE_ACTIVITY_STACKS权限去掉即可，该权限需要在&#x2F;system&#x2F;etc&#x2F;permissions&#x2F;下进行配置，该目录下xml文件的作用在privapp-permissions-platform.xml文件中的注释有清楚的说明： 1234&lt;!--This XML file declares which signature|privileged permissions should be granted to privilegedapplications that come with the platform--&gt; 5.总结关于默认权限目前已知有以下几种情况： priv-app 系统默认授予运行时权限； 系统核心应用，系统默认授予运行时权限； 项目预置应用的默认运行时权限在&#x2F;system&#x2F;etc&#x2F;default-permissions进行配置； signature|privileged权限在&#x2F;system&#x2F;etc&#x2F;permissions&#x2F;下进行配置。 另外。Android P中android.permission.MANAGE_ACTIVITY_STACKS的权限变成了下面这样： 12345Permission [android.permission.MANAGE_ACTIVITY_STACKS] (69ec6d4): sourcePackage=android uid=1000 gids=null type=0 prot=signature|privileged|development perm=Permission&#123;fbebcd2 android.permission.MANAGE_ACTIVITY_STACKS&#125; packageSetting=PackageSetting&#123;5c62591 android/1000&#125; 多了个development，所以Android P上不存在该问题。 详细的应用权限授予过程还需要进一步了解……","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"}],"tags":[{"name":"PKMS","slug":"PKMS","permalink":"https://mouzishuo.github.io/tags/PKMS/"},{"name":"权限","slug":"权限","permalink":"https://mouzishuo.github.io/tags/%E6%9D%83%E9%99%90/"}]},{"title":"SparseArray","slug":"SparseArray","date":"2019-01-16T03:17:15.840Z","updated":"2019-01-16T03:17:03.268Z","comments":true,"path":"2019/01/16/SparseArray/","link":"","permalink":"https://mouzishuo.github.io/2019/01/16/SparseArray/","excerpt":"","text":"SparseArray稀疏数组，是Android内部特有的api,标准的jdk是没有这个类的. SparseArray保存的是Integer到Object的映射。和普通Array不同，SparseArray允许索引之间存在间隔，在Android中用来替代HashMap&lt;Integer, Object&gt;这种形式，目的是节省内存：一方面，SparseArray不会进行自动装箱的操作；另一方面，SparseArray不依赖于额外的Entry数据结构。 SparseArray的map关系是通过两个数组来实现的，通过二分查找来查找key。这个数据结构的设计意图不是用来存储大量的数据的。通常来说，SparseArray的效率低于HashMap，因为查找需要通过二分查找，而添加和删除需要通过数组的插入和删除操作进行。对于几百项的数据量，性能的差别不大，少于50%. 为了提高性能，SparseArray对删除操作进行了优化：在删除元素，并不会马上把数组中的元素移除，而是会先把该元素标记为已删除。该项在之后可以得到复用（key不变），或者在之后的垃圾回收过程中进行统一的移除。垃圾回收发生在以下几种情况：数据容量需要发生改变、map的size发生改变或者元素值被检索。 SparseArray可以通过keyAt和valueAt方法进行遍历。 SparseArray的成员如下： 可以看到，SparseArray添加和获取删除元素的方式都和HashMap类似。","categories":[{"name":"Android基础","slug":"Android基础","permalink":"https://mouzishuo.github.io/categories/Android%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"Android基础/数据结构","permalink":"https://mouzishuo.github.io/categories/Android%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"},{"name":"数据结构","slug":"数据结构","permalink":"https://mouzishuo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"FLAG_ACTIVITY_TASK_ON_HOME作用","slug":"FLAG_ACTIVITY_TASK_ON_HOME","date":"2019-01-15T08:49:00.000Z","updated":"2019-01-15T08:59:36.727Z","comments":true,"path":"2019/01/15/FLAG_ACTIVITY_TASK_ON_HOME/","link":"","permalink":"https://mouzishuo.github.io/2019/01/15/FLAG_ACTIVITY_TASK_ON_HOME/","excerpt":"","text":"最近做项目时测试提了个问题：查看联系人时，收到新短信，查看短信后，按返回键，回到了launcher而不是联系人（其实不一定要是联系人，其他应用也一样）。看到这个问题第一感觉是“这个问题和应用的启动模式和Flag有关”，然后觉得这不是问题。测试备注了这个”问题“Google对比机上也存在，本来想直接关掉的，但是想想具体原因自己也不清楚，还是看下吧。 这种问题一般看下启动时的flag就能大概找到问题的原因，想看启动时的flag可以通过Android studio调试，也可以直接看log，一般直接用logcat，因为比较简单。抓了下从接收到短信点击通知进入短信到返回桌面的log： 1201-15 08:30:52.510 894 1114 I ActivityManager: START u0 &#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x1000c000 cmp=com.google.android.apps.messaging/.ui.conversationlist.ConversationListActivity&#125; from uid 1008201-15 08:30:52.584 894 1114 I ActivityManager: START u0 &#123;dat=content://com.google.android.apps.messaging.shared.datamodel.BugleContentProvider/conversations/1 flg=0x14000001 cmp=com.google.android.apps.messaging/.ui.conversation.ConversationActivity (has extras)&#125; from uid 10082 其中uid为10082的应用就是com.google.android.apps.messaging。可以看到点击通知后是先进入.ui.conversationlist.ConversationListActivity然后再跳转到.ui.conversation.ConversationActivity的。启动.ui.conversationlist.ConversationListActivity时的flag是0x1000c000，可以拆分成三个flag的组合： 0x10000000：FLAG_ACTIVITY_NEW_TASK 0x00008000:FLAG_ACTIVITY_CLEAR_TASK 0x00004000:FLAG_ACTIVITY_TASK_ON_HOME 第三个flag看起来很像是造成问题的原因，来看下注释： 12345678/** * If set in an Intent passed to &#123;@link Context#startActivity Context.startActivity()&#125;, * this flag will cause a newly launching task to be placed on top of the current * home activity task (if there is one). That is, pressing back from the task * will always return the user to home even if that was not the last activity they * saw. This can only be used in conjunction with &#123;@link #FLAG_ACTIVITY_NEW_TASK&#125;. */public static final int FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000; 也就是说添加这个flag会导致新启动的stack放到当先home activity stack上，再加上FLAG_ACTIVITY_NEW_TASK和FLAG_ACTIVITY_CLEAR_TASK这两个flag，最后的结果就是创建一个新的stack并把activity放到这个stack里，然后把这个stack放到home activity stack上面，该stack变成可见stack，home在它下面，所以这个stack中的activity中的activity都销毁后，home activity stack就会变成可见stack，所以这个问题里按home键会直接从Message进入到launcher。","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"}],"tags":[{"name":"AMS","slug":"AMS","permalink":"https://mouzishuo.github.io/tags/AMS/"},{"name":"Intent","slug":"Intent","permalink":"https://mouzishuo.github.io/tags/Intent/"}]},{"title":"OTA升级后多个应用crash","slug":"OTA升级后，多个应用启动时crash","date":"2019-01-10T04:00:00.000Z","updated":"2019-01-11T08:56:23.504Z","comments":true,"path":"2019/01/10/OTA升级后，多个应用启动时crash/","link":"","permalink":"https://mouzishuo.github.io/2019/01/10/OTA%E5%8D%87%E7%BA%A7%E5%90%8E%EF%BC%8C%E5%A4%9A%E4%B8%AA%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%97%B6crash/","excerpt":"","text":"问题描述Android P的项目，进行OTA升级。升级后多个应用出现异常：启动时crash，切换系统语言后应用名称和图标混乱。恢复出厂设置后正常。 问题场景OTA高版本主要是进行了GMS包的升级，也就是对GMS包中的应用进行了升级，而出现问题的应用也都是GMS包中的应用。 问题分析过程首先当然是收集log。好在问题是必现的，所以就先抓了下有问题的应用的启动log，结果发现各种各样的错误都有：类找不到的、资源找不到的、AndroidManifest文件出错的……毫无规律，加上应用名字和图标的错误，反正问题的整个感觉就是乱。再加上恢复出厂设置后问题会消失，所以基本确定不是应用本身的问题，而是在升级过程中应用的更新出了问题。 接着用adb shell dumpsys package对比了一下OTA前后应用的信息，发现升级前后应用的版本号等信息都没有变化，但是恢复出场后的应用版本是不一样的，但是&#x2F;system分区中的应用拉出来看是换成了新应用的。很明显，就是在升级过程中应用的扫描出了问题，导致应用的信息没有得到更新。那应用的信息为什么没有升级成功呢？恢复出厂设置后问题消失，说明新的版本也是没问题的，恢复出厂主要就是清除&#x2F;data中的东西，而OTA升级是不会清除&#x2F;data的，是不是&#x2F;data中缓存了什么东西导致了应用的信息没有得到更新？ 对这部分的代码不是很清楚，所以就用了个本办法，在PackageManagerService中搜索“OTA”，找到了下面的代码： 123456789101112131415161718// If this is first boot after an OTA, and a normal boot, then// we need to clear code cache directories.// Note that we do *not* clear the application profiles. These remain valid// across OTAs and are used to drive profile verification (post OTA) and// profile compilation (without waiting to collect a fresh set of profiles).if (mIsUpgrade &amp;&amp; !onlyCore) &#123; Slog.i(TAG, &quot;Build fingerprint changed; clearing code caches&quot;); for (int i = 0; i &lt; mSettings.mPackages.size(); i++) &#123; final PackageSetting ps = mSettings.mPackages.valueAt(i); if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123; // No apps are running this early, so no need to freeze clearAppDataLIF(ps.pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY); &#125; &#125; ver.fingerprint = Build.FINGERPRINT;&#125; 里面有个log输出，在正常升级中应该是能输出的，但是做了到userdebug的升级包，抓了log后没发现这个记录，也就是说mIsUpgrade &amp;&amp; !onlyCore这条件不满足。正常启动中!onlyCore这个条件肯定是满足的（加密第一次启动时才不满足），所以mIsUpgrade这个是false的，也就是说PKMS压根就没觉得这是升级了。 看看mIsUpgrade的值是怎么确定的： 12final VersionInfo ver = mSettings.getInternalVersion();mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint); 也就是说比较两个版本的指纹，如果不相同才判定为升级。mSettings.getInternalVersion()的结果可以在dumpsys package的头几行看到： 1234567Database versions: Internal: sdkVersion=28 databaseVersion=3 fingerprint=Mobicel/HYPE/HYPE:8.1.0/O11019/1533524463:user/release-keys External: sdkVersion=28 databaseVersion=3 fingerprint=Mobicel/HYPE/HYPE:8.1.0/O11019/1533524463:user/release-keys 然后看了两个版本的指纹，发现确实是一样的，所以PKMS认为这不是在升级。 在PKMS的构造方法中会对预置的apk进行扫描，不管是不是升级、是不是第一次启动，然后和packages.xml里的信息进行比较。前面也说了手机里的apk已经发生变化了，那么按说扫描过程中也会更新应用的信息吧？这就又回到刚才说的缓存问题了。在PKMS的构造方法里看了下，发现了下面的内容： 1mCacheDir = preparePackageParserCache(mIsUpgrade); 看起来和缓存有关，而且还和升级有关，很可能就是这个了。mCacheDir的作用没有注释，那就进这方法里看下吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private static File preparePackageParserCache(boolean isUpgrade) &#123; if (!DEFAULT_PACKAGE_PARSER_CACHE_ENABLED) &#123;//是否开启缓存 return null; &#125; // Disable package parsing on eng builds to allow for faster incremental development. if (Build.IS_ENG) &#123;//ENG版本不使用缓存 return null; &#125; if (SystemProperties.getBoolean(&quot;pm.boot.disable_package_cache&quot;, false)) &#123; Slog.i(TAG, &quot;Disabling package parser cache due to system property.&quot;); return null; &#125; // The base directory for the package parser cache lives under /data/system/. final File cacheBaseDir = FileUtils.createDir(Environment.getDataSystemDirectory(), &quot;package_cache&quot;); if (cacheBaseDir == null) &#123; return null; &#125; // If this is a system upgrade scenario, delete the contents of the package cache dir. // This also serves to &quot;GC&quot; unused entries when the package cache version changes (which // can only happen during upgrades). if (isUpgrade) &#123; FileUtils.deleteContents(cacheBaseDir); &#125; // Return the versioned package cache directory. This is something like // &quot;/data/system/package_cache/1&quot; File cacheDir = FileUtils.createDir(cacheBaseDir, PACKAGE_PARSER_CACHE_VERSION); if (cacheDir == null) &#123; // Something went wrong. Attempt to delete everything and return. Slog.wtf(TAG, &quot;Cache directory cannot be created - wiping base dir &quot; + cacheBaseDir); FileUtils.deleteContentsAndDir(cacheBaseDir); return null; &#125; // The following is a workaround to aid development on non-numbered userdebug // builds or cases where &quot;adb sync&quot; is used on userdebug builds. If we detect that // the system partition is newer. // // NOTE: When no BUILD_NUMBER is set by the build system, it defaults to a build // that starts with &quot;eng.&quot; to signify that this is an engineering build and not // destined for release. if (Build.IS_USERDEBUG &amp;&amp; Build.VERSION.INCREMENTAL.startsWith(&quot;eng.&quot;)) &#123; Slog.w(TAG, &quot;Wiping cache directory because the system partition changed.&quot;); // Heuristic: If the /system directory has been modified recently due to an &quot;adb sync&quot; // or a regular make, then blow away the cache. Note that mtimes are *NOT* reliable // in general and should not be used for production changes. In this specific case, // we know that they will work. File frameworkDir = new File(Environment.getRootDirectory(), &quot;framework&quot;); if (cacheDir.lastModified() &lt; frameworkDir.lastModified()) &#123; FileUtils.deleteContents(cacheBaseDir); cacheDir = FileUtils.createDir(cacheBaseDir, PACKAGE_PARSER_CACHE_VERSION); &#125; &#125; return cacheDir;&#125; 从上面的代码可以得到这个缓存的以下信息： 可以在代码里通过DEFAULT_PACKAGE_PARSER_CACHE_ENABLED配置是否使用缓存； eng版本默认关闭缓存； 可以通过pm.boot.disable_package_cache属性控制是否使用缓存； 缓存位于&#x2F;data&#x2F;system&#x2F;package_cache&#x2F;； 升级后第一次开机会清空缓存，然后重新创建； 通过adb sync更新system分区的东西后，也会重新创建缓存； 下面再来看下缓存是怎么对应用的更新产生影响的。以前大致了解过PKMS启动过程，PKMS扫描预置应用包含以下流程，PKMS构造方法-&gt;scanDirTracedLI()-&gt; scanDirLI()，然后就进入了应用解析的流程，来看下scanDirLI（）的实现： 1234567891011121314151617181920212223242526//scanDir就是system/app等目录private void scanDirLI(File scanDir, int parseFlags, int scanFlags, long currentTime) &#123; final File[] files = scanDir.listFiles(); if (ArrayUtils.isEmpty(files)) &#123; Log.d(TAG, &quot;No files in app dir &quot; + scanDir); return; &#125; //…… try (ParallelPackageParser parallelPackageParser = new ParallelPackageParser( mSeparateProcesses, mOnlyCore, mMetrics, mCacheDir, mParallelPackageParserCallback)) &#123; // Submit files for parsing in parallel int fileCount = 0; for (File file : files) &#123; final boolean isPackage = (isApkFile(file) || file.isDirectory()) &amp;&amp; !PackageInstallerService.isStageName(file.getName()); if (!isPackage) &#123; // Ignore entries which are not packages continue; &#125; parallelPackageParser.submit(file, parseFlags); fileCount++; &#125; //…… &#125; &#125; 在构造parallelPackageParser时会将mCacheDir传递给构造方法，然后在commit（）中传递给PackageParser，应用的解析最终都是通过PackageParser进行的。 12345678910111213141516171819202122/** * Submits the file for parsing * @param scanFile file to scan * @param parseFlags parse falgs */public void submit(File scanFile, int parseFlags) &#123; mService.submit(() -&gt; &#123; ParseResult pr = new ParseResult(); Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;parallel parsePackage [&quot; + scanFile + &quot;]&quot;); try &#123; //…… pp.setCacheDir(mCacheDir); //…… pr.pkg = parsePackage(pp, scanFile, parseFlags); &#125; catch (Throwable e) &#123; pr.throwable = e; &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; //…… &#125;);&#125; 之后在下面的方法中调用PackageParser中的方法进行应用解析： 1234protected PackageParser.Package parsePackage(PackageParser packageParser, File scanFile, int parseFlags) throws PackageParser.PackageParserException &#123; return packageParser.parsePackage(scanFile, parseFlags, true /* useCaches */);&#125; PackageParser解析应用方法如下： 123456789101112131415161718192021222324252627/** * If &#123;@code useCaches&#125; is true, the package parser might return a cached * result from a previous parse of the same &#123;@code packageFile&#125; with the same * &#123;@code flags&#125;. Note that this method does not check whether &#123;@code packageFile&#125; * has changed since the last parse, it&#x27;s up to callers to do so. * * @see #parsePackageLite(File, int) */public Package parsePackage(File packageFile, int flags, boolean useCaches) throws PackageParserException &#123;//parallelPackageParser传过来的useCaches是true的 Package parsed = useCaches ? getCachedResult(packageFile, flags) : null; if (parsed != null) &#123; return parsed; &#125; long parseTime = LOG_PARSE_TIMINGS ? SystemClock.uptimeMillis() : 0; if (packageFile.isDirectory()) &#123; parsed = parseClusterPackage(packageFile, flags); &#125; else &#123; parsed = parseMonolithicPackage(packageFile, flags); &#125; long cacheTime = LOG_PARSE_TIMINGS ? SystemClock.uptimeMillis() : 0; cacheResult(packageFile, flags, parsed); //…… return parsed;&#125; 注释里说的很清楚，如果使用缓存，则可能返回上次解析的结果（路径和flags一样），不管应用是不是发生了变化，这是调用者应该关心的。代码的逻辑也很简单，如果存在缓存就从缓存了获取结果直接返回；否则重新进行解析，并缓存结果。来看下缓存的获取过程： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Returns the cached parse result for &#123;@code packageFile&#125; for parse flags &#123;@code flags&#125;, * or &#123;@code null&#125; if no cached result exists. */ private Package getCachedResult(File packageFile, int flags) &#123; if (mCacheDir == null) &#123; return null; &#125; final String cacheKey = getCacheKey(packageFile, flags); final File cacheFile = new File(mCacheDir, cacheKey); try &#123; // If the cache is not up to date, return null. if (!isCacheUpToDate(packageFile, cacheFile)) &#123; return null; &#125; final byte[] bytes = IoUtils.readFileAsByteArray(cacheFile.getAbsolutePath()); Package p = fromCacheEntry(bytes); if (mCallback != null) &#123; String[] overlayApks = mCallback.getOverlayApks(p.packageName); if (overlayApks != null &amp;&amp; overlayApks.length &gt; 0) &#123; for (String overlayApk : overlayApks) &#123; // If a static RRO is updated, return null. if (!isCacheUpToDate(new File(overlayApk), cacheFile)) &#123; return null; &#125; &#125; &#125; &#125; return p; &#125; catch (Throwable e) &#123; Slog.w(TAG, &quot;Error reading package cache: &quot;, e); // If something went wrong while reading the cache entry, delete the cache file // so that we regenerate it the next time. cacheFile.delete(); return null; &#125; &#125; 该方法会从以byte数组的形式读取缓存然后再把结果转换成Package对象，也就是说缓存里缓存的不是apk本身，而是对Package对象的持久化。另外有三种情况下缓存会返回null: - 缓存的修改时间比apk的早（可以通过stat命令查看时间）； - apk 任何一个rro的修改时间比缓存修改时间晚； - 获取缓存出错，此时会删除缓存，等下次再生成； 通过上面的代码可以知道，缓存在两种情况下不会影响升级，一是系统认为是升级，会把缓存清掉，等应用解析完再创建；二是应用（或RRO）的修改时间比缓存晚，按说通过OTA后的应用修改时间应该比旧版本的缓存新的，但是不知道为什么，升级后system&#x2F;app的修改时间是2009-01-01的（看了Pixel的时间也是这样，不知道是不是bug），而缓存的时间是最近的，所以最后缓存还是生效了……信息是老的，但是运行的时候是用的新应用，然后就出现了乱七八糟的问题。 总结以前看PKMS扫描应用的时候把缓存部分跳过去了，所以遇到相关问题时还要分析log、重新看代码，解决问题的逻辑也不是很顺畅，不过连蒙带猜结合代码还是找到原因了。虽然发现是指纹的问题，不需要修改，但是补充了一个PKMS的知识点，还是有点收获的。 最后还是简单的总结下这个问题：因为项目还在开发中，为了方便测试，项目负责人设置了一个固定的指纹，导致OTA后PKMS不知道升级了，没有清除缓存；而且OTA后应用的时间是2009年的，导致PKMS认为缓存比应用新，是可用的，所以直接从缓存中反持久化了Package对象，这就导致了应用是新的但是信息是旧的，两者是不匹配的就出了一堆莫名其妙的问题。之前的版本应用没有进行大的改动，所以没发现这个问题，这次恰好升级了GMS包，就暴露了出来。所以说，项目的指纹最好是每个版本自动变化啊……","categories":[],"tags":[{"name":"PKMS","slug":"PKMS","permalink":"https://mouzishuo.github.io/tags/PKMS/"},{"name":"PackageManagerService","slug":"PackageManagerService","permalink":"https://mouzishuo.github.io/tags/PackageManagerService/"}]},{"title":"android:documentLaunchMode属性的作用","slug":"android:documentLaunchMode属性的作用","date":"2018-11-16T09:42:19.798Z","updated":"2018-11-16T09:44:19.722Z","comments":true,"path":"2018/11/16/android:documentLaunchMode属性的作用/","link":"","permalink":"https://mouzishuo.github.io/2018/11/16/android:documentLaunchMode%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"","text":"参考：https://stackoverflow.com/questions/32154059/what-is-the-difference-between-androidlaunchmode-and-androiddocumentlaunchmode android:launcherMode的作用网上有很多介绍，也有大致的了解，但是最近在看源码时发现了一个android:documentLaunchMode，文档上说这个属性的作用也是用来控制Activity的启动的，那它和android:launcherMode有什么区别呢？里面为什么加个document？ 上面给出的stackoverflow的答案解释的比较清楚，先把原文贴一下： Let’s take a quick look at the launchMode values: standard and singleTop both allow multiple instances of an activity to be created, within other tasks. singleTask and singleInstance both limit an activity to a single instance, as the first activity in its task. Anything seem to be missing to you? None of these values allow multiple instances of an activity to be created at the top level. Either you launch instances of your activity into other people’s tasks, or you limit it to a single instance. None of these values allow multiple tasks to be created to host your activity. This oversight is what documentLaunchMode addresses. The idea is that if your activity has an intent filter that allows it to view documents, that each of those documents – each data uri – should be able to get its own instance of your activity in its own task. standard和singleTop允许在一个stack中创建多个Activity的实例；singleTask和singleInstance限制只能有一个Activity的实例，那么如果我想启动两个一样的Activity，而且这两个Activity都作为task里的topActivity该怎么做呢？android:documentLaunchMode就是解决这个问题的，比如说，我有一个用来浏览文档的Activity，我想在浏览每个文档时都创建一个该Activity的实例，这样我可以在多个文档间切换，这个用android:documentLaunchMode就可以实现。 之所以注意到这个属性是因为测试反馈的一个问题：多次点击Google语音搜索的小部件，在最近任务中出现多个语音搜索的实例。第一感觉是Activity启动模式造成的，应该不是问题。但是以防万一还是抓了下Activity启动时的log： 1234❯❯❯ adb logcat | grep START11-16 16:25:48.432 893 984 I ActivityManager: START u0 &#123;act=android.intent.action.MAIN cat=[android.intent.category.HOME] flg=0x10200000 cmp=com.android.launcher3/.Launcher (has extras)&#125; from uid 100011-16 16:25:50.403 893 8188 I ActivityManager: START u0 &#123;act=com.google.android.apps.searchlite.WIDGET_ACTION flg=0x10008000 cmp=com.google.android.apps.searchlite/.ui.SearchActivity bnds=[302,106][338,155] (has extras)&#125; from uid 10024 从log来看Activity启动时Intent传递过来的flag是0x10008000，也就是FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK.先看下FLAG_ACTIVITY_NEW_TASK的注释： 12345678910111213141516171819202122232425/** * If set, this activity will become the start of a new task on this * history stack. A task (from the activity that started it to the * next task activity) defines an atomic group of activities that the * user can move to. Tasks can be moved to the foreground and background; * all of the activities inside of a particular task always remain in * the same order. See * &lt;a href=&quot;&#123;@docRoot&#125;guide/topics/fundamentals/tasks-and-back-stack.html&quot;&gt;Tasks and Back * Stack&lt;/a&gt; for more information about tasks. * * &lt;p&gt;This flag is generally used by activities that want * to present a &quot;launcher&quot; style behavior: they give the user a list of * separate things that can be done, which otherwise run completely * independently of the activity launching them. * * &lt;p&gt;When using this flag, if a task is already running for the activity * you are now starting, then a new activity will not be started; instead, * the current task will simply be brought to the front of the screen with * the state it was last in. See &#123;@link #FLAG_ACTIVITY_MULTIPLE_TASK&#125; for a flag * to disable this behavior. * * &lt;p&gt;This flag can not be used when the caller is requesting a result from * the activity being launched. */public static final int FLAG_ACTIVITY_NEW_TASK = 0x10000000; 注释里提到，如果已经有stack里在运行要启动的Activity，那么不会再创建新的Activity，而是会把之前的Activity带到前台，类似于launcher的行为。再来看下FLAG_ACTIVITY_CLEAR_TASK的注释： 12345678/** * If set in an Intent passed to &#123;@link Context#startActivity Context.startActivity()&#125;, * this flag will cause any existing task that would be associated with the * activity to be cleared before the activity is started. That is, the activity * becomes the new root of an otherwise empty task, and any old activities * are finished. This can only be used in conjunction with &#123;@link #FLAG_ACTIVITY_NEW_TASK&#125;. */public static final int FLAG_ACTIVITY_CLEAR_TASK = 0X00008000; 如果启动Activity时带这个flag，那么和该Activity关联的stack会被清空，将新启动的Activity作为root。 从上面两个flag的注释来看，语音搜索启动的时候不应该有多个实例，而且还是位于不同的栈。然后就调试了下Activity的启动过程，发现ActivityStarter中启动Activity时的mLaunchFlags为403210240，转化成16进制为0x18088000,包含以下几个flag： 1234FLAG_ACTIVITY_NEW_TASKFLAG_ACTIVITY_MULTIPLE_TASKFLAG_ACTIVITY_CLEAR_WHEN_TASK_RESETFLAG_ACTIVITY_CLEAR_TASK 第一个和第四个前面已经了解了，第三个调试过程中发现这个flag没起什么作用，这里就不关心了，可疑的就是FLAG_ACTIVITY_MULTIPLE_TASK了，来看下它的注释： 123456789101112131415161718192021222324252627282930313233343536/** * This flag is used to create a new task and launch an activity into it. * This flag is always paired with either &#123;@link #FLAG_ACTIVITY_NEW_DOCUMENT&#125; * or &#123;@link #FLAG_ACTIVITY_NEW_TASK&#125;. In both cases these flags alone would * search through existing tasks for ones matching this Intent. Only if no such * task is found would a new task be created. When paired with * FLAG_ACTIVITY_MULTIPLE_TASK both of these behaviors are modified to skip * the search for a matching task and unconditionally start a new task. * * &lt;strong&gt;When used with &#123;@link #FLAG_ACTIVITY_NEW_TASK&#125; do not use this * flag unless you are implementing your own * top-level application launcher.&lt;/strong&gt; Used in conjunction with * &#123;@link #FLAG_ACTIVITY_NEW_TASK&#125; to disable the * behavior of bringing an existing task to the foreground. When set, * a new task is &lt;em&gt;always&lt;/em&gt; started to host the Activity for the * Intent, regardless of whether there is already an existing task running * the same thing. * * &lt;p&gt;&lt;strong&gt;Because the default system does not include graphical task management, * you should not use this flag unless you provide some way for a user to * return back to the tasks you have launched.&lt;/strong&gt; * * See &#123;@link #FLAG_ACTIVITY_NEW_DOCUMENT&#125; for details of this flag&#x27;s use for * creating new document tasks. * * &lt;p&gt;This flag is ignored if one of &#123;@link #FLAG_ACTIVITY_NEW_TASK&#125; or * &#123;@link #FLAG_ACTIVITY_NEW_DOCUMENT&#125; is not also set. * * &lt;p&gt;See * &lt;a href=&quot;&#123;@docRoot&#125;guide/topics/fundamentals/tasks-and-back-stack.html&quot;&gt;Tasks and Back * Stack&lt;/a&gt; for more information about tasks. * * @see #FLAG_ACTIVITY_NEW_DOCUMENT * @see #FLAG_ACTIVITY_NEW_TASK */public static final int FLAG_ACTIVITY_MULTIPLE_TASK = 0x08000000; 从注释上看这个flag常和FLAG_ACTIVITY_NEW_DOCUMENT以及FLAG_ACTIVITY_NEW_TASK配合，并且会改变它们的行为，不管之前存不存在stack包含要启动的Activity，都会创建新的Stack来启动Activity。看来语音搜索有多个相同的实例，就是这个引起的了（其实现在看从名字上看就能推测出来，MULTI_TASK正好和现象一致）。 现在又有了一个新的问题，Activity启动时Intent携带的flag明明是0x10008000怎么变成0x18088000了呢？来看下ActivityStater中启动Activity的代码： 1234567891011private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession, voiceInteractor); computeLaunchingTaskFlags(); //……&#125; 从名字上看，似乎computeLaunchingTaskFlags（）是用来计算flag的，但其实setInitialState（）就改变了mLaunchFlag的值，而且查找FLAG_ACTIVITY_MULTIPLE_TASK的引用发现这个flag也是在setInitialState（）方法中添加到mLaunchFlags中的。代码如下： 1234567891011121314private void setInitialState(ActivityRecord r, ActivityOptions options, TaskRecord inTask, boolean doResume, int startFlags, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) &#123; //…… // If we are actually going to launch in to a new task, there are some cases where // we further want to do multiple task. if ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123; if (mLaunchTaskBehind || r.info.documentLaunchMode == DOCUMENT_LAUNCH_ALWAYS) &#123; mLaunchFlags |= FLAG_ACTIVITY_MULTIPLE_TASK; &#125; &#125; //…… &#125; 从上面的代码可以看到在存在FLAG_ACTIVITY_NEW_TASK这个flag时如果mLaunchTaskBehind|| r.info.documentLaunchMode == DOCUMENT_LAUNCH_ALWAYS为true,则会向mLaunchFlags中添加FLAG_ACTIVITY_MULTIPLE_TASK。而r.info.documentLaunchMode == DOCUMENT_LAUNCH_ALWAYS对应的就是AndrodManifest.xml中的android:documentLaunchMode&#x3D;”always”属性。","categories":[{"name":"AMS","slug":"AMS","permalink":"https://mouzishuo.github.io/categories/AMS/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"}]},{"title":"Google Play Store搜索不到应用或提示应用不兼容","slug":"Google Play Store无法搜索应用或提示应用不兼容 ，此类问题该如何定位及分析","date":"2018-11-16T03:39:00.000Z","updated":"2018-11-16T03:51:30.714Z","comments":true,"path":"2018/11/16/Google Play Store无法搜索应用或提示应用不兼容 ，此类问题该如何定位及分析/","link":"","permalink":"https://mouzishuo.github.io/2018/11/16/Google%20Play%20Store%E6%97%A0%E6%B3%95%E6%90%9C%E7%B4%A2%E5%BA%94%E7%94%A8%E6%88%96%E6%8F%90%E7%A4%BA%E5%BA%94%E7%94%A8%E4%B8%8D%E5%85%BC%E5%AE%B9%20%EF%BC%8C%E6%AD%A4%E7%B1%BB%E9%97%AE%E9%A2%98%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%8F%8A%E5%88%86%E6%9E%90/","excerpt":"","text":"原文地址：https://online.mediatek.com/FAQ#/SW/FAQ07984 出现使用Google PlayStore搜索不到应用或应用提示不兼容一般由于以下几个原因： 国家或地区限制，某些应用只在某些国家和地区才能使用，所以Google PlayStore会根据用户当前网络情况屏蔽这些应用； 应用声明需要使用的feature在当前手机未查询到，Google PlayStore也会将此应用屏蔽 第一种情况属于正常情况，可以使用对比机在同样的网络环境下验证。如果您确实需要下载，则可通过vpn翻墙搜索下载。 第二种情况又可分为： 1）手机确实没有相应feature，如GPS 2）手机有但是未声明相应feature，导致系统显示为缺少对此feature的支持 针对1），属于正常情况，如果您一定需要下载，则可通过强制声明此feature方式下载，但是不能保证下载后可以正常安装以及使用。 针对2），这是主要问题，下面给出解决问题操作流程： i. 确保对比机在同样网络条件下可以搜索到，并将此应用下载下来(file.apk) ii. 使用aapt（aapt即AndroidAssetPackagingTool,在SDK的platform-tools目录下）命令 ​ aapt dump badging file.apk &gt; fileInfo.xml ​ 此命令用于查看APK包的packageName、versionCode、applicationLabel、launcherActivity、permission等各种详细信息，请记录应用uses-feature和uses-library项,另外也可以直接将apk反编译，然后查看AndroidManifest.xml中的内容。 iii. 手机连接pc，使用命令： ​ adb shell dumpsys package &gt; package.xml ​ 此命令可显示手机可供应用查询到的library和feature，令外也可以采用adb shell pm list features和adb shell pm list libraries来查看设备支持的feature和library。 iiii. 对比应用需要的与手机声明的feature和library，补上手机缺少的相应feature，Android P的feature声明文件在&#x2F;system&#x2F;etc&#x2F;permissions&#x2F;下面，feature和library的声明示例如下： 12345&lt;!--android.hardware.sensor.gyroscope.xml--&gt;&lt;!-- Feature for devices with gyroscope. --&gt;&lt;permissions&gt; &lt;feature name=&quot;android.hardware.sensor.gyroscope&quot; /&gt;&lt;/permissions&gt; 123456&lt;!--com.google.android.maps.xml--&gt;&lt;permissions&gt; &lt;library name=&quot;com.google.android.maps&quot; file=&quot;/system/framework/com.google.android.maps.jar&quot; /&gt;&lt;/permissions&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"}],"tags":[{"name":"兼容性","slug":"兼容性","permalink":"https://mouzishuo.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"}]},{"title":"Ubuntu samba无法访问服务器","slug":"Ubuntu samba无法访问服务器","date":"2018-11-09T01:30:00.000Z","updated":"2018-11-09T01:30:44.151Z","comments":true,"path":"2018/11/09/Ubuntu samba无法访问服务器/","link":"","permalink":"https://mouzishuo.github.io/2018/11/09/Ubuntu%20samba%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"Ubuntu samba无法访问服务器开始的时候Ubuntu上面是可以访问samba的，后来不知道进行了什么操作无法访问了。在nautilus中输入地址后提示“抱歉,无法显示“×××.×××.×××.××× (smb)”的全部内容:不支持指定位置”。 之后找了很久解决方案，一直没找到。最近不小心把虚拟机给弄崩了，就想再弄下samba，Google了一下，找到了下面的解决方案： 12#安装 gvfs-backends 应该允许Nautilus使用大多数常用协议（包括SMB，SSH等）。sudo apt-get install gvfs-backends 原文地址：https://chubuntu.com/questions/38013/cant-browse-network-from-nautilus.html","categories":[{"name":"Tools","slug":"Tools","permalink":"https://mouzishuo.github.io/categories/Tools/"}],"tags":[{"name":"Ubuntu Samba","slug":"Ubuntu-Samba","permalink":"https://mouzishuo.github.io/tags/Ubuntu-Samba/"}]},{"title":"多个PackageInstaller导致无法开机","slug":"手机存在多个PackageInstaller导致开不了机","date":"2018-09-26T08:16:55.000Z","updated":"2019-09-19T01:32:59.218Z","comments":true,"path":"2018/09/26/手机存在多个PackageInstaller导致开不了机/","link":"","permalink":"https://mouzishuo.github.io/2018/09/26/%E6%89%8B%E6%9C%BA%E5%AD%98%E5%9C%A8%E5%A4%9A%E4%B8%AAPackageInstaller%E5%AF%BC%E8%87%B4%E5%BC%80%E4%B8%8D%E4%BA%86%E6%9C%BA/","excerpt":"","text":"出错信息如下： 123456789101112131415161718192021222324252609-11 15:25:48.414 858 858 E System : ******************************************09-11 15:25:48.414 858 858 E System : ************ Failure starting system services09-11 15:25:48.414 858 858 E System : java.lang.RuntimeException: There must be exactly one installer; found [ResolveInfo&#123;4f7a3fa com.android.packageinstaller/.InstallStart m=0x608000&#125;, ResolveInfo&#123;ec32dab com.google.android.packageinstaller/com.android.packageinstaller.InstallStart m=0x608000&#125;]09-11 15:25:48.414 858 858 E System : at com.android.server.pm.PackageManagerService.getRequiredInstallerLPr(PackageManagerService.java:3538)09-11 15:25:48.414 858 858 E System : at com.android.server.pm.PackageManagerService.&lt;init&gt;(PackageManagerService.java:3189)09-11 15:25:48.414 858 858 E System : at com.android.server.pm.PackageManagerService.main(PackageManagerService.java:2310)09-11 15:25:48.414 858 858 E System : at com.android.server.SystemServer.startBootstrapServices(SystemServer.java:628)09-11 15:25:48.414 858 858 E System : at com.android.server.SystemServer.run(SystemServer.java:429)09-11 15:25:48.414 858 858 E System : at com.android.server.SystemServer.main(SystemServer.java:294)09-11 15:25:48.414 858 858 E System : at java.lang.reflect.Method.invoke(Native Method)09-11 15:25:48.414 858 858 E System : at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)09-11 15:25:48.414 858 858 E System : at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:838)09-11 15:25:48.414 858 858 D SystemServerTiming: StartPackageManagerService took to complete: 682ms09-11 15:25:48.414 858 858 E Zygote : System zygote died with exception09-11 15:25:48.414 858 858 E Zygote : java.lang.RuntimeException: There must be exactly one installer; found [ResolveInfo&#123;4f7a3fa com.android.packageinstaller/.InstallStart m=0x608000&#125;, ResolveInfo&#123;ec32dab com.google.android.packageinstaller/com.android.packageinstaller.InstallStart m=0x608000&#125;]09-11 15:25:48.414 858 858 E Zygote : at com.android.server.pm.PackageManagerService.getRequiredInstallerLPr(PackageManagerService.java:3538)09-11 15:25:48.414 858 858 E Zygote : at com.android.server.pm.PackageManagerService.&lt;init&gt;(PackageManagerService.java:3189)09-11 15:25:48.414 858 858 E Zygote : at com.android.server.pm.PackageManagerService.main(PackageManagerService.java:2310)09-11 15:25:48.414 858 858 E Zygote : at com.android.server.SystemServer.startBootstrapServices(SystemServer.java:628)09-11 15:25:48.414 858 858 E Zygote : at com.android.server.SystemServer.run(SystemServer.java:429)09-11 15:25:48.414 858 858 E Zygote : at com.android.server.SystemServer.main(SystemServer.java:294)09-11 15:25:48.414 858 858 E Zygote : at java.lang.reflect.Method.invoke(Native Method)09-11 15:25:48.414 858 858 E Zygote : at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)09-11 15:25:48.414 858 858 E Zygote : at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:838)09-11 15:25:48.414 858 858 D AndroidRuntime: Shutting down VM--------- beginning of crash 对应PKMS代码： 123456789101112131415161718private @NonNull String getRequiredInstallerLPr() &#123; final Intent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.setDataAndType(Uri.fromFile(new File(&quot;foo.apk&quot;)), PACKAGE_MIME_TYPE); final List&lt;ResolveInfo&gt; matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, MATCH_SYSTEM_ONLY | MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE, UserHandle.USER_SYSTEM); if (matches.size() == 1) &#123; ResolveInfo resolveInfo = matches.get(0); if (!resolveInfo.activityInfo.applicationInfo.isPrivilegedApp()) &#123; throw new RuntimeException(&quot;The installer must be a privileged app&quot;); &#125; return matches.get(0).getComponentInfo().packageName; &#125; else &#123; throw new RuntimeException(&quot;There must be exactly one installer; found &quot; + matches); &#125;&#125; 对应SystemServer代码： 12345678910111213try &#123; traceBeginAndSlog(&quot;StartServices&quot;); startBootstrapServices(); startCoreServices(); startOtherServices(); SystemServerInitThreadPool.shutdown();&#125; catch (Throwable ex) &#123; Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex;&#125; finally &#123; traceEnd();&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"},{"name":"PackageManagerService","slug":"Android/PackageManagerService","permalink":"https://mouzishuo.github.io/categories/Android/PackageManagerService/"},{"name":"PKMS","slug":"Android/PackageManagerService/PKMS","permalink":"https://mouzishuo.github.io/categories/Android/PackageManagerService/PKMS/"}],"tags":[{"name":"PackageInstaller","slug":"PackageInstaller","permalink":"https://mouzishuo.github.io/tags/PackageInstaller/"}]},{"title":"虚拟按键隐藏过程log","slug":"虚拟按键隐藏过程log","date":"2018-09-15T05:22:30.000Z","updated":"2021-06-16T02:56:48.337Z","comments":true,"path":"2018/09/15/虚拟按键隐藏过程log/","link":"","permalink":"https://mouzishuo.github.io/2018/09/15/%E8%99%9A%E6%8B%9F%E6%8C%89%E9%94%AE%E9%9A%90%E8%97%8F%E8%BF%87%E7%A8%8Blog/","excerpt":"","text":"公司最近开始搞Android P的项目，有一天在新的代码上出现了一个奇怪的问题。在点完开机向导后，进入到launcher，发现虚拟按键中的recents不见了，点击那个区域也没反应，但是在系统配置发生改变时（比如切换言）recents又出来了。 刚开始只有一个user版的手机，开机向导过程中的log抓不到，怀疑是别人改了SystemUI造成的也没法验证，为了方便分析问题，只能先编一个userdebug版本。编译时间比较长，闲着也是闲着，就先在代码里看下有没有什么头绪吧。 在SystemUI的代码里搜索关键字“recent”，“disable”，“hide”，最终在StatusBar.java里发现了一个“DISABLE_RECENT”进而找到了framework里的StatusBarManager.java中的以下代码： 123456789101112131415161718192021222324public static final int DISABLE_EXPAND = View.STATUS_BAR_DISABLE_EXPAND;public static final int DISABLE_NOTIFICATION_ICONS = View.STATUS_BAR_DISABLE_NOTIFICATION_ICONS;public static final int DISABLE_NOTIFICATION_ALERTS = View.STATUS_BAR_DISABLE_NOTIFICATION_ALERTS;@Deprecatedpublic static final int DISABLE_NOTIFICATION_TICKER = View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER;public static final int DISABLE_SYSTEM_INFO = View.STATUS_BAR_DISABLE_SYSTEM_INFO;public static final int DISABLE_HOME = View.STATUS_BAR_DISABLE_HOME;public static final int DISABLE_RECENT = View.STATUS_BAR_DISABLE_RECENT;public static final int DISABLE_BACK = View.STATUS_BAR_DISABLE_BACK;public static final int DISABLE_CLOCK = View.STATUS_BAR_DISABLE_CLOCK;public static final int DISABLE_SEARCH = View.STATUS_BAR_DISABLE_SEARCH;@Deprecatedpublic static final int DISABLE_NAVIGATION = View.STATUS_BAR_DISABLE_HOME | View.STATUS_BAR_DISABLE_RECENT;public static final int DISABLE_NONE = 0x00000000;public static final int DISABLE_MASK = DISABLE_EXPAND | DISABLE_NOTIFICATION_ICONS | DISABLE_NOTIFICATION_ALERTS | DISABLE_NOTIFICATION_TICKER | DISABLE_SYSTEM_INFO | DISABLE_RECENT | DISABLE_HOME | DISABLE_BACK | DISABLE_CLOCK | DISABLE_SEARCH; 各种各样的disable，而这些disable都在StatusBar的disable()方法中出现了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * State is one or more of the DISABLE constants from StatusBarManager. */ @Override public void disable(int state1, int state2, boolean animate) &#123; state2 = mRemoteInputQuickSettingsDisabler.adjustDisableFlags(state2); animate &amp;= mStatusBarWindowState != WINDOW_STATE_HIDDEN; final int old1 = mDisabled1; final int diff1 = state1 ^ old1; mDisabled1 = state1; final int old2 = mDisabled2; final int diff2 = state2 ^ old2; mDisabled2 = state2; if (DEBUG) &#123; Log.d(TAG, String.format(&quot;disable1: 0x%08x -&gt; 0x%08x (diff1: 0x%08x)&quot;, old1, state1, diff1)); Log.d(TAG, String.format(&quot;disable2: 0x%08x -&gt; 0x%08x (diff2: 0x%08x)&quot;, old2, state2, diff2)); &#125; StringBuilder flagdbg = new StringBuilder(); flagdbg.append(&quot;disable&lt;&quot;); flagdbg.append(0 != ((state1 &amp; StatusBarManager.DISABLE_EXPAND)) ? &#x27;E&#x27; : &#x27;e&#x27;); flagdbg.append(0 != ((diff1 &amp; StatusBarManager.DISABLE_EXPAND)) ? &#x27;!&#x27; : &#x27; &#x27;); flagdbg.append(0 != ((state1 &amp; StatusBarManager.DISABLE_NOTIFICATION_ICONS)) ? &#x27;I&#x27; : &#x27;i&#x27;); flagdbg.append(0 != ((diff1 &amp; StatusBarManager.DISABLE_NOTIFICATION_ICONS)) ? &#x27;!&#x27; : &#x27; &#x27;); flagdbg.append(0 != ((state1 &amp; StatusBarManager.DISABLE_NOTIFICATION_ALERTS)) ? &#x27;A&#x27; : &#x27;a&#x27;); flagdbg.append(0 != ((diff1 &amp; StatusBarManager.DISABLE_NOTIFICATION_ALERTS)) ? &#x27;!&#x27; : &#x27; &#x27;); flagdbg.append(0 != ((state1 &amp; StatusBarManager.DISABLE_SYSTEM_INFO)) ? &#x27;S&#x27; : &#x27;s&#x27;); flagdbg.append(0 != ((diff1 &amp; StatusBarManager.DISABLE_SYSTEM_INFO)) ? &#x27;!&#x27; : &#x27; &#x27;); flagdbg.append(0 != ((state1 &amp; StatusBarManager.DISABLE_BACK)) ? &#x27;B&#x27; : &#x27;b&#x27;); flagdbg.append(0 != ((diff1 &amp; StatusBarManager.DISABLE_BACK)) ? &#x27;!&#x27; : &#x27; &#x27;); flagdbg.append(0 != ((state1 &amp; StatusBarManager.DISABLE_HOME)) ? &#x27;H&#x27; : &#x27;h&#x27;); flagdbg.append(0 != ((diff1 &amp; StatusBarManager.DISABLE_HOME)) ? &#x27;!&#x27; : &#x27; &#x27;); flagdbg.append(0 != ((state1 &amp; StatusBarManager.DISABLE_RECENT)) ? &#x27;R&#x27; : &#x27;r&#x27;); flagdbg.append(0 != ((diff1 &amp; StatusBarManager.DISABLE_RECENT)) ? &#x27;!&#x27; : &#x27; &#x27;); flagdbg.append(0 != ((state1 &amp; StatusBarManager.DISABLE_CLOCK)) ? &#x27;C&#x27; : &#x27;c&#x27;); flagdbg.append(0 != ((diff1 &amp; StatusBarManager.DISABLE_CLOCK)) ? &#x27;!&#x27; : &#x27; &#x27;); flagdbg.append(0 != ((state1 &amp; StatusBarManager.DISABLE_SEARCH)) ? &#x27;S&#x27; : &#x27;s&#x27;); flagdbg.append(0 != ((diff1 &amp; StatusBarManager.DISABLE_SEARCH)) ? &#x27;!&#x27; : &#x27; &#x27;); flagdbg.append(&quot;&gt; disable2&lt;&quot;); flagdbg.append(0 != ((state2 &amp; StatusBarManager.DISABLE2_QUICK_SETTINGS)) ? &#x27;Q&#x27; : &#x27;q&#x27;); flagdbg.append(0 != ((diff2 &amp; StatusBarManager.DISABLE2_QUICK_SETTINGS)) ? &#x27;!&#x27; : &#x27; &#x27;); flagdbg.append(0 != ((state2 &amp; StatusBarManager.DISABLE2_SYSTEM_ICONS)) ? &#x27;I&#x27; : &#x27;i&#x27;); flagdbg.append(0 != ((diff2 &amp; StatusBarManager.DISABLE2_SYSTEM_ICONS)) ? &#x27;!&#x27; : &#x27; &#x27;); flagdbg.append(0 != ((state2 &amp; StatusBarManager.DISABLE2_NOTIFICATION_SHADE)) ? &#x27;N&#x27; : &#x27;n&#x27;); flagdbg.append(0 != ((diff2 &amp; StatusBarManager.DISABLE2_NOTIFICATION_SHADE)) ? &#x27;!&#x27; : &#x27; &#x27;); flagdbg.append(&#x27;&gt;&#x27;); Log.d(TAG, flagdbg.toString()); if ((diff1 &amp; StatusBarManager.DISABLE_EXPAND) != 0) &#123; if ((state1 &amp; StatusBarManager.DISABLE_EXPAND) != 0) &#123; animateCollapsePanels(); &#125; &#125; if ((diff1 &amp; StatusBarManager.DISABLE_RECENT) != 0) &#123; if ((state1 &amp; StatusBarManager.DISABLE_RECENT) != 0) &#123; // close recents if it&#x27;s visible mHandler.removeMessages(MSG_HIDE_RECENT_APPS); mHandler.sendEmptyMessage(MSG_HIDE_RECENT_APPS); &#125; &#125; if ((diff1 &amp; StatusBarManager.DISABLE_NOTIFICATION_ALERTS) != 0) &#123; mEntryManager.setDisableNotificationAlerts( (state1 &amp; StatusBarManager.DISABLE_NOTIFICATION_ALERTS) != 0); &#125; if ((diff2 &amp; StatusBarManager.DISABLE2_QUICK_SETTINGS) != 0) &#123; updateQsExpansionEnabled(); &#125; if ((diff2 &amp; StatusBarManager.DISABLE2_NOTIFICATION_SHADE) != 0) &#123; updateQsExpansionEnabled(); if ((state1 &amp; StatusBarManager.DISABLE2_NOTIFICATION_SHADE) != 0) &#123; animateCollapsePanels(); &#125; &#125; &#125; 其中mDisabled1和mDisabled2表示之前的disable状态，state1和state2表示新的状态，diff1和diff2表示发生改变的标志位。状态的改变会记录在flagdbg中从代码中来看，如果新的state中包含某个disable标志位，则log中用一个大写字母表示，否则用小写表示；如果某个标志位发生改变，则字母后面会加上一个“!”。三个虚拟按键分别对应B(b),H(b),R(r). 在刷机后抓取了开机向导过程中的log，从其中找到了以下信息: 12309-21 14:21:36.096 1432 1432 D StatusBar: disable1: 0x00000000 -&gt; 0x03a50000 (diff1: 0x03a50000)09-21 14:21:36.097 1432 1432 D StatusBar: disable2: 0x00000000 -&gt; 0x00000010 (diff2: 0x00000010)09-21 14:21:36.097 1432 1432 D StatusBar: disable&lt;E!i A!s b H!R!C!S!&gt; disable2&lt;q i n &gt; 该条记录表示E，A，H，R，C，S等标志位发生了变化。这里只关心三个虚拟按键，b表示back按键还是可用的而且没有发生变化；H!表示home键状态从enable变为disable了;R!表示recents按键也从enable变为了disable。 上面这些内容比较好理解，仅作记录。关于最开始提到的问题，最后发现别人添加功能改出来的，这里就不关心了。","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"}],"tags":[{"name":"SystemUI","slug":"SystemUI","permalink":"https://mouzishuo.github.io/tags/SystemUI/"}]},{"title":"ActivityManagerService启动过程","slug":"ActivityManager启动过程","date":"2018-09-02T03:46:00.000Z","updated":"2019-01-16T01:14:47.560Z","comments":true,"path":"2018/09/02/ActivityManager启动过程/","link":"","permalink":"https://mouzishuo.github.io/2018/09/02/ActivityManager%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/","excerpt":"","text":"ActivityManagerService简称AMS，也就是通常说的组件管理器，是系统核心服务之一，用于对四大组件进行管理，包括创建四大组件，组件生命周期管理等。这里先先了解下AMS的创建过程。代码基于Android P。 AMS的启动是在SystemServer中进行的。SystemServer中服务启动分为三个过程： 123startBootstrapServices();startCoreServices();startOtherServices(); AMS的启动贯穿了这三个过程。 startBootstrapServicesBootstrapServices是指系统启动所需的核心服务，这些服务具有复杂的相互依赖关系所以放到一个地方初始化。其中AMS的初始化代码如下： 1234567// Activity manager runs the show.traceBeginAndSlog(&quot;StartActivityManager&quot;);mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService();mActivityManagerService.setSystemServiceManager(mSystemServiceManager);mActivityManagerService.setInstaller(installer);traceEnd(); 其中mSystemServiceManager是SystemServiceManager的实例用于管理系统服务的创建启动及其他生命周期事件。而 ActivityManagerService.Lifecycle是 ActivityManagerService的静态内部类，继承了SystemService并封装了一些AMS生命周期的回调，代码如下： 1234567891011121314151617181920212223242526272829public static final class Lifecycle extends SystemService &#123; private final ActivityManagerService mService; public Lifecycle(Context context) &#123; super(context); mService = new ActivityManagerService(context); &#125; @Override public void onStart() &#123; mService.start(); &#125; @Override public void onBootPhase(int phase) &#123; mService.mBootPhase = phase; if (phase == PHASE_SYSTEM_SERVICES_READY) &#123; mService.mBatteryStatsService.systemServicesReady(); mService.mServices.systemServicesReady(); &#125; &#125; @Override public void onCleanupUser(int userId) &#123; mService.mBatteryStatsService.onCleanupUser(userId); &#125; public ActivityManagerService getService() &#123; return mService; &#125;&#125; SystemServiceManager的startService()方法是一个泛型方法，用于启动系统服务，其实现如下： 12345678910111213141516171819202122232425262728293031/** * Creates and starts a system service. The class must be a subclass of * &#123;@link com.android.server.SystemService&#125;. * * @param serviceClass A Java class that implements the SystemService interface. * @return The service instance, never null. * @throws RuntimeException if the service fails to start. */@SuppressWarnings(&quot;unchecked&quot;)public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123; try &#123; final String name = serviceClass.getName(); //…… Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, &quot;StartService &quot; + name); //…… final T service; try &#123; Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); &#125; catch (InstantiationException ex) &#123;//…… &#125; catch (IllegalAccessException ex) &#123;//…… &#125; catch (NoSuchMethodException ex) &#123;//…… &#125; catch (InvocationTargetException ex) &#123; //…… &#125; startService(service); return service; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); &#125;&#125; 首先需要通过反射的方法得到service的实例，因为泛型不是具体的类，无法在编译期加载，只能使用反射在运行时动态加载。这里的service指的是ActivityManagerService.Lifecycle，而不是ActivityManagerService本身，之所以这么设计应该是应为ActivityManagerService已经继承了IActivityManager.Stub，无法再继承SystemService。 在LifeCycle的构造方法中构建了AMS的实例，AMS构造方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 // Note: This method is invoked on the main thread but may need to attach various // handlers to other threads. So take care to be explicit about the looper. public ActivityManagerService(Context systemContext) &#123; //…… mContext = systemContext; //…… mSystemThread = ActivityThread.currentActivityThread(); mUiContext = mSystemThread.getSystemUiContext(); //…… mHandlerThread = new ServiceThread(TAG, THREAD_PRIORITY_FOREGROUND, false /*allowIo*/); mHandlerThread.start(); mHandler = new MainHandler(mHandlerThread.getLooper()); mUiHandler = mInjector.getUiHandler(this); mProcStartHandlerThread = new ServiceThread(TAG + &quot;:procStart&quot;, THREAD_PRIORITY_FOREGROUND, false /* allowIo */); mProcStartHandlerThread.start(); mProcStartHandler = new Handler(mProcStartHandlerThread.getLooper()); mConstants = new ActivityManagerConstants(this, mHandler); /* static; one-time init here */ if (sKillHandler == null) &#123; sKillThread = new ServiceThread(TAG + &quot;:kill&quot;, THREAD_PRIORITY_BACKGROUND, true /* allowIo */); sKillThread.start(); sKillHandler = new KillHandler(sKillThread.getLooper()); &#125; mFgBroadcastQueue = new BroadcastQueue(this, mHandler, &quot;foreground&quot;, BROADCAST_FG_TIMEOUT, false); mBgBroadcastQueue = new BroadcastQueue(this, mHandler, &quot;background&quot;, BROADCAST_BG_TIMEOUT, true); mBroadcastQueues[0] = mFgBroadcastQueue; mBroadcastQueues[1] = mBgBroadcastQueue; mServices = new ActiveServices(this); mProviderMap = new ProviderMap(this); mAppErrors = new AppErrors(mUiContext, this); File dataDir = Environment.getDataDirectory(); File systemDir = new File(dataDir, &quot;system&quot;); systemDir.mkdirs();//…… mAppOpsService = mInjector.getAppOpsService(new File(systemDir, &quot;appops.xml&quot;), mHandler);//原生权限管理服务，暂时不管 //…… mTempConfig.setToDefaults(); mTempConfig.setLocales(LocaleList.getDefault()); mConfigurationSeq = mTempConfig.seq = 1; mStackSupervisor = createStackSupervisor(); mStackSupervisor.onConfigurationChanged(mTempConfig); mKeyguardController = mStackSupervisor.getKeyguardController(); mCompatModePackages = new CompatModePackages(this, systemDir, mHandler); //用于对Intent启动的组件进行拦截 mIntentFirewall = new IntentFirewall(new IntentFirewallInterface(), mHandler); mTaskChangeNotificationController = new TaskChangeNotificationController(this, mStackSupervisor, mHandler); mActivityStartController = new ActivityStartController(this); mRecentTasks = createRecentTasks(); mStackSupervisor.setRecentTasks(mRecentTasks); mLockTaskController = new LockTaskController(mContext, mStackSupervisor, mHandler); mLifecycleManager = new ClientLifecycleManager(); //…… mHiddenApiBlacklist = new HiddenApiSettings(mHandler, mContext); Watchdog.getInstance().addMonitor(this); Watchdog.getInstance().addThread(mHandler); // bind background thread to little cores // this is expected to fail inside of framework tests because apps can&#x27;t touch cpusets directly // make sure we&#x27;ve already adjusted system_server&#x27;s internal view of itself first updateOomAdjLocked(); //…… &#125; 首先是进行Context和ActivityThread等成员的初始化，ActivityThread这个东西挺重要的，之后还要好好了解下，这里先关注主线流程。 AMS初始化过程中创建了三个ServiceThread，关于ServiceThread在了解PKMS的时候就接触过了，是系统服务专用的一个HandlerThread类，也就是一个带消息循环的线程，用来帮系统服务分担工作的，所以也不需要担心系统服务会不会管的事情太多而忙不过来。 前面说了AMS是管理四大组件的，接下来AMS首先创建了两个BroadcastQueue，一个是前台优先级的，一个是后台优先级的，用于进行广播的管理。 有了广播当然也要有Service和provider了，这两种组件分别用ActiveServices和ProviderMap进行管理，四大组件已经有了三个了，至于重头戏Activity还在后面，等下再说。 再然后会试着创建&#x2F;data&#x2F;system&#x2F;目录，如果已存在的话就什么都不做。这个目录目测是用来存储一些系统用到的持久化文件的。 后面还有一堆的初始化工作，很多还不知道是干什么的，就先挑感兴趣的来看下。前面说了四大组件就差Activity了，Activity是通过什么来管理呢？其实是通过mStackSupervisor，这是一个ActivityStackSupervisor的实例，顾名思义是用来管理ActivityStack的，这个ActivityStack并不是平时说的任务栈，ActivityStack的内部管理着一个TaskRecord的列表，这个TaskRecord才是通常说的任务栈，而TaskRecord中维护着一个ActivityRecord的ArrayList，而这个ActivityRecord就是Activity在AMS中的表示。来看下mStackSupervisor的创建过程： 12345protected ActivityStackSupervisor createStackSupervisor() &#123; final ActivityStackSupervisor supervisor = new ActivityStackSupervisor(this, mHandler.getLooper()); supervisor.initialize(); return supervisor;&#125; 里面的mHandler在前面出现过，是mHandlerThread这个ServiceThread的handler，也就是说和ActivityStackSupervisor相关的消息也不是在主线程处理的。在initialize()方法中会初始化RunningTasks实例，用以表示系统中正在运行的Task。 平时经常用到的最近任务也是在这里进行创建的： 12mRecentTasks = createRecentTasks();mStackSupervisor.setRecentTasks(mRecentTasks); createRecentTasks()调用了RecentTasks的构造方法： 12345678910RecentTasks(ActivityManagerService service, ActivityStackSupervisor stackSupervisor) &#123; final File systemDir = Environment.getDataSystemDirectory(); final Resources res = service.mContext.getResources(); mService = service; mUserController = service.mUserController; mTaskPersister = new TaskPersister(systemDir, stackSupervisor, service, this); mGlobalMaxNumTasks = ActivityManager.getMaxRecentTasksStatic(); mHasVisibleRecentTasks = res.getBoolean(com.android.internal.R.bool.config_hasRecents); loadParametersFromResources(res);&#125; mTaskPersister用于进行taskid的持久化，将taskId写入&#x2F;data&#x2F;system_de&#x2F;0&#x2F;persisted_taskIds.txt文件。mGlobalMaxNumTasks表示最大的任务数，低内存设备为36，非低内存设备48.mHasVisibleRecentTasks表示最近任务是否可见，可通过com.android.internal.R.bool.config_hasRecents这个资源进行配置，除此之外还可以进行以下配置： 1234567891011121314151617181920212223242526272829303132&lt;!-- Component name for the activity that will be presenting the Recents UI, which will receive special permissions for API related to fetching and presenting recent tasks. The default configuration uses Launcehr3QuickStep as default launcher and points to the corresponding recents component. When using a different default launcher, change this appropriately or use the default systemui implementation: com.android.systemui/.recents.RecentsActivity --&gt;&lt;string name=&quot;config_recentsComponentName&quot; translatable=&quot;false&quot;&gt;com.android.launcher3/com.android.quickstep.RecentsActivity&lt;/string&gt;&lt;!-- The minimum number of visible recent tasks to be presented to the user through the SystemUI. Can be -1 if there is no minimum limit. --&gt;&lt;integer name=&quot;config_minNumVisibleRecentTasks_grid&quot;&gt;-1&lt;/integer&gt;&lt;!-- The maximum number of visible recent tasks to be presented to the user through the SystemUI. Can be -1 if there is no maximum limit. --&gt;&lt;integer name=&quot;config_maxNumVisibleRecentTasks_grid&quot;&gt;9&lt;/integer&gt;&lt;!-- The minimum number of visible recent tasks to be presented to the user through the SystemUI. Can be -1 if there is no minimum limit. --&gt;&lt;integer name=&quot;config_minNumVisibleRecentTasks_lowRam&quot;&gt;-1&lt;/integer&gt;&lt;!-- The maximum number of visible recent tasks to be presented to the user through the SystemUI. Can be -1 if there is no maximum limit. --&gt;&lt;integer name=&quot;config_maxNumVisibleRecentTasks_lowRam&quot;&gt;9&lt;/integer&gt;&lt;!-- The minimum number of visible recent tasks to be presented to the user through the SystemUI. Can be -1 if there is no minimum limit. --&gt;&lt;integer name=&quot;config_minNumVisibleRecentTasks&quot;&gt;5&lt;/integer&gt;&lt;!-- The maximum number of visible recent tasks to be presented to the user through the SystemUI. Can be -1 if there is no maximum limit. --&gt;&lt;integer name=&quot;config_maxNumVisibleRecentTasks&quot;&gt;-1&lt;/integer&gt;&lt;!-- The duration in which a recent task is considered in session and should be visible. --&gt;&lt;integer name=&quot;config_activeTaskDurationHours&quot;&gt;6&lt;/integer&gt; 除了config_hasRecents之外的配置项在Android O中还是没有的，其中config_recentsComponentName可以配置显示最近任务的组件，Android P中有两个组件可以显示最近任务，一个是launcher的com.android.launcher3&#x2F;com.android.quickstep.RecentsActivity，一个是SystemUI的 com.android.systemui&#x2F;.recents.RecentsActivity，默认采用launcher中的组件。 后面关于hidden api和性能的代码暂时不做了解。 好了，AMS的初始化到这里就结束了，之后通过mActivityManagerService.setSystemServiceManager(mSystemServiceManager);设置AMS的管理器。 startCoreServices在该方法中只是将AMS和UsageStatsManager进行关联，至于UsageStatsManager是干吗的暂时不关心。 startOtherServices该方法中AMS出现了这么几次，挑其中几个感兴趣的来了解下： installSystemProviders, 安装系统的provider，包括Settings.System,Settings.Secure,Settings.Global等内容，该方法的代码： 123456789101112131415161718192021222324252627282930313233343536public final void installSystemProviders() &#123; List&lt;ProviderInfo&gt; providers; synchronized (this) &#123; ProcessRecord app = mProcessNames.get(&quot;system&quot;, SYSTEM_UID); providers = generateApplicationProvidersLocked(app); if (providers != null) &#123; for (int i=providers.size()-1; i&gt;=0; i--) &#123; ProviderInfo pi = (ProviderInfo)providers.get(i); if ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == 0) &#123; Slog.w(TAG, &quot;Not installing system proc provider &quot; + pi.name + &quot;: not system .apk&quot;); providers.remove(i); &#125; &#125; &#125; &#125; if (providers != null) &#123; mSystemThread.installSystemProviders(providers); &#125; synchronized (this) &#123; mSystemProvidersInstalled = true; &#125; mConstants.start(mContext.getContentResolver()); mCoreSettingsObserver = new CoreSettingsObserver(this); mFontScaleSettingObserver = new FontScaleSettingObserver(); mDevelopmentSettingsObserver = new DevelopmentSettingsObserver(); GlobalSettingsToPropertiesMapper.start(mContext.getContentResolver()); // Now that the settings provider is published we can consider sending // in a rescue party. RescueParty.onSettingsProviderPublished(mContext); //mUsageStatsService.monitorPackages(); &#125; 首先通过mProcessNames.get(&quot;system&quot;, SYSTEM_UID); 获取进程名为system，uid为SystemUID（1000）的进程，然后获取该进程中的provider信息，值得注意的是，进程名为system（android:process=&quot;system&quot;），sharedUid为system(android:sharedUserId&#x3D;”android.uid.system”)的应用有多个，常用到的SettingsProvider就是其中之一，但是包含provider的只有framework-res和SettingsProvider这两个（cts里还有一个，但是不算在内），这部分主要就是针对SettingsProvider的。 之后通过mSystemThread.installSystemProviders(providers); 对获取的providers进行安装，也就是放到mProviderMap中，再然后就是对各种provider添加observer。关于provider的处理在以后单独了解，这里知道有这回事就行。 watchdog.init(context, mActivityManagerService);初始化看门狗，暂不了解。 mActivityManagerService.setWindowManager(wm);关联WMS实例，代码如下： 1234567public void setWindowManager(WindowManagerService wm) &#123; synchronized (this) &#123; mWindowManager = wm; mStackSupervisor.setWindowManager(wm); mLockTaskController.setWindowManager(wm); &#125;&#125; 在这个时候调用这个方法是因为AMS需要和WMS交互但是在AMS初始化的过程中WMS实例还不存在（是在otherService中生成的），所以需要在WMS生成后和AMS进行关联。 mActivityManagerService.systemReady，代码比较长，只挑其中几个感兴趣的片段来看下： 12345678910111213141516171819202122232425262728293031323334353637mActivityManagerService.systemReady(() -&gt; &#123; Slog.i(TAG, &quot;Making services ready&quot;); traceBeginAndSlog(&quot;StartActivityManagerReadyPhase&quot;); //通知系统服务，SystemServer到了PHASE_ACTIVITY_MANAGER_READY阶段 mSystemServiceManager.startBootPhase( SystemService.PHASE_ACTIVITY_MANAGER_READY); traceEnd(); traceBeginAndSlog(&quot;StartObservingNativeCrashes&quot;); try &#123;//添加NativeCrashListener mActivityManagerService.startObservingNativeCrashes(); &#125; catch (Throwable e) &#123; reportWtf(&quot;observing native crashes&quot;, e); &#125; traceEnd(); //…… traceBeginAndSlog(&quot;StartSystemUI&quot;); try &#123;//启动SystemUI的com.android.systemui.SystemUIService //并通知WMS，绑定keyguard startSystemUi(context, windowManagerF); &#125; catch (Throwable e) &#123; reportWtf(&quot;starting System UI&quot;, e); &#125; traceEnd(); //…… traceBeginAndSlog(&quot;StartWatchdog&quot;); Watchdog.getInstance().start(); traceEnd(); // Wait for all packages to be prepared mPackageManagerService.waitForAppDataPrepared(); //…… // 所有的package data已准备完成，可以运行第三方的代码了，通知系统服务 mSystemServiceManager.startBootPhase( SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); traceEnd(); //…… &#125;, BOOT_TIMINGS_TRACE_LOG); 在systemReady方法中，runnable运行之后会启动homeActivity:startHomeActivityLocked(currentUserId, &quot;systemReady&quot;); 。 ​ 以上就是AMS启动的大致流程，主要就是创建AMS实例、关联其他服务，以及启动完成三个阶段，其中有很多内容未做了解，有些理解可能也不太到位，这里仅对已了解内容作个记录，以后再进行补充和修正。","categories":[{"name":"AMS","slug":"AMS","permalink":"https://mouzishuo.github.io/categories/AMS/"},{"name":"Android","slug":"AMS/Android","permalink":"https://mouzishuo.github.io/categories/AMS/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"https://mouzishuo.github.io/tags/ActivityManagerService/"}]},{"title":"应用安装-点击apk安装","slug":"应用安装-点击apk安装","date":"2018-08-27T16:00:00.000Z","updated":"2018-08-30T06:39:16.686Z","comments":true,"path":"2018/08/28/应用安装-点击apk安装/","link":"","permalink":"https://mouzishuo.github.io/2018/08/28/%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85-%E7%82%B9%E5%87%BBapk%E5%AE%89%E8%A3%85/","excerpt":"","text":"之前了解了通过adb进行应用安装的过程，现在了解在应用中点击apk进行应用安装的过程，代码基于Android P。安装流程的PKMS部分和通过adb安装类似，这里主要是了解下应用安装发起过程和PackageInstaller相关代码。 发起安装该部分以DocumentsUI为例，了解应用安装发起的过程。打开Files应用，切换到内部存储，找到apk，点击安装。对应的代码如下： 1234567891011private void onDocumentPicked(DocumentInfo doc, @ViewType int type, @ViewType int fallback) &#123; //…… // For APKs, even if the type is preview, we send an ACTION_VIEW intent to allow // PackageManager to install it. This allows users to install APKs from any root. // The Downloads special case is handled above in #manageDocument. if (MimeTypes.isApkType(doc.mimeType)) &#123; viewDocument(doc); return; &#125; //…… &#125; 1234567891011private boolean viewDocument(DocumentInfo doc) &#123; //…… Intent intent = buildViewIntent(doc); try &#123; mActivity.startActivity(intent); return true; &#125; catch (ActivityNotFoundException e) &#123; mDialogs.showNoApplicationFound(); &#125; return false;&#125; 12345678910111213141516171819private Intent buildViewIntent(DocumentInfo doc) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); //doc.derivedUri = content://com.android.externalstorage.documents/document/primary%3ATurbo.apk（%3A代表：） //doc.mimeType = APK_TYPE = &quot;application/vnd.android.package-archive&quot; intent.setDataAndType(doc.derivedUri, doc.mimeType); // Downloads has traditionally added the WRITE permission // in the TrampolineActivity. Since this behavior is long // established, we set the same permission for non-managed files // This ensures consistent behavior between the Downloads root // and other roots. int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION; if (doc.isWriteSupported()) &#123; flags |= Intent.FLAG_GRANT_WRITE_URI_PERMISSION; &#125; intent.setFlags(flags); return intent;&#125; 上面代码中Intent的描述如下： 123Intent &#123; act=android.intent.action.VIEW dat=content://com.android.externalstorage.documents/document/primary:Turbo.apk typ=application/vnd.android.package-archive flg=0x800003 cmp=com.android.packageinstaller/.InstallStart &#125; 满足条件的Activity为PackageInstaller中的com.android.packageinstaller.InstallStart. 安装开始安装开始对应InstallStart这个类，这个类的onCreate()中没有调用setContentView()方法，没有可见的内容，用于选择安装过程中第一个可见的Activity，并把intent转给他。具体情况如下： 12345678910111213141516171819202122232425262728293031 Intent nextActivity = new Intent(intent); //多个Activity的值传递。ActivityA到达ActivityB再到达ActivityC， //但ActivityB为过渡页可以finish了，此时ActivityC将值透传至ActivityA。 nextActivity.setFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); // The the installation source as the nextActivity thinks this activity is the source, hence // set the originating UID and sourceInfo explicitly nextActivity.putExtra(PackageInstallerActivity.EXTRA_CALLING_PACKAGE, callingPackage); nextActivity.putExtra(PackageInstallerActivity.EXTRA_ORIGINAL_SOURCE_INFO, sourceInfo); nextActivity.putExtra(Intent.EXTRA_ORIGINATING_UID, originatingUid); //PackageInstallerSession已存在，此时Activity是从PackageInstallerSession的commitLocked方法中启动的 if (PackageInstaller.ACTION_CONFIRM_PERMISSIONS.equals(intent.getAction())) &#123; nextActivity.setClass(this, PackageInstallerActivity.class); &#125; else &#123; Uri packageUri = intent.getData(); //从Android 7开始不能把file://类型的url传递给其他应用了 if (packageUri != null &amp;&amp; (packageUri.getScheme().equals(ContentResolver.SCHEME_FILE) || packageUri.getScheme().equals(ContentResolver.SCHEME_CONTENT))) &#123; // Copy file to prevent it from being changed underneath this process nextActivity.setClass(this, InstallStaging.class); &#125; else if (packageUri != null &amp;&amp; packageUri.getScheme().equals( PackageInstallerActivity.SCHEME_PACKAGE)) &#123; nextActivity.setClass(this, PackageInstallerActivity.class); &#125; else &#123;//…… &#125; &#125; if (nextActivity != null) &#123; startActivity(nextActivity); &#125; 在这里走的是packageUri.getScheme()为content这个分支 ，所以下个Activity为InstallStaging。 将apk暂存到临时文件InstallStaging用于见apk复制到&#x2F;data分区下的临时目录，然后将url进行转换并跳到DeleteStagedFileOnResult这个Activity。 转化后的url如下： 1Intent &#123; act=android.intent.action.VIEW dat=file:///data/user_de/0/com.android.packageinstaller/no_backup/package5143412883397554305.apk flg=0x2000000 cmp=com.android.packageinstaller/.DeleteStagedFileOnResult (has extras) &#125; 此时的界面是这个样子的： 临时文件的路径如下： 1/data/user_de/0/com.android.packageinstaller/no_backup/package3066602231324109028.apk DeleteStagedFileOnResult只是一个跳板用于跳转到PackageInstallerActivity，并在onActivityResult中删除临时文件。 用户确认 &amp; 安装初始化关于PackageInstallerActivity这个类，注释上是这么说的：当通过sideload(关于sideload的概念可以wiki一下)的方式安装应用时会启动这个类。首先对package进行解析，如果解析出错会弹框通知用户，也就是常见的包解析错误。解析成功后通知用户打开“安装未知应用”的设置，如果应用已存在，会通知用户确认是否替换当前应用。 看下该类的onCreate方法里的关键代码： 123456789101112 protected void onCreate(Bundle icicle) &#123;//…… boolean wasSetUp = processPackageUri(packageUri); if (!wasSetUp) &#123; return; &#125; // load dummy layout with OK button disabled until we override this layout in // startInstallConfirm bindUi(R.layout.install_confirm, false); checkIfAllowedAndInitiateInstall(); &#125; 首先是处理packageUri，根据uri解析apk，得到PackageInfo，并获取AppSnippet，其中包含title和图标的信息。然后根据AppSnippet更新界面。之后检查是否允许安装应用并初始化安装过程，检查过程暂不关心，来看下安装的初始化过程，也就是initiateInstall方法的内容： 1234567891011121314151617181920212223242526private void initiateInstall() &#123; String pkgName = mPkgInfo.packageName; // Check if there is already a package on the device with this name // but it has been renamed to something else. String[] oldName = mPm.canonicalToCurrentPackageNames(new String[] &#123; pkgName &#125;); if (oldName != null &amp;&amp; oldName.length &gt; 0 &amp;&amp; oldName[0] != null) &#123; pkgName = oldName[0]; mPkgInfo.packageName = pkgName; mPkgInfo.applicationInfo.packageName = pkgName; &#125; // Check if package is already installed. display confirmation dialog if replacing pkg try &#123; // This is a little convoluted because we want to get all uninstalled // apps, but this may include apps with just data, and if it is just // data we still want to count it as &quot;installed&quot;. mAppInfo = mPm.getApplicationInfo(pkgName, PackageManager.MATCH_UNINSTALLED_PACKAGES); if ((mAppInfo.flags&amp;ApplicationInfo.FLAG_INSTALLED) == 0) &#123; mAppInfo = null; &#125; &#125; catch (NameNotFoundException e) &#123; mAppInfo = null; &#125; startInstallConfirm();&#125; 主要是检测是该应用是否已安装，然后进行安装确认。 1234567891011121314151617181920212223 private void startInstallConfirm() &#123; // We might need to show permissions, load layout with permissions if (mAppInfo != null) &#123; bindUi(R.layout.install_confirm_perm_update, true); &#125; else &#123; bindUi(R.layout.install_confirm_perm, true); &#125;//…… if (mScrollView == null) &#123; // There is nothing to scroll view, so the ok button is immediately // set to install. mOk.setText(R.string.install); mOkCanInstall = true; &#125; else &#123; mScrollView.setFullScrollAction(new Runnable() &#123; @Override public void run() &#123; mOk.setText(R.string.install); mOkCanInstall = true; &#125; &#125;); &#125; &#125; 大部分是进行UI的设置，根据是安装新的应用还是更新已有应用界面会有所不同，bindUi（）除了设置contentView外还会设置主要按键的listener，安装按键的事件处理如下： 1234567891011121314if (v == mOk) &#123; if (mOk.isEnabled()) &#123; if (mOkCanInstall || mScrollView == null) &#123; if (mSessionId != -1) &#123; mInstaller.setPermissionsResult(mSessionId, true); finish(); &#125; else &#123; startInstall(); &#125; &#125; else &#123; mScrollView.pageScroll(View.FOCUS_DOWN); &#125; &#125;&#125; 如果安装正在进行则结束该安装，否则调用startInstal()进行安装。 123456789101112 private void startInstall() &#123; // Start subactivity to actually install the application Intent newIntent = new Intent(); newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO, mPkgInfo.applicationInfo); newIntent.setData(mPackageURI); newIntent.setClass(this, InstallInstalling.class);//…… newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); startActivity(newIntent); finish(); &#125; 主要是在进行intent的构建，主要包含applicationInfo和URI等信息。然后跳转到InstallInstalling，这里又看到了FLAG_ACTIVITY_FORWARD_RESULT这个flag，所以InstallInstalling的结果会传给PackageInstallerActivity前一个activity，也就是DeleteStagedFileOnResult。 安装进行中InstallInstalling负责将package的信息传递给package manager并处理package manager传回的结果，如果安装成功启动InstallSuccess，失败则跳转到InstallFailed. 先来看下InstallInstalling的onCreate()方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.install_installing); ApplicationInfo appInfo = getIntent() .getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO); mPackageURI = getIntent().getData(); if (&quot;package&quot;.equals(mPackageURI.getScheme())) &#123; try &#123; getPackageManager().installExistingPackage(appInfo.packageName); launchSuccess(); &#125; catch (PackageManager.NameNotFoundException e) &#123; launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null); &#125; &#125; else &#123; final File sourceFile = new File(mPackageURI.getPath()); PackageUtil.initSnippetForNewApp(this, PackageUtil.getAppSnippet(this, appInfo, sourceFile), R.id.app_snippet);//获取应用label if (savedInstanceState != null) &#123; //…… &#125; else &#123; PackageInstaller.SessionParams params = new PackageInstaller.SessionParams( PackageInstaller.SessionParams.MODE_FULL_INSTALL); params.installFlags = PackageManager.INSTALL_FULL_APP; params.referrerUri = getIntent().getParcelableExtra(Intent.EXTRA_REFERRER); params.originatingUri = getIntent() .getParcelableExtra(Intent.EXTRA_ORIGINATING_URI); params.originatingUid = getIntent().getIntExtra(Intent.EXTRA_ORIGINATING_UID, UID_UNKNOWN); params.installerPackageName = getIntent().getStringExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME); File file = new File(mPackageURI.getPath()); try &#123; PackageParser.PackageLite pkg = PackageParser.parsePackageLite(file, 0); params.setAppPackageName(pkg.packageName); params.setInstallLocation(pkg.installLocation); params.setSize( PackageHelper.calculateInstalledSize(pkg, false, params.abiOverride)); &#125; catch (PackageParser.PackageParserException e) &#123; params.setSize(file.length()); &#125; catch (IOException e) &#123; params.setSize(file.length()); &#125; try &#123; mInstallId = InstallEventReceiver .addObserver(this, EventResultPersister.GENERATE_NEW_ID, this::launchFinishBasedOnResult); &#125; catch (EventResultPersister.OutOfIdsException e) &#123; launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null); &#125; try &#123; mSessionId = getPackageManager().getPackageInstaller().createSession(params); &#125; catch (IOException e) &#123; launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, null); &#125; &#125; //…… mSessionCallback = new InstallSessionCallback(); &#125; &#125; 这里只关心安装新应用的情况，主要做了四件事： 构建Session的参数PackageInstaller.SessionParams； 添加EventResultObserver到InstallEventReceiver， this::launchFinishBasedOnResult为lambda表达式，表示一个在onResult（）方法中调用launchFinishBasedOnResult（）方法的EventResultObserver对象； 创建会话mSessionId &#x3D; getPackageManager().getPackageInstaller().createSession(params); 创建回调mSessionCallback &#x3D; new InstallSessionCallback();这个监听器中只提供了onProgressChanged（）方法的具体实现，用于更新安装进度。 onStart（）方法： 12345protected void onStart() &#123; super.onStart(); getPackageManager().getPackageInstaller().registerSessionCallback(mSessionCallback);&#125; 注册mSessionCallback，实际上是添加到PackageInstallerService的mCallbacks中，在上面创建PackageInstallerSession时PackageInstallerService的回调mCallbacks会传递给PackageInstallerSession，session的进度更新时会进行回调。这里看起来很简单是由一行代码，但是涉及到了binder通信和handler等内容，以后对binder有更多了解时可以对这里再深入了解下。 onResume方法： 123456789101112131415161718protected void onResume() &#123; super.onResume(); // This is the first onResume in a single life of the activity if (mInstallingTask == null) &#123; PackageInstaller installer = getPackageManager().getPackageInstaller(); PackageInstaller.SessionInfo sessionInfo = installer.getSessionInfo(mSessionId); if (sessionInfo != null &amp;&amp; !sessionInfo.isActive()) &#123; mInstallingTask = new InstallingAsyncTask(); mInstallingTask.execute(); &#125; else &#123; // we will receive a broadcast when the install is finished mCancelButton.setEnabled(false); setFinishOnTouchOutside(false); &#125; &#125;&#125; 创建并执行InstallingAsyncTask，该任务在后台将apk复制到&#x2F;data&#x2F;app目录下，具体路径为：&#x2F;data&#x2F;app&#x2F;vmdl685420279.tmp&#x2F;PackageInstaller。onPostExecute（）方法如下： 12345678910111213141516171819202122232425protected void onPostExecute(PackageInstaller.Session session) &#123; if (session != null) &#123; Intent broadcastIntent = new Intent(BROADCAST_ACTION); broadcastIntent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND); broadcastIntent.setPackage( getPackageManager().getPermissionControllerPackageName()); broadcastIntent.putExtra(EventResultPersister.EXTRA_ID, mInstallId); PendingIntent pendingIntent = PendingIntent.getBroadcast( InstallInstalling.this, mInstallId, broadcastIntent, PendingIntent.FLAG_UPDATE_CURRENT); session.commit(pendingIntent.getIntentSender()); mCancelButton.setEnabled(false); setFinishOnTouchOutside(false); &#125; else &#123; getPackageManager().getPackageInstaller().abandonSession(mSessionId); if (!isCancelled()) &#123; launchFailure(PackageManager.INSTALL_FAILED_INVALID_APK, null); &#125; &#125; &#125; 创建一个广播的PendingIntent并传递给PackageInstaller.Session的commit方法，用于接收应用安装的结果。 安装完成在安装完成后发送广播给之前PendingIntent对应的组件。该组件为PackageInstaller中的InstallEventReceiver。而在其onReceive()方法中会调用SparseArray mObservers中EventResultObserver对象的onResult（）方法，也就是前面onCreate（）方法中注册的observer的onResult（）方法，进而会调用到launchFinishBasedOnResult（）方法： 1234567private void launchFinishBasedOnResult(int statusCode, int legacyStatus, String statusMessage) &#123; if (statusCode == PackageInstaller.STATUS_SUCCESS) &#123; launchSuccess(); &#125; else &#123; launchFailure(legacyStatus, statusMessage); &#125;&#125; 安装成功后跳转到InstallSuccess，失败后跳转到InstallFailed，这里只看success的情况： 12345678private void launchSuccess() &#123; Intent successIntent = new Intent(getIntent()); successIntent.setClass(this, InstallSuccess.class); successIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); startActivity(successIntent); finish();&#125; InstallSuccess主要是提示用户安装成功，用户确认后由于FLAG_ACTIVITY_FORWARD_RESULT会一路回调到DeleteStagedFileOnResult的onActivityResult方法删除临时文件.","categories":[{"name":"应用安装","slug":"应用安装","permalink":"https://mouzishuo.github.io/categories/%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"PackageInstaller","slug":"PackageInstaller","permalink":"https://mouzishuo.github.io/tags/PackageInstaller/"}]},{"title":"PKMS启动过程","slug":"PKMS启动过程","date":"2018-08-01T06:23:08.000Z","updated":"2019-01-16T01:14:47.496Z","comments":true,"path":"2018/08/01/PKMS启动过程/","link":"","permalink":"https://mouzishuo.github.io/2018/08/01/PKMS%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/","excerpt":"","text":"PKMS启动过程参考：https://blog.csdn.net/u012124438/article/details/54882771 PackageManagerService，是Android系统中核心服务之一，管理着所有跟package相关的工作。Android是基于mashup（混搭）的风格设计的，程序是由一个个的组件拼凑起来的，而PackageManagerService的任务就是解析package，然后把其中的组件信息一个个的拆解出来把相关信息放到内存里，当然还要处理package中的其他东西，比如库文件什么的。在程序需要的时候组件管理器（AMS）会向PKMS查询组件信息，然后创建相应的组件并进行管理。 PKMS涉及的内容比较多，常见的比如安装、卸载应用、应用解析，查询应用信息等。 PKMS服务也是通过binder进行通信，IPackageManager.aidl由工具转换后自动生成binder的服务端IPackageManager.Stub和客户端IPackageManager.Stub.Proxy，具体关系如下： Binder服务端：PackageManagerService继承于IPackageManager.Stub；Binder客户端：ApplicationPackageManager(简称APM)的成员变量mPM继承于IPackageManager.Stub.Proxy; 本身APM是继承于PackageManager对象。 首先先来看下PKMS的注释： 123456789101112131415161718192021222324252627282930313233/** * Keep track of all those APKs everywhere. * &lt;p&gt; * Internally there are two important locks: * &lt;ul&gt; * &lt;li&gt;&#123;@link #mPackages&#125; is used to guard all in-memory parsed package details * and other related state. It is a fine-grained lock that should only be held * momentarily, as it&#x27;s one of the most contended locks in the system. * &lt;li&gt;&#123;@link #mInstallLock&#125; is used to guard all &#123;@code installd&#125; access, whose * operations typically involve heavy lifting of application data on disk. Since * &#123;@code installd&#125; is single-threaded, and it&#x27;s operations can often be slow, * this lock should never be acquired while already holding &#123;@link #mPackages&#125;. * Conversely, it&#x27;s safe to acquire &#123;@link #mPackages&#125; momentarily while already * holding &#123;@link #mInstallLock&#125;. * &lt;/ul&gt; * Many internal methods rely on the caller to hold the appropriate locks, and * this contract is expressed through method name suffixes: * &lt;ul&gt; * &lt;li&gt;fooLI(): the caller must hold &#123;@link #mInstallLock&#125; * &lt;li&gt;fooLIF(): the caller must hold &#123;@link #mInstallLock&#125; and the package * being modified must be frozen * &lt;li&gt;fooLPr(): the caller must hold &#123;@link #mPackages&#125; for reading * &lt;li&gt;fooLPw(): the caller must hold &#123;@link #mPackages&#125; for writing * &lt;/ul&gt; * &lt;p&gt; * Because this class is very central to the platform&#x27;s security; please run all * CTS and unit tests whenever making modifications: * * &lt;pre&gt; * $ runtest -c android.content.pm.PackageManagerTests frameworks-core * $ cts-tradefed run commandAndExit cts -m CtsAppSecurityHostTestCases * &lt;/pre&gt; */ mPackages同步锁，是指操作mPackages时，用synchronized (mPackages) &#123;&#125;保护起来。mPackages同步锁用来保护内存中已经解析的包信息和其他相关状态。mPackages同步锁是细粒度的锁，只能短时间持有这个锁，因为争抢mPackages锁的请求很多，短时间持有mPackages锁，可以让其他请求等待的时间短些。 mInstallLock同步锁，是指安装App的时候，对安装的处理要用synchronized (mInstaller) &#123;&#125;保护起来。mInstallLock同步锁，用来保护所有对installd的访问。installd通常包含对应用数据的繁重操作。 由于installd是单线程的，并且installd的操作通常很慢，所以在已经持有mPackages同步锁的时候，千万不要再请求mInstallLock同步锁。反之，在已经持有mInstallLock同步锁的时候，可以去请求mPackages同步锁。 PKMS中的很多方法带有LI、LIF、LPw、LPr等后缀，LI、LIF、LPw、LPr中的L，指的是Lock，而后面跟的I和P指的是两个锁，I表示mInstallLock同步锁。P表示mPackages同步锁。LPw、LPr中的w表示writing，r表示reading。LIF中的F表示Freeze。 该部分也可参考https://blog.csdn.net/u013553529/article/details/61962439。 1. PKMS启动过程PKMS和其它系统服务一样是在SystemServer中启动的： 1234567891011121314151617181920212223242526272829303132333435363738394041 /** * Starts the small tangle of critical services that are needed to get * the system off the ground. These services have complex mutual dependencies * which is why we initialize them all in one place here. Unless your service * is also entwined in these dependencies, it should be initialized in one of * the other functions. */ private void startBootstrapServices() &#123;//Bootstrap：引导，启动引导服务//…… // Wait for installd to finish starting up so that it has a chance to // create critical directories such as /data/user with the appropriate // permissions. We need this to complete before we initialize other services. traceBeginAndSlog(&quot;StartInstaller&quot;); Installer installer = mSystemServiceManager.startService(Installer.class); traceEnd(); //…… // Only run &quot;core&quot; apps if we&#x27;re encrypting the device. String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;); if (ENCRYPTING_STATE.equals(cryptState)) &#123; Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;); mOnlyCore = true; &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123; Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;); mOnlyCore = true; &#125; // Start the package manager. if (!mRuntimeRestart) &#123; MetricsLogger.histogram(null, &quot;boot_package_manager_init_start&quot;, (int) SystemClock.elapsedRealtime()); &#125; traceBeginAndSlog(&quot;StartPackageManagerService&quot;); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); traceEnd(); //…… &#125; startBootstrapServices中启动的是系统中最关键的一批服务，所以也是在SystemServer中最先启动的一批服务。 SystemServer通过调用PKSM的main方法创建并启动PKMS服务。 12345678910111213public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; // Self-check for initial settings. PackageManagerServiceCompilerMapping.checkProperties(); PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); m.enableSystemUserPackages(); ServiceManager.addService(&quot;package&quot;, m); final PackageManagerNative pmn = m.new PackageManagerNative(); ServiceManager.addService(&quot;package_native&quot;, pmn); return m;&#125; 首先是PKMS的初始化过程：PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore);。 1.1 PKMS构造过程Android系统提供了一种诊断工具来记录系统级的事件，该工具就是EventLog。PKMS的创建过程也通过EventLog进行了记录。根据EventLog来看，PKMS的创建可以分为5个阶段： 12345&gt;BOOT_PROGRESS_PMS_START&gt;BOOT_PROGRESS_PMS_SYSTEM_SCAN_START&gt;BOOT_PROGRESS_PMS_DATA_SCAN_START&gt;BOOT_PROGRESS_PMS_SCAN_END&gt;BOOT_PROGRESS_PMS_READY 阶段1：BOOT_PROGRESS_PMS_START该阶段代码如下，其中成员初始化的部分代码省略掉了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis()); // …… //构造Settings对象存储运行时的设置信息 mSettings = new Settings(mPackages);//添加系统的shareUID mSettings.addSharedUserLPw(&quot;android.uid.system&quot;, Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(&quot;android.uid.phone&quot;, RADIO_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(&quot;android.uid.log&quot;, LOG_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(&quot;android.uid.nfc&quot;, NFC_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(&quot;android.uid.bluetooth&quot;, BLUETOOTH_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); mSettings.addSharedUserLPw(&quot;android.uid.shell&quot;, SHELL_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); //…… SystemConfig systemConfig = SystemConfig.getInstance(); //…… synchronized (mInstallLock) &#123; // writer synchronized (mPackages) &#123; //…… // 添加内置权限配置到mSettings // Propagate permission configuration in to package manager. ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig = systemConfig.getPermissions(); for (int i=0; i&lt;permConfig.size(); i++) &#123; SystemConfig.PermissionEntry perm = permConfig.valueAt(i); BasePermission bp = mSettings.mPermissions.get(perm.name); if (bp == null) &#123;//android（framework-res.apk）这个应用拥有所有权限？ bp = new BasePermission(perm.name, &quot;android&quot;, BasePermission.TYPE_BUILTIN); mSettings.mPermissions.put(perm.name, bp); &#125; if (perm.gids != null) &#123; bp.setGids(perm.gids, perm.perUser); &#125; &#125; //获取SharedLibraries信息 ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries(); final int builtInLibCount = libConfig.size(); for (int i = 0; i &lt; builtInLibCount; i++) &#123; String name = libConfig.keyAt(i); String path = libConfig.valueAt(i); addSharedLibraryLPw(path, null, name, SharedLibraryInfo.VERSION_UNDEFINED, SharedLibraryInfo.TYPE_BUILTIN, PLATFORM_PACKAGE_NAME, 0); &#125; mFoundPolicyFile = SELinuxMMAC.readInstallPolicy(); Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;read user settings&quot;); //尝试读取packages.xml内容，读取不到或者读取失败则判定为首次启动 mFirstBoot = !mSettings.readLPw(sUserManager.getUsers(false)); Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); // Clean up orphaned packages for which the code path doesn&#x27;t exist // and they are an update to a system app - caused by bug/32321269 //第一次启动时还没有生成packages.xml所以packageSettingCount为0 final int packageSettingCount = mSettings.mPackages.size(); for (int i = packageSettingCount - 1; i &gt;= 0; i--) &#123; PackageSetting ps = mSettings.mPackages.valueAt(i); if (!isExternal(ps) &amp;&amp; (ps.codePath == null || !ps.codePath.exists()) &amp;&amp; mSettings.getDisabledSystemPkgLPr(ps.name) != null) &#123; mSettings.mPackages.removeAt(i); mSettings.enableSystemPackageLPw(ps.name); &#125; &#125; //等到dex文件拷贝完成，实际copy是在/system/extras/cppreopts/cppreopts.rc进行的 if (mFirstBoot) &#123; requestCopyPreoptedFiles(); &#125; //自定义的Intent resolver String customResolverActivity = Resources.getSystem().getString( R.string.config_customResolverActivity); if (TextUtils.isEmpty(customResolverActivity)) &#123; customResolverActivity = null; &#125; else &#123; mCustomResolverComponentName = ComponentName.unflattenFromString( customResolverActivity); &#125; 第一阶段前半部分没加锁，后半部分是在加锁的代码块里的。总的来说第一阶段主要做了这几件事：初始化成员变量、添加系统SharedUID信息到mSettings、加载权限信息、获取SharedLibraries信息以及清除找不到的package信息。 关键的变量有两个： 12mSettings = new Settings(mPackages);//对应packages.xml文件SystemConfig systemConfig = SystemConfig.getInstance(); 先来看下Setting的构造过程： 123456789101112131415161718192021222324252627Settings(Object lock) &#123; this(Environment.getDataDirectory(), lock);&#125;Settings(File dataDir, Object lock) &#123; mLock = lock; mRuntimePermissionsPersistence = new RuntimePermissionPersistence(mLock); mSystemDir = new File(dataDir, &quot;system&quot;); mSystemDir.mkdirs(); FileUtils.setPermissions(mSystemDir.toString(), FileUtils.S_IRWXU|FileUtils.S_IRWXG |FileUtils.S_IROTH|FileUtils.S_IXOTH, -1, -1); mSettingsFilename = new File(mSystemDir, &quot;packages.xml&quot;); mBackupSettingsFilename = new File(mSystemDir, &quot;packages-backup.xml&quot;); mPackageListFilename = new File(mSystemDir, &quot;packages.list&quot;); FileUtils.setPermissions(mPackageListFilename, 0640, SYSTEM_UID, PACKAGE_INFO_GID); final File kernelDir = new File(&quot;/config/sdcardfs&quot;); mKernelMappingFilename = kernelDir.exists() ? kernelDir : null; // Deprecated: Needed for migration mStoppedPackagesFilename = new File(mSystemDir, &quot;packages-stopped.xml&quot;); mBackupStoppedPackagesFilename = new File(mSystemDir, &quot;packages-stopped-backup.xml&quot;);&#125; 主要是指定Settings相关的文件路径。Settings中保存了package的相关信息，包括应用本身信息和AndroidManifest.xml中的信息。Settings中保存了各个包的PackageSetting信息，PackageSetting继承自PackageSettingBase，PackageSettingBase又继承自SettingBase，PackageSetting中保存了一个PackageParser.Package的引用（保存从apk中解析出的信息），而该Package对象由持有一个ApplicationInfo对象（对应于AndroidManifest.xml中的application标签）的引用。 再来看下SettingConfig的创建过程： 12345678910111213141516171819202122232425262728293031323334 public static SystemConfig getInstance() &#123; synchronized (SystemConfig.class) &#123; if (sInstance == null) &#123; sInstance = new SystemConfig(); &#125; return sInstance; &#125; &#125;SystemConfig() &#123; // Read configuration from system readPermissions(Environment.buildPath( Environment.getRootDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), ALLOW_ALL); // Read configuration from the old permissions dir readPermissions(Environment.buildPath( Environment.getRootDirectory(), &quot;etc&quot;, &quot;permissions&quot;), ALLOW_ALL); // Allow Vendor to customize system configs around libs, features, permissions and apps int vendorPermissionFlag = ALLOW_LIBS | ALLOW_FEATURES | ALLOW_PERMISSIONS | ALLOW_APP_CONFIGS; readPermissions(Environment.buildPath( Environment.getVendorDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), vendorPermissionFlag); readPermissions(Environment.buildPath( Environment.getVendorDirectory(), &quot;etc&quot;, &quot;permissions&quot;), vendorPermissionFlag); // Allow ODM to customize system configs around libs, features and apps int odmPermissionFlag = ALLOW_LIBS | ALLOW_FEATURES | ALLOW_APP_CONFIGS; readPermissions(Environment.buildPath( Environment.getOdmDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), odmPermissionFlag); readPermissions(Environment.buildPath( Environment.getOdmDirectory(), &quot;etc&quot;, &quot;permissions&quot;), odmPermissionFlag); // Only allow OEM to customize features readPermissions(Environment.buildPath( Environment.getOemDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), ALLOW_FEATURES); readPermissions(Environment.buildPath( Environment.getOemDirectory(), &quot;etc&quot;, &quot;permissions&quot;), ALLOW_FEATURES); &#125; readPermissions()解析指定目录下的所有xml文件，所以，SystemConfig创建过程是对以下这六个目录中的所有xml进行解析来完成的。 &#x2F;system&#x2F;etc&#x2F;sysconfig&#x2F;system&#x2F;etc&#x2F;permissions&#x2F;vendor&#x2F;etc&#x2F;sysconfig&#x2F;vendor&#x2F;etc&#x2F;permissions&#x2F;oem&#x2F;etc&#x2F;sysconfig&#x2F;oem&#x2F;etc&#x2F;permissions 权限分两类，存储在两个不同的变量中，final SparseArray&lt;ArraySet&lt;String&gt;&gt; mSystemPermissions表示系统权限，是一个uid到权限的映射，final ArrayMap&lt;String, PermissionEntry&gt; mPermissions = new ArrayMap&lt;&gt;();gid到权限的映射。系统权限在文件中的attribute为assign-permission，比如： 123456platform.xml144: &lt;assign-permission name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; uid=&quot;media&quot; /&gt;151: &lt;assign-permission name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; uid=&quot;audioserver&quot; /&gt;170: &lt;assign-permission name=&quot;android.permission.PACKAGE_USAGE_STATS&quot; uid=&quot;incidentd&quot; /&gt;172: &lt;assign-permission name=&quot;android.permission.ACCESS_LOWPAN_STATE&quot; uid=&quot;lowpan&quot; /&gt;177: &lt;assign-permission name=&quot;android.permission.STATSCOMPANION&quot; uid=&quot;statsd&quot; /&gt; mPermissions在xml中对应的attribute为permissions： 1234567&lt;permission name=&quot;android.permission.INTERNET&quot; &gt; &lt;group gid=&quot;inet&quot; /&gt;&lt;/permission&gt;&lt;permission name=&quot;android.permission.READ_LOGS&quot; &gt; &lt;group gid=&quot;log&quot; /&gt;&lt;/permission&gt; 阶段2：BOOT_PROGRESS_PMS_SYSTEM_SCAN_START123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155 long startTime = SystemClock.uptimeMillis(); EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, startTime); final String bootClassPath = System.getenv(&quot;BOOTCLASSPATH&quot;); final String systemServerClassPath = System.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;); //…… //system/framework/ File frameworkDir = new File(Environment.getRootDirectory(), &quot;framework&quot;); final VersionInfo ver = mSettings.getInternalVersion(); mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint); //…… // Set flag to monitor and not change apk file paths when // scanning install directories. int scanFlags = SCAN_BOOTING | SCAN_INITIAL; if (mIsUpgrade || mFirstBoot) &#123; scanFlags = scanFlags | SCAN_FIRST_BOOT_OR_UPGRADE; &#125; // Collect vendor overlay packages. (Do this before scanning any apps.) // For security and version matching reason, only consider // overlay packages if they reside in the right directory. scanDirTracedLI(new File(VENDOR_OVERLAY_DIR), mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_TRUSTED_OVERLAY, scanFlags | SCAN_TRUSTED_OVERLAY, 0); mParallelPackageParserCallback.findStaticOverlayPackages(); // Find base frameworks (resource packages without code). scanDirTracedLI(frameworkDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags | SCAN_NO_DEX, 0); // Collected privileged system packages. final File privilegedAppDir = new File(Environment.getRootDirectory(), &quot;priv-app&quot;); scanDirTracedLI(privilegedAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0); // Collect ordinary system packages. final File systemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;); scanDirTracedLI(systemAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all vendor packages. File vendorAppDir = new File(&quot;/vendor/app&quot;); try &#123; vendorAppDir = vendorAppDir.getCanonicalFile(); &#125; catch (IOException e) &#123; // failed to look up canonical path, continue with original one &#125; scanDirTracedLI(vendorAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all OEM packages. final File oemAppDir = new File(Environment.getOemDirectory(), &quot;app&quot;); scanDirTracedLI(oemAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Prune any system packages that no longer exist. final List&lt;String&gt; possiblyDeletedUpdatedSystemApps = new ArrayList&lt;&gt;(); // Stub packages must either be replaced with full versions in the /data // partition or be disabled. final List&lt;String&gt; stubSystemApps = new ArrayList&lt;&gt;(); if (!mOnlyCore) &#123; // do this first before mucking with mPackages for the &quot;expecting better&quot; case final Iterator&lt;PackageParser.Package&gt; pkgIterator = mPackages.values().iterator(); while (pkgIterator.hasNext()) &#123; final PackageParser.Package pkg = pkgIterator.next(); if (pkg.isStub) &#123; stubSystemApps.add(pkg.packageName); &#125; &#125; final Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator(); while (psit.hasNext()) &#123; PackageSetting ps = psit.next(); /* * If this is not a system app, it can&#x27;t be a * disable system app.OTA的升级只涉及到系统app。 */ if ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == 0) &#123; continue; &#125; /* * If the package is scanned, it&#x27;s not erased. */ final PackageParser.Package scannedPkg = mPackages.get(ps.name); if (scannedPkg != null) &#123; /* * If the system app is both scanned and in the * disabled packages list, then it must have been * added via OTA. Remove it from the currently * scanned package so the previously user-installed * application can be scanned. */ if (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123; removePackageLI(scannedPkg, true); mExpectingBetter.put(ps.name, ps.codePath); &#125; continue; &#125; if (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123; psit.remove(); logCriticalInfo(Log.WARN, &quot;System package &quot; + ps.name + &quot; no longer exists; it&#x27;s data will be wiped&quot;); // Actual deletion of code and data will be handled by later // reconciliation step &#125; else &#123; // we still have a disabled system package, but, it still might have // been removed. check the code path still exists and check there&#x27;s // still a package. the latter can happen if an OTA keeps the same // code path, but, changes the package name. final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name); if (disabledPs.codePath == null || !disabledPs.codePath.exists() || disabledPs.pkg == null) &#123; possiblyDeletedUpdatedSystemApps.add(ps.name); &#125; &#125; &#125; &#125; //look for any incomplete package installations//删除未完成安装的package ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr(); for (int i = 0; i &lt; deletePkgsList.size(); i++) &#123; // Actual deletion of code and data will be handled by later // reconciliation step final String packageName = deletePkgsList.get(i).name; logCriticalInfo(Log.WARN, &quot;Cleaning up incompletely installed app: &quot; + packageName); synchronized (mPackages) &#123; mSettings.removePackageLPw(packageName); &#125; &#125; //delete tmp files deleteTempPackageFiles(); final int cachedSystemApps = PackageParser.sCachedPackageReadCount.get(); // Remove any shared userIDs that have no associated packages mSettings.pruneSharedUsersLPw(); 环境变量: 那可通过adb shell env来查看系统所有的环境变量及相应值。也可通过命令adb shell echo $SYSTEMSERVERCLASSPATH。 SYSTEMSERVERCLASSPATH：主要包括&#x2F;system&#x2F;framework目录下services.jar，ethernet-service.jar，wifi-service.jar这3个文件。BOOTCLASSPATH：该环境变量内容较多，不同ROM可能有所不同，常见内容包含&#x2F;system&#x2F;framework目录下的framework.jar，ext.jar，core-libart.jar，telephony-common.jar，ims-common.jar，core-junit.jar等文件。 scanDirLI(): 扫描指定目录下的apk文件，最终调用PackageParser.parseBaseApk来完成AndroidManifest.xml文件的解析，生成Application, activity,service,broadcast, provider等信息。&#x2F;vendor&#x2F;overlay&#x2F;system&#x2F;framework&#x2F;system&#x2F;priv-app&#x2F;system&#x2F;app&#x2F;vendor&#x2F;priv-app&#x2F;vendor&#x2F;app&#x2F;oem&#x2F;app 该部分代码的细节暂不了解，以后有需要了再专门了解。 阶段3： BOOT_PROGRESS_PMS_DATA_SCAN_START123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154 if (!mOnlyCore) &#123; EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START, SystemClock.uptimeMillis()); // /data/app/ scanDirTracedLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);// /data/app-private/ scanDirTracedLI(mDrmAppPrivateInstallDir, mDefParseFlags | PackageParser.PARSE_FORWARD_LOCK, scanFlags | SCAN_REQUIRE_KNOWN, 0); // Remove disable package settings for updated system apps that were // removed via an OTA. If the update is no longer present, remove the // app completely. Otherwise, revoke their system privileges. for (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123; PackageParser.Package deletedPkg = mPackages.get(deletedAppName); mSettings.removeDisabledSystemPackageLPw(deletedAppName); final String msg; if (deletedPkg == null) &#123; // should have found an update, but, we didn&#x27;t; remove everything msg = &quot;Updated system package &quot; + deletedAppName + &quot; no longer exists; removing its data&quot;; // Actual deletion of code and data will be handled by later // reconciliation step &#125; else &#123; // found an update; revoke system privileges msg = &quot;Updated system package + &quot; + deletedAppName + &quot; no longer exists; revoking system privileges&quot;; // Don&#x27;t do anything if a stub is removed from the system image. If // we were to remove the uncompressed version from the /data partition, // this is where it&#x27;d be done. final PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName); deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM; deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM; &#125; logCriticalInfo(Log.WARN, msg); &#125; /* * Make sure all system apps that we expected to appear on * the userdata partition actually showed up. If they never * appeared, crawl back and revive the system version. */ for (int i = 0; i &lt; mExpectingBetter.size(); i++) &#123; final String packageName = mExpectingBetter.keyAt(i); if (!mPackages.containsKey(packageName)) &#123; final File scanFile = mExpectingBetter.valueAt(i); logCriticalInfo(Log.WARN, &quot;Expected better &quot; + packageName + &quot; but never showed up; reverting to system&quot;); int reparseFlags = mDefParseFlags; if (FileUtils.contains(privilegedAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED; &#125; else if (FileUtils.contains(systemAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else if (FileUtils.contains(vendorAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else if (FileUtils.contains(oemAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else &#123; Slog.e(TAG, &quot;Ignoring unexpected fallback path &quot; + scanFile); continue; &#125; mSettings.enableSystemPackageLPw(packageName); try &#123; scanPackageTracedLI(scanFile, reparseFlags, scanFlags, 0, null); &#125; catch (PackageManagerException e) &#123; Slog.e(TAG, &quot;Failed to parse original system package: &quot; + e.getMessage()); &#125; &#125; &#125; // Uncompress and install any stubbed system applications. // This must be done last to ensure all stubs are replaced or disabled. decompressSystemApplications(stubSystemApps, scanFlags); final int cachedNonSystemApps = PackageParser.sCachedPackageReadCount.get() - cachedSystemApps; final long dataScanTime = SystemClock.uptimeMillis() - systemScanTime - startTime; final int dataPackagesCount = mPackages.size() - systemPackagesCount; Slog.i(TAG, &quot;Finished scanning non-system apps. Time: &quot; + dataScanTime + &quot; ms, packageCount: &quot; + dataPackagesCount + &quot; , timePerPackage: &quot; + (dataPackagesCount == 0 ? 0 : dataScanTime / dataPackagesCount) + &quot; , cached: &quot; + cachedNonSystemApps); if (mIsUpgrade &amp;&amp; dataPackagesCount &gt; 0) &#123; MetricsLogger.histogram(null, &quot;ota_package_manager_data_app_avg_scan_time&quot;, ((int) dataScanTime) / dataPackagesCount); &#125; &#125; mExpectingBetter.clear(); // Resolve the storage manager. mStorageManagerPackage = getStorageManagerPackageName(); // Resolve protected action filters. Only the setup wizard is allowed to // have a high priority filter for these actions. mSetupWizardPackage = getSetupWizardPackageName(); if (mProtectedFilters.size() &gt; 0) &#123; if (DEBUG_FILTERS &amp;&amp; mSetupWizardPackage == null) &#123; Slog.i(TAG, &quot;No setup wizard;&quot; + &quot; All protected intents capped to priority 0&quot;); &#125; for (ActivityIntentInfo filter : mProtectedFilters) &#123; if (filter.activity.info.packageName.equals(mSetupWizardPackage)) &#123; if (DEBUG_FILTERS) &#123; Slog.i(TAG, &quot;Found setup wizard;&quot; + &quot; allow priority &quot; + filter.getPriority() + &quot;;&quot; + &quot; package: &quot; + filter.activity.info.packageName + &quot; activity: &quot; + filter.activity.className + &quot; priority: &quot; + filter.getPriority()); &#125; // skip setup wizard; allow it to keep the high priority filter continue; &#125; if (DEBUG_FILTERS) &#123; Slog.i(TAG, &quot;Protected action; cap priority to 0;&quot; + &quot; package: &quot; + filter.activity.info.packageName + &quot; activity: &quot; + filter.activity.className + &quot; origPrio: &quot; + filter.getPriority()); &#125; filter.setPriority(0); &#125; &#125; mDeferProtectedFilters = false; mProtectedFilters.clear(); // Now that we know all of the shared libraries, update all clients to have // the correct library paths. updateAllSharedLibrariesLPw(null); for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123; // NOTE: We ignore potential failures here during a system scan (like // the rest of the commands above) because there&#x27;s precious little we // can do about it. A settings error is reported, though. adjustCpuAbisForSharedUserLPw(setting.packages, null /*scannedPackage*/); &#125; // Now that we know all the packages we are keeping, // read and update their last usage times. mPackageUsage.read(mPackages); mCompilerStats.read(); 当mOnlyCore &#x3D; false时，则scanDirLI()还会收集如下目录中的apk：&#x2F;data&#x2F;app&#x2F;data&#x2F;app-private：DRM保护的APK文件 阶段4：BOOT_PROGRESS_PMS_SCAN_END123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis()); Slog.i(TAG, &quot;Time to scan packages: &quot; + ((SystemClock.uptimeMillis()-startTime)/1000f) + &quot; seconds&quot;); // If the platform SDK has changed since the last time we booted, // we need to re-grant app permission to catch any new ones that // appear. This is really a hack, and means that apps can in some // cases get permissions that the user didn&#x27;t initially explicitly // allow... it would be nice to have some better way to handle // this situation. int updateFlags = UPDATE_PERMISSIONS_ALL; if (ver.sdkVersion != mSdkVersion) &#123; Slog.i(TAG, &quot;Platform changed from &quot; + ver.sdkVersion + &quot; to &quot; + mSdkVersion + &quot;; regranting permissions for internal storage&quot;); updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL; &#125; //当sdk版本不一致时，,更新相关信息，并给需要使用权限的apk分配相应的权限 updatePermissionsLPw(null, null, StorageManager.UUID_PRIVATE_INTERNAL, updateFlags); ver.sdkVersion = mSdkVersion; // If this is the first boot or an update from pre-M, and it is a normal // boot, then we need to initialize the default preferred apps across // all defined users. //当这是ota后的首次启动，正常启动则需要清除目录的缓存代码 if (!onlyCore &amp;&amp; (mPromoteSystemApps || !mRestoredSettings)) &#123; for (UserInfo user : sUserManager.getUsers(true)) &#123; mSettings.applyDefaultPreferredAppsLPw(this, user.id); applyFactoryDefaultBrowserLPw(user.id); primeDomainVerificationsLPw(user.id); &#125; &#125; // Prepare storage for system user really early during boot, // since core system apps like SettingsProvider and SystemUI // can&#x27;t wait for user to start final int storageFlags; if (StorageManager.isFileEncryptedNativeOrEmulated()) &#123; storageFlags = StorageManager.FLAG_STORAGE_DE; &#125; else &#123; storageFlags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE; &#125; reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, UserHandle.USER_SYSTEM, storageFlags); // If this is first boot after an OTA, and a normal boot, then // we need to clear code cache directories. // Note that we do *not* clear the application profiles. These remain valid // across OTAs and are used to drive profile verification (post OTA) and // profile compilation (without waiting to collect a fresh set of profiles). if (mIsUpgrade &amp;&amp; !onlyCore) &#123; Slog.i(TAG, &quot;Build fingerprint changed; clearing code caches&quot;); for (int i = 0; i &lt; mSettings.mPackages.size(); i++) &#123; final PackageSetting ps = mSettings.mPackages.valueAt(i); if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123; // No apps are running this early, so no need to freeze clearAppDataLIF(ps.pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY); &#125; &#125; ver.fingerprint = Build.FINGERPRINT; &#125; checkDefaultBrowser(); // clear only after permissions and other defaults have been updated //当权限和其他默认项都完成更新，则清理相关信息 mExistingSystemPackages.clear(); mPromoteSystemApps = false; // All the changes are done during package scanning. ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION; // can downgrade to reader //信息写回packages.xml文件 mSettings.writeLPr(); // Perform dexopt on all apps that mark themselves as coreApps. We do this pretty // early on (before the package manager declares itself as early) because other // components in the system server might ask for package contexts for these apps. // // Note that &quot;onlyCore&quot; in this context means the system is encrypted or encrypting // (i.e, that the data partition is unavailable). if ((isFirstBoot() || isUpgrade() || VMRuntime.didPruneDalvikCache()) &amp;&amp; !onlyCore) &#123; long start = System.nanoTime(); List&lt;PackageParser.Package&gt; coreApps = new ArrayList&lt;&gt;(); for (PackageParser.Package pkg : mPackages.values()) &#123; if (pkg.coreApp) &#123; coreApps.add(pkg); &#125; &#125; int[] stats = performDexOpt(coreApps, false, getCompilerFilterForReason(REASON_CORE_APP)); final int elapsedTimeSeconds = (int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - start); MetricsLogger.histogram(mContext, &quot;opt_coreapps_time_s&quot;, elapsedTimeSeconds); if (DEBUG_DEXOPT) &#123; Slog.i(TAG, &quot;Dex-opt core apps took : &quot; + elapsedTimeSeconds + &quot; seconds (&quot; + stats[0] + &quot;, &quot; + stats[1] + &quot;, &quot; + stats[2] + &quot;)&quot;); &#125; &#125; 阶段5：BOOT_PROGRESS_PMS_READY1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis()); if (!mOnlyCore) &#123; mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr(); mRequiredInstallerPackage = getRequiredInstallerLPr(); mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr(); mIntentFilterVerifier = new IntentVerifierProxy(mContext, mIntentFilterVerifierComponent); mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr( PackageManager.SYSTEM_SHARED_LIBRARY_SERVICES); mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr( PackageManager.SYSTEM_SHARED_LIBRARY_SHARED); &#125; else &#123; mRequiredVerifierPackage = null; mRequiredInstallerPackage = null; mIntentFilterVerifierComponent = null; mIntentFilterVerifier = null; mServicesSystemSharedLibraryPackageName = null; mSharedSystemSharedLibraryPackageName = null; &#125; mInstallerService = new PackageInstallerService(context, this); final ComponentName ephemeralResolverComponent = getEphemeralResolverLPr(); final ComponentName ephemeralInstallerComponent = getEphemeralInstallerLPr(); // both the installer and resolver must be present to enable ephemeral if (ephemeralInstallerComponent != null &amp;&amp; ephemeralResolverComponent != null) &#123; if (DEBUG_EPHEMERAL) &#123; Slog.i(TAG, &quot;Ephemeral activated; resolver: &quot; + ephemeralResolverComponent + &quot; installer:&quot; + ephemeralInstallerComponent); &#125; mEphemeralResolverComponent = ephemeralResolverComponent; mEphemeralInstallerComponent = ephemeralInstallerComponent; setUpEphemeralInstallerActivityLP(mEphemeralInstallerComponent); mEphemeralResolverConnection = new EphemeralResolverConnection(mContext, mEphemeralResolverComponent); &#125; else &#123; if (DEBUG_EPHEMERAL) &#123; final String missingComponent = (ephemeralResolverComponent == null) ? (ephemeralInstallerComponent == null) ? &quot;resolver and installer&quot; : &quot;resolver&quot; : &quot;installer&quot;; Slog.i(TAG, &quot;Ephemeral deactivated; missing &quot; + missingComponent); &#125; mEphemeralResolverComponent = null; mEphemeralInstallerComponent = null; mEphemeralResolverConnection = null; &#125; mEphemeralApplicationRegistry = new EphemeralApplicationRegistry(this); &#125; // synchronized (mPackages) &#125; // synchronized (mInstallLock) // Now after opening every single application zip, make sure they // are all flushed. Not really needed, but keeps things nice and // tidy. Runtime.getRuntime().gc(); // The initial scanning above does many calls into installd while // holding the mPackages lock, but we&#x27;re mostly interested in yelling // once we have a booted system. mInstaller.setWarnIfHeld(mPackages); // Expose private service for system components to use. LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl()); 创建PackageInstallerService服务。 PKMS初始化过程，分为5个阶段：PMS_START阶段：创建Settings对象；将6类shareUserId到mSettings；初始化SystemConfig；创建名为“PackageManager”的handler线程mHandlerThread;创建UserManagerService多用户管理服务；通过解析4大目录中的xmL文件构造共享mSharedLibraries；PMS_SYSTEM_SCAN_START阶段：扫描系统apk;PMS_DATA_SCAN_START阶段：扫描&#x2F;data&#x2F;app目录下的apk;扫描&#x2F;data&#x2F;app-private目录下的apk;PMS_SCAN_END阶段：将上述信息写回&#x2F;data&#x2F;system&#x2F;packages.xml;PMS_READY阶段：创建服务PackageInstallerService； 回到PKMS的main方法： 12345678910111213public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; // Self-check for initial settings. PackageManagerServiceCompilerMapping.checkProperties(); PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); m.enableSystemUserPackages(); ServiceManager.addService(&quot;package&quot;, m); final PackageManagerNative pmn = m.new PackageManagerNative(); ServiceManager.addService(&quot;package_native&quot;, pmn); return m; &#125; PKSM初始化后会将服务添加到ServiceManager中。之后在SystemServer的startOtherServices()方法中会调用PKSM的systemReady()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140@Overridepublic void systemReady() &#123; enforceSystemOrRoot(&quot;Only the system can claim the system is ready&quot;); mSystemReady = true; final ContentResolver resolver = mContext.getContentResolver(); ContentObserver co = new ContentObserver(mHandler) &#123; @Override public void onChange(boolean selfChange) &#123; mEphemeralAppsDisabled = (Global.getInt(resolver, Global.ENABLE_EPHEMERAL_FEATURE, 1) == 0) || (Secure.getInt(resolver, Secure.INSTANT_APPS_ENABLED, 1) == 0); &#125; &#125;; mContext.getContentResolver().registerContentObserver(android.provider.Settings.Global .getUriFor(Global.ENABLE_EPHEMERAL_FEATURE), false, co, UserHandle.USER_SYSTEM); mContext.getContentResolver().registerContentObserver(android.provider.Settings.Global .getUriFor(Secure.INSTANT_APPS_ENABLED), false, co, UserHandle.USER_SYSTEM); co.onChange(true); // Disable any carrier apps. We do this very early in boot to prevent the apps from being // disabled after already being started. CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), this, mContext.getContentResolver(), UserHandle.USER_SYSTEM); // Read the compatibilty setting when the system is ready. boolean compatibilityModeEnabled = android.provider.Settings.Global.getInt( mContext.getContentResolver(), android.provider.Settings.Global.COMPATIBILITY_MODE, 1) == 1; PackageParser.setCompatibilityModeEnabled(compatibilityModeEnabled); if (DEBUG_SETTINGS) &#123; Log.d(TAG, &quot;compatibility mode:&quot; + compatibilityModeEnabled); &#125; int[] grantPermissionsUserIds = EMPTY_INT_ARRAY; synchronized (mPackages) &#123; // Verify that all of the preferred activity components actually // exist. It is possible for applications to be updated and at // that point remove a previously declared activity component that // had been set as a preferred activity. We try to clean this up // the next time we encounter that preferred activity, but it is // possible for the user flow to never be able to return to that // situation so here we do a sanity check to make sure we haven&#x27;t // left any junk around. ArrayList&lt;PreferredActivity&gt; removed = new ArrayList&lt;PreferredActivity&gt;(); for (int i=0; i&lt;mSettings.mPreferredActivities.size(); i++) &#123; PreferredIntentResolver pir = mSettings.mPreferredActivities.valueAt(i); removed.clear(); for (PreferredActivity pa : pir.filterSet()) &#123; if (mActivities.mActivities.get(pa.mPref.mComponent) == null) &#123; removed.add(pa); &#125; &#125; if (removed.size() &gt; 0) &#123; for (int r=0; r&lt;removed.size(); r++) &#123; PreferredActivity pa = removed.get(r); Slog.w(TAG, &quot;Removing dangling preferred activity: &quot; + pa.mPref.mComponent); pir.removeFilter(pa); &#125; mSettings.writePackageRestrictionsLPr( mSettings.mPreferredActivities.keyAt(i)); &#125; &#125; for (int userId : UserManagerService.getInstance().getUserIds()) &#123; if (!mSettings.areDefaultRuntimePermissionsGrantedLPr(userId)) &#123; grantPermissionsUserIds = ArrayUtils.appendInt( grantPermissionsUserIds, userId); &#125; &#125; &#125; sUserManager.systemReady(); // If we upgraded grant all default permissions before kicking off. for (int userId : grantPermissionsUserIds) &#123; mDefaultPermissionPolicy.grantDefaultPermissions(userId); &#125; // If we did not grant default permissions, we preload from this the // default permission exceptions lazily to ensure we don&#x27;t hit the // disk on a new user creation. if (grantPermissionsUserIds == EMPTY_INT_ARRAY) &#123; mDefaultPermissionPolicy.scheduleReadDefaultPermissionExceptions(); &#125; // Kick off any messages waiting for system ready if (mPostSystemReadyMessages != null) &#123; for (Message msg : mPostSystemReadyMessages) &#123; msg.sendToTarget(); &#125; mPostSystemReadyMessages = null; &#125; // Watch for external volumes that come and go over time final StorageManager storage = mContext.getSystemService(StorageManager.class); storage.registerListener(mStorageListener); mInstallerService.systemReady(); mPackageDexOptimizer.systemReady(); StorageManagerInternal StorageManagerInternal = LocalServices.getService( StorageManagerInternal.class); StorageManagerInternal.addExternalStoragePolicy( new StorageManagerInternal.ExternalStorageMountPolicy() &#123; @Override public int getMountMode(int uid, String packageName) &#123; if (Process.isIsolated(uid)) &#123; return Zygote.MOUNT_EXTERNAL_NONE; &#125; if (checkUidPermission(WRITE_MEDIA_STORAGE, uid) == PERMISSION_GRANTED) &#123; return Zygote.MOUNT_EXTERNAL_DEFAULT; &#125; if (checkUidPermission(READ_EXTERNAL_STORAGE, uid) == PERMISSION_DENIED) &#123; return Zygote.MOUNT_EXTERNAL_DEFAULT; &#125; if (checkUidPermission(WRITE_EXTERNAL_STORAGE, uid) == PERMISSION_DENIED) &#123; return Zygote.MOUNT_EXTERNAL_READ; &#125; return Zygote.MOUNT_EXTERNAL_WRITE; &#125; @Override public boolean hasExternalStorage(int uid, String packageName) &#123; return true; &#125; &#125;); // Now that we&#x27;re mostly running, clean up stale users and apps sUserManager.reconcileUsers(StorageManager.UUID_PRIVATE_INTERNAL); reconcileApps(StorageManager.UUID_PRIVATE_INTERNAL); if (mPrivappPermissionsViolations != null) &#123; Slog.wtf(TAG,&quot;Signature|privileged permissions not in &quot; + &quot;privapp-permissions whitelist: &quot; + mPrivappPermissionsViolations); mPrivappPermissionsViolations = null; &#125;&#125; 至此，PKMS启动完毕。 已知的PKMS获取方式PackageManager -&gt;ApplicationPackageManager -&gt; mPm 123IBinder b = ServiceManager.getService(&quot;package&quot;);//Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);PackageManager packageManager = IPackageManager.Stub.asInterface(b); 1context.getPackageManager(); 上面的所有代码基于Android O，有些细节没做了解，有些流程还没有理清，待以后进一步熟悉后再做补充完善，先对已了解内容做个记录。","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"}],"tags":[{"name":"PKMS","slug":"PKMS","permalink":"https://mouzishuo.github.io/tags/PKMS/"},{"name":"PackageManagerService","slug":"PackageManagerService","permalink":"https://mouzishuo.github.io/tags/PackageManagerService/"},{"name":"Android系统服务","slug":"Android系统服务","permalink":"https://mouzishuo.github.io/tags/Android%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"ABI确定过程","slug":"ABI确定过程","date":"2018-07-28T06:21:08.000Z","updated":"2019-01-16T01:14:47.560Z","comments":true,"path":"2018/07/28/ABI确定过程/","link":"","permalink":"https://mouzishuo.github.io/2018/07/28/ABI%E7%A1%AE%E5%AE%9A%E8%BF%87%E7%A8%8B/","excerpt":"","text":"ABI确定过程之所以了解这块内容，是因为在项目中出现了一个奇怪的问题：64位的代码编译刷机后，多个app无法运行，点击后直接闪退，log提示是找不到dex文件。问题非必现，但是第一次启动后如果存在该问题，之后就会一直存在该问题。但是恢复出厂设置和重新刷机后问题可能会消失。 经人提示是32和62位相关的东西引起的，看log发现出问题的apk都是64位的，但是查找的路径是32位的，所以找不到。 问题的log如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434401-01 12:00:00.869 1344 1344 E AndroidRuntime: FATAL EXCEPTION: main01-01 12:00:00.869 1344 1344 E AndroidRuntime: Process: com.android.deskclock, PID: 134401-01 12:00:00.869 1344 1344 E AndroidRuntime: java.lang.RuntimeException: Unable to instantiate application com.android.deskclock.DeskClockApplication: java.lang.ClassNotFoundException: Didn&#x27;t find class &quot;com.android.deskclock.DeskClockApplication&quot; on path: DexPathList[[zip file &quot;/system/app/ApeDeskClock80/ApeDeskClock80.apk&quot;],nativeLibraryDirectories=[/system/app/ApeDeskClock80/lib/arm64, /system/app/ApeDeskClock80/ApeDeskClock80.apk!/lib/armeabi, /system/lib, /vendor/lib, /system/lib, /vendor/lib]]01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.LoadedApk.makeApplication(LoadedApk.java:999)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5742)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.ActivityThread.-wrap1(Unknown Source:0)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1680)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.os.Handler.dispatchMessage(Handler.java:106)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.os.Looper.loop(Looper.java:164)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.ActivityThread.main(ActivityThread.java:6523)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at java.lang.reflect.Method.invoke(Native Method)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:857)01-01 12:00:00.869 1344 1344 E AndroidRuntime: Caused by: java.lang.ClassNotFoundException: Didn&#x27;t find class &quot;com.android.deskclock.DeskClockApplication&quot; on path: DexPathList[[zip file &quot;/system/app/ApeDeskClock80/ApeDeskClock80.apk&quot;],nativeLibraryDirectories=[/system/app/ApeDeskClock80/lib/arm64, /system/app/ApeDeskClock80/ApeDeskClock80.apk!/lib/armeabi, /system/lib, /vendor/lib, /system/lib, /vendor/lib]]01-01 12:00:00.869 1344 1344 E AndroidRuntime: at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:125)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at java.lang.ClassLoader.loadClass(ClassLoader.java:379)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at java.lang.ClassLoader.loadClass(ClassLoader.java:312)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.Instrumentation.newApplication(Instrumentation.java:1087)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.LoadedApk.makeApplication(LoadedApk.java:993)01-01 12:00:00.869 1344 1344 E AndroidRuntime: ... 9 more01-01 12:00:00.869 1344 1344 E AndroidRuntime: Suppressed: java.io.IOException: No original dex files found for dex location /system/app/ApeDeskClock80/ApeDeskClock80.apk01-01 12:00:00.869 1344 1344 E AndroidRuntime: at dalvik.system.DexFile.openDexFileNative(Native Method)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at dalvik.system.DexFile.openDexFile(DexFile.java:353)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at dalvik.system.DexFile.&lt;init&gt;(DexFile.java:100)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at dalvik.system.DexFile.&lt;init&gt;(DexFile.java:74)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at dalvik.system.DexPathList.loadDexFile(DexPathList.java:374)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at dalvik.system.DexPathList.makeDexElements(DexPathList.java:337)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at dalvik.system.DexPathList.&lt;init&gt;(DexPathList.java:157)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at dalvik.system.BaseDexClassLoader.&lt;init&gt;(BaseDexClassLoader.java:65)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at dalvik.system.PathClassLoader.&lt;init&gt;(PathClassLoader.java:64)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at com.android.internal.os.ClassLoaderFactory.createClassLoader(ClassLoaderFactory.java:73)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at com.android.internal.os.ClassLoaderFactory.createClassLoader(ClassLoaderFactory.java:88)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.ApplicationLoaders.getClassLoader(ApplicationLoaders.java:69)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.ApplicationLoaders.getClassLoader(ApplicationLoaders.java:35)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.LoadedApk.createOrUpdateClassLoaderLocked(LoadedApk.java:703)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.LoadedApk.getClassLoader(LoadedApk.java:737)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.LoadedApk.getResources(LoadedApk.java:964)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.ContextImpl.createAppContext(ContextImpl.java:2271)01-01 12:00:00.869 1344 1344 E AndroidRuntime: at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5666)01-01 12:00:00.869 1344 1344 E AndroidRuntime: ... 8 more……01-01 12:16:15.024 800 800 W PackageManager: Instruction set mismatch, PackageSetting&#123;2aef961 com.ape.factory/1000&#125; requires arm whereas PackageSetting&#123;324db9c factory.tinnosnew.tinno.ui.test/1000&#125; requires arm6401-01 12:16:15.024 800 800 W PackageManager: Instruction set mismatch, PackageSetting&#123;2aef961 com.ape.factory/1000&#125; requires arm whereas PackageSetting&#123;8fef249 com.android.settings/1000&#125; requires arm64 刚开始无从下手，先百度。然后找到两篇博客和这个问题一模一样。 https://blog.csdn.net/buding_code/article/details/54633048 https://blog.csdn.net/qq_37610155/article/details/78607276 问题原因都是同一个uid的app有的是32位的有的是64位的，uid都是1000 ，也就是是android.uid.system。从问题的现象可以推断该问题和第一次启动时的某些操作有关，另外和同uid的32位应用有关。根据这两篇博客在log中查找关键词Instruction set mismatch，找到32应用为com.ape.factory。问题点找到了，根据“Instruction set mismatch”的log可以追到PKMS中的adjustCpuAbisForSharedUserLPw方法，从方法名看是用来调整相同uid应用的cpuAbi的，那就来了解下ABI是什么，以及为什么会出现这个问题。 以下关于ABI确定过程的内容来自：https://www.2cto.com/kf/201709/687437.html。 所谓的ABI全称是application binary interface，是一个机器语言级别的接口，描述的是二进制代码之间的兼容性，也就是说一起工作的二进制文件必须是ABI兼容的。 我们都知道Android现在支持的CPU架构大概有：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64这么多种，在Android系统中，上面的每一种CPU架构都关联着一个相应的ABI。如果某个app使用了.so文件，那Android系统就必须要保证这个app进程所关联的ABI要和.so文件所依赖的ABI对应，否则这个app就可能会因为找不到需要的so文件而无法正常运行。今天这篇文章就来介绍一下Android系统是如何决定每个app进程以哪种ABI形式来启动的。 1. abi相关property我们先来看几个和abi相关的系统property(以我自己的系统为例): 123[ro.product.cpu.abilist] : [arm64-v8a, armeabi-v7a, armeabi][ro.product.cpu.abilist32] : [armeabi-v7a, armeabi][ro.product.cpu.abilist64] : [arm64-v8a] ro.product.cpu.abilist的值表明当前系统所支持所有的ABI类型 ro.product.cpu.abilist32和ro.product.cpu.abilist64分别表示系统所支持的32位和64位的ABI类型。 需要注意的是，这些property的排序代表着ABI的优先级，比如ro.product.cpu.abilist的值里arm64-v8a排在第一个，就表明如果没有指定，arm64-v8a就会成为app进程默认启动的关联ABI。 2. app进程启动流程下面这张图是Android系统启动一个新进程的流程图： 可以看到，Android系统中启动新的app进程都是通过socket机制通知zygote进程，然后由zogote进程启动新的app进程。图中有几个关键的函数： 1234567891011121314151617startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123; ... ... String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi; if (requiredAbi == null) &#123; // Build.SUPPORTED_ABIS[0]的值就是ro.product.cpu.abilist这个property的值的第一项 requiredAbi = Build.SUPPORTED_ABIS[0]; &#125; app.requiredAbi = requiredAbi; Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs);&#125; startProcessLocked方法里确定app进程的关联abi过程如下： 如果abiOverride非空的话，就使用abiOverride的值，否则使用app.info.primaryCpuAbi的值 如果app.info.primaryCpuAbi也为空，则使用ro.product.cpu.abilist这个property的值的第一项 关于abiOverride的值，其实我也并不知道它是哪里来的，但是一般情况下，这个值都是空的. 3. primaryCpuAbi值的确定上面提到过app.info.primaryCpuAbi的值会对app进程最终的运行架构产生影响，那app.info.primaryCpuAbi的值又是在哪里确定的呢，答案就在PKMS(PackageManagerService)里。 在PKMS里有两处会对app.info.primaryCpuAbi的值产生影响，分别在scanPackageDirtyLI和adjustCpuAbisForSharedUserLPw两个方法里。 3.1 非第一次开机，直接读取如果手机不是第一次开机或者升级，则应用的ABI直接从packages.xml中读取。 1234567if ((scanFlags &amp; SCAN_FIRST_BOOT_OR_UPGRADE) == 0) &#123; PackageSetting foundPs = mSettings.getPackageLPr(pkg.packageName); if (foundPs != null) &#123; primaryCpuAbiFromSettings = foundPs.primaryCpuAbiString; secondaryCpuAbiFromSettings = foundPs.secondaryCpuAbiString; &#125;&#125; 3.2 scanPackageDirtyLI先看看scanPackageDirtyLI方法里和primaryCpuAbi相关的代码： 123456789101112131415161718192021222324scanPackageDirtyLI() &#123; ... ... // 这个方法里会通过apk包里包含的so库的架构来决定app的primaryCpuAbi的值 derivePackageAbi(pkg, scanFile, cpuAbiOverride, extractNativeLibs, mAppLib32InstallDir); if (isSystemApp(pkg) &amp;&amp; !pkg.isUpdatedSystemApp() &amp;&amp; pkg.applicationInfo.primaryCpuAbi == null) &#123; // 如果是system app，并且这个app没有通过上面的函数找到primaryCpuAbi的值 setBundledAppAbisAndRoots(pkg, pkgSetting); // setNativeLibraryPaths方法会根据CpuAbi的值确定apk使用的so库的安装路径 setNativeLibraryPaths(pkg); &#125; ... ... // 当前解析的apk是framework-res.apk, 对这个特殊的apk, 让它的ABI值的系统相同 // 在我这里，它就是arm64-v8a if (mPlatformPackage == pkg) &#123; pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0]; &#125;&#125; 从上面的这段代码可以看到： 对所有的app，会先通过derivePackageAbi()方法尝试确定app的primaryCpuAbi的值 如果是system app, 并且通过derivePackageAbi()方法没有确定primaryCpuAbi的值，会再尝试通过setBundledAppAbisAndRoots()方法来确定 需要注意的是，无论是第三方app还是系统app, 运行完这段代码之后，仍然存在primaryCpuAbi值为空的情况，这是正常现象. 接着先来看下derivePackageAbi()方法是如何确定primaryCpuAbi的值的： 1234567891011121314151617181920212223242526272829303132public void derivePackageAbi(PackageParser.Package pkg, File scanFile, String cpuAbiOverride, boolean extractLibs) &#123; // 这里会先设置一个默认的so库安装路径 setNativeLibraryPaths(pkg); if (isMultiArch(pkg.applicationInfo)) &#123; // 这里处理的是支持两种abi的apk, 这种apk的AndroidManifest.xml里会设置android:multiarch为true ... ... &#125; else &#123; String[] abiList = (cpuAbiOverride != null) ? new String[] &#123; cpuAbiOverride &#125; : Build.SUPPORTED_ABIS; final int copyRet; // 这是一个JNI函数，作用就是根据apk包里的lib/目录下的.so的ABI确定返回值 copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, abiList, useIsaSpecificSubdirs); // 根据copyRet的值，确定当前app的primaryCpuAbi值 if (copyRet &gt;= 0) &#123; pkg.applicationInfo.primaryCpuAbi = abiList[copyRet]; &#125; else if (copyRet == PackageManager.NO_NATIVE_LIBRARIES &amp;&amp; cpuAbiOverride != null) &#123; pkg.applicationInfo.primaryCpuAbi = cpuAbiOverride; &#125; else if (needsRenderScriptOverride) &#123; pkg.applicationInfo.primaryCpuAbi = abiList[0]; &#125; &#125; // 到这里有一些app已经确定了primaryCpuAbi的值，所以再调一次这个函数，更新它使用的.so库的安装位置 setNativeLibraryPaths(pkg);&#125; 通过这段代码会可以看出： 一些apk包里lib目录下有.so文件的，可以通过.so文件的ABI来确定app的primaryCpuAbi的值 对于那些lib下没有.so文件的apk, 比如不使用so库的或者是系统app，运行完这个方法之后，primaryCpuAbi的值仍然是空 接下来看下系统app是如何通过setBundledAppAbisAndRoots()方法来确定primaryCpuAbi的值的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private void setBundledAppAbisAndRoots(PackageParser.Package pkg, PackageSetting pkgSetting) &#123; final String apkName = deriveCodePathName(pkg.applicationInfo.getCodePath()); final String apkRoot = calculateBundledApkRoot(pkg.applicationInfo.sourceDir); // 使用setBundledAppAbi()方法确定primaryCpuAbi值 setBundledAppAbi(pkg, apkRoot, apkName); if (pkgSetting != null) &#123; pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi; pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi; &#125;&#125; private static void setBundledAppAbi(PackageParser.Package pkg, String apkRoot, String apkName) &#123; final File codeFile = new File(pkg.codePath); final boolean has64BitLibs; final boolean has32BitLibs; if (isApkFile(codeFile)) &#123; // 只有framework-res.apk这个包会进这个if分支，has64BitLibs和has32BitLibs的值都是false // 在前面scanPackageDirtyLI里有说过，这个app的primaryCpuAbi的值是arm64-v8a has64BitLibs = (new File(apkRoot, new File(LIB64_DIR_NAME, apkName).getPath())).exists(); has32BitLibs = (new File(apkRoot, new File(LIB_DIR_NAME, apkName).getPath())).exists(); &#125; else &#123; // 对于其它的app, codeFile是apk所在的路径 final File rootDir = new File(codeFile, LIB_DIR_NAME); final String isa = VMRuntime.getInstructionSet(Build.SUPPORTED_64_BIT_ABIS[0]); // 通过判断/system/app/$&#123;APP_NAME&#125;/lib64这个文件夹是否存在决定has64BitLibs的值 has64BitLibs = (new File(rootDir, isa)).exists(); final String isa = VMRuntime.getInstructionSet(Build.SUPPORTED_32_BIT_ABIS[0]); // 通过判断/system/app/$&#123;APP_NAME&#125;/lib这个文件夹是否存在决定has32BitLibs的值 has32BitLibs = (new File(rootDir, isa)).exists(); &#125; // 下面这一段会根据has64BitLibs和has32BitLibs的值来确定app的primaryCpuAbi的值 if (has64BitLibs &amp;&amp; !has32BitLibs) &#123; pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0]; pkg.applicationInfo.secondaryCpuAbi = null; &#125; else if (has32BitLibs &amp;&amp; !has64BitLibs) &#123; pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0]; pkg.applicationInfo.secondaryCpuAbi = null; &#125; else if (has32BitLibs &amp;&amp; has64BitLibs) &#123; if (VMRuntime.is64BitInstructionSet(getPreferredInstructionSet())) &#123; pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0]; pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0]; &#125; else &#123; pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0]; pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0]; &#125; &#125; else &#123; pkg.applicationInfo.primaryCpuAbi = null; pkg.applicationInfo.secondaryCpuAbi = null; &#125;&#125; 根据上面的代码，可以知道： 对系统app而言，根据&#x2F;system&#x2F;app&#x2F;${APP_NAME}&#x2F;lib和&#x2F;system&#x2F;app&#x2F;${APP_NAME}&#x2F;lib64这两个文件夹是否存在，来确定它的primaryCpuAbi的值 当然，如果系统app不存在上述两个文件夹，那它的primaryCpuAbi的值仍然为空 所以在经过scanPackageDirtyLI()方法之后，会存在以下四种情况： 无论是系统app还是第三方app, 如果apk包里lib目录存在.so文件，会根据.so文件来确定primaryCpuAbi的值 如果是系统app, apk包里又不存在.so文件，就会进一步根据&#x2F;system&#x2F;app&#x2F;${APP_NAME}&#x2F;lib和&#x2F;system&#x2F;app&#x2F;${APP_NAME}&#x2F;lib64这两个文件夹是否存在，来确定它的primaryCpuAbi的值 对于framework-res.apk为个特殊的apk文件，它的primaryCpuAbi的值由虚拟机是什么架构来决定，在我这里，它是arm64-v8a 对于其余的apk, 它们的primaryCpuAbi的值仍然为空. 3.3 adjustCpuAbisForSharedUserLPw先来看下adjustCpuAbisForSharedUserLPw的调用位置，在PKMS的构造函数里: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; //... ... // 逐个解析系统里的所有apk文件，上一节中的内容，都在这里完成 scanDirLI(); //... ... // 当所有的apk文件解析完之后，对使用了相同UID的apk, 调用adjustCpuAbisForSharedUserLPw for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123; // setting.packages是所有使用相同UID的apk的集合 adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */, false /* force dexopt */, false /* defer dexopt */); &#125; // ... ...&#125; private void adjustCpuAbisForSharedUserLPw(Set&lt;packagesetting&gt; packagesForUser, PackageParser.Package scannedPackage, boolean forceDexOpt, boolean deferDexOpt) &#123; String requiredInstructionSet = null; //... ... PackageSetting requirer = null; for (PackageSetting ps : packagesForUser) &#123; if (scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) &#123; if (ps.primaryCpuAbiString == null) &#123; continue; &#125; // 这个for循环的作用就是遍历所有使用相同UID的package，把遍历过程中遇到的第一个确定primaryCpuAbi // 的那个package取出来，保存到requirer中 final String instructionSet = VMRuntime.getInstructionSet(ps.primaryCpuAbiString); if (requiredInstructionSet == null) &#123; // 只取第一个被遍历到的 requiredInstructionSet = instructionSet; requirer = ps; &#125; &#125; &#125; if (requiredInstructionSet != null) &#123; String adjustedAbi; if (requirer != null) &#123; // 证明在这个集合中找到了已经确定primaryCpuAbi的那个package adjustedAbi = requirer.primaryCpuAbiString; &#125; else &#123; // scannedPackage == null时，这种情况不存在，所以不考虑这里 &#125; for (PackageSetting ps : packagesForUser) &#123; if (scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) &#123; if (ps.primaryCpuAbiString != null) &#123; continue; &#125; // 将adjustedAbi的值给那些使用同一个UID并且primaryCpuAbi是空的package ps.primaryCpuAbiString = adjustedAbi; if (ps.pkg != null &amp;&amp; ps.pkg.applicationInfo != null) &#123; ps.pkg.applicationInfo.primaryCpuAbi = adjustedAbi; // ... ... &#125; &#125; &#125; &#125;&#125; 这段代码的作用就是调整使用相同UID的package的primaryCpuAbi的值，将那些还没有确定primaryCpuAbi的package用已经确定了的Abi的值代替。这里将是那些没有确定primaryCpuAbi的apk再次确定abi值的最后一次机会，如果在这里还无法确定，那就在启动进程时，使用系统默认值。 4. 总结最后来总结一下Android系统确定app进程关联哪种ABI的流程： 手机不是第一次开机或者升级，直接从packages.xml中读取； 如果apk包中lib文件夹下有.so库，就根据这个.so库的架构模式确定app的primaryCpuAbi的值 ; 对于system app, 如果没法通过第一步确定primaryCpuAbi的值，PKMS会根据&#x2F;system&#x2F;app&#x2F;${APP_NAME}&#x2F;lib和&#x2F;system&#x2F;app&#x2F;${APP_NAME}&#x2F;lib64这两个文件夹是否存在，来确定它的primaryCpuAbi的值; 对于还没有确定的app, 在最后还会将自己的primaryCpuAbi值与和他使用相同UID的package的值设成一样; 对于到这里还没有确认primaryCpuAbi的app，就会在启动进程时使用ro.product.cpu.abilist这个property的值的第一项作为它关联的ABI; 了解了ABI的确定过程，继续来看前面的问题。上面说的很清楚，第一次开机时app的ABI确定过程分四个过程，首先是找lib文件夹下有没有so，有的话根据so来确定ABI；然后看app目录下有没有lib或lib64文件夹，有的话根据文件夹确定ABI；通过adjustCpuAbisForSharedUserLPw方法将app的api调整为与之uid相同的某个app的ABI；还无法确认的话（同uid的应用都不存在lib和lib64文件夹），去系统默认值。 根据以上过程可以推断，出问题的应用应该是本身无法确定ABI，在通过adjustCpuAbisForSharedUserLPw确定ABI时是根据 com.ape.factory来确定的ABI，也就是32位。因为问题不是必现的，所以adjustCpuAbisForSharedUserLPw确定ABI的顺序应该不是确定的。来看下该方法的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * Adjusts ABIs for a set of packages belonging to a shared user so that they all match. * i.e, so that all packages can be run inside a single process if required. * * Optionally, callers can pass in a parsed package via &#123;@code newPackage&#125; in which case * this function will either try and make the ABI for all packages in &#123;@code packagesForUser&#125; * match &#123;@code scannedPackage&#125; or will update the ABI of &#123;@code scannedPackage&#125; to match * the ABI selected for &#123;@code packagesForUser&#125;. This variant is used when installing or * updating a package that belongs to a shared user. * * NOTE: We currently only match for the primary CPU abi string. Matching the secondary * adds unnecessary complexity. */ private void adjustCpuAbisForSharedUserLPw(Set&lt;PackageSetting&gt; packagesForUser, PackageParser.Package scannedPackage) &#123; String requiredInstructionSet = null; //根据log可以判断scannedPackage为空，不考虑这个分支 if (scannedPackage != null &amp;&amp; scannedPackage.applicationInfo.primaryCpuAbi != null) &#123; requiredInstructionSet = VMRuntime.getInstructionSet( scannedPackage.applicationInfo.primaryCpuAbi); Slog.i(TAG, &quot;In adjustCpuAbisForSharedUserLPw, scannedPackage:&quot; + scannedPackage.toString() + &quot;, primaryCpuAbi:&quot; + scannedPackage.applicationInfo.primaryCpuAbi); &#125; PackageSetting requirer = null;//首个能自身确定ABI的应用 //遍历同ｕid的应用，packagesForUser是个ｓｅｔ，每次遍历的顺序不确定 for (PackageSetting ps : packagesForUser) &#123; // If packagesForUser contains scannedPackage, we skip it. This will happen // when scannedPackage is an update of an existing package. Without this check, // we will never be able to change the ABI of any package belonging to a shared // user, even if it&#x27;s compatible with other packages. if (scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) &#123; //找到首个能自身确定ABI的应用，用于确定requirer和requiredInstructionSet if (ps.primaryCpuAbiString == null) &#123; continue; &#125; final String instructionSet = VMRuntime.getInstructionSet(ps.primaryCpuAbiString); //找到首个能自身确定ABI的应用之前requiredInstructionSet一直为空 if (requiredInstructionSet != null &amp;&amp; !instructionSet.equals(requiredInstructionSet)) &#123; // We have a mismatch between instruction sets (say arm vs arm64) warn about // this but there&#x27;s not much we can do. //同ｕｉｄ的应用是能运行在同一个进程的，所以指令集应该是一致的，但是如果不一致， //系统也无能为力 String errorMessage = &quot;Instruction set mismatch, &quot; + ((requirer == null) ? &quot;[caller]&quot; : requirer) + &quot; requires &quot; + requiredInstructionSet + &quot; whereas &quot; + ps + &quot; requires &quot; + instructionSet; Slog.w(TAG, errorMessage); &#125; //找到首个能自身确定ABI的应用后赋值，之后循环不会再走到这里 if (requiredInstructionSet == null) &#123; requiredInstructionSet = instructionSet; requirer = ps; &#125; &#125; &#125; if (requiredInstructionSet != null) &#123; String adjustedAbi; if (requirer != null) &#123;//存在能确定自身ＡＢＩ的应用 // requirer != null implies that either scannedPackage was null or that scannedPackage // did not require an ABI, in which case we have to adjust scannedPackage to match // the ABI of the set (which is the same as requirer&#x27;s ABI) adjustedAbi = requirer.primaryCpuAbiString; if (scannedPackage != null) &#123; scannedPackage.applicationInfo.primaryCpuAbi = adjustedAbi; &#125; &#125; else &#123; // requirer == null implies that we&#x27;re updating all ABIs in the set to // match scannedPackage. adjustedAbi = scannedPackage.applicationInfo.primaryCpuAbi; &#125; for (PackageSetting ps : packagesForUser) &#123; if (scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) &#123; if (ps.primaryCpuAbiString != null) &#123;//能自己确定ＡＢＩ的就不会再走这里，保留已经确定的值 continue; &#125; ps.primaryCpuAbiString = adjustedAbi; if (ps.pkg != null &amp;&amp; ps.pkg.applicationInfo != null &amp;&amp; !TextUtils.equals(adjustedAbi, ps.pkg.applicationInfo.primaryCpuAbi)) &#123; //根据首个得到的ＡＢＩ确定其余应用的ＡＢＩ，该值会写入/ｄａｔａ/system/packages.xml中，再次启动手机时直接从该文件读取 ps.pkg.applicationInfo.primaryCpuAbi = adjustedAbi; if (DEBUG_ABI_SELECTION) &#123; Slog.i(TAG, &quot;Adjusting ABI for &quot; + ps.name + &quot; to &quot; + adjustedAbi + &quot; (requirer=&quot; + (requirer != null ? requirer.pkg : &quot;null&quot;) + &quot;, scannedPackage=&quot; + (scannedPackage != null ? scannedPackage : &quot;null&quot;) + &quot;)&quot;); &#125; try &#123; mInstaller.rmdex(ps.codePathString, getDexCodeInstructionSet(getPreferredInstructionSet())); &#125; catch (InstallerException ignored) &#123; &#125; &#125; &#125; &#125; &#125; &#125; 关于ps.pkg.applicationInfo.primaryCpuAbi = adjustedAbi;中primaryCpuAbi的说明： 12345678910/** * The primary ABI that this application requires, This is inferred from the ABIs * of the native JNI libraries the application bundles. Will be &#123;@code null&#125; * if this application does not require any particular ABI. * * If non-null, the application will always be launched with this ABI. * * &#123;@hide&#125; */public String primaryCpuAbi; 上面的代码证明上面的推测是正确的，保险起见，又加了些log,分别抓取了正常情况下的ｌｏｇ和出问题时的ｌｏｇ，从log中可以看出，在出问题时，com.ape.factory都是遍历过程中第一个可以确认自身ABI的应用，而在正常的情况下，第一个可以确认自身ABI的应用的ABI都是64位的，满足这个条件的应用有两个：com.android.settings和factory.tinnosnew.tinno.ui.test（&#x2F;system&#x2F;app&#x2F;Mygsensortest）。所以是否会出问题取决于在遍历过程中先取到factory还是另外两个应用，只要不先取到factory就不会出现问题。将代码修改未只能根据factory确定其余应用ABI，则该问题变为必现，进一步证明该问题就是factory引起的。 最后，要确定是不是存在相同uid中同时有32位和64位的apk，只需要在log中搜索‘“PackageManager: Instruction set mismatch”即可。比如： 1Instruction set mismatch, PackageSetting&#123;b4910c6 factory.tinnosnew.tinno.ui.test/1000&#125; requires arm64 whereas PackageSetting&#123;da776f5 com.ape.factory/1000&#125; requires arm 表示先取得的是64位的factory.tinnosnew.tinno.ui.test，这时一切正常； 1201-01 12:40:19.782 823 823 W PackageManager: Instruction set mismatch, PackageSetting&#123;58e729 com.ape.factory/1000&#125; requires arm whereas PackageSetting&#123;79d22ba com.android.settings/1000&#125; requires arm6401-01 12:40:19.783 823 823 W PackageManager: Instruction set mismatch, PackageSetting&#123;58e729 com.ape.factory/1000&#125; requires arm whereas PackageSetting&#123;bd64d3a factory.tinnosnew.tinno.ui.test/1000&#125; requires arm64 表示先取到的是com.ape.factory，这时就会出现文中的问题。 尾声一个疑惑： 101-01 12:00:00.869 1344 1344 E AndroidRuntime: java.lang.RuntimeException: Unable to instantiate application com.android.deskclock.DeskClockApplication: java.lang.ClassNotFoundException: Didn&#x27;t find class &quot;com.android.deskclock.DeskClockApplication&quot; on path: DexPathList[[zip file &quot;/system/app/ApeDeskClock80/ApeDeskClock80.apk&quot;],nativeLibraryDirectories=[/system/app/ApeDeskClock80/lib/arm64, /system/app/ApeDeskClock80/ApeDeskClock80.apk!/lib/armeabi, /system/lib, /vendor/lib, /system/lib, /vendor/lib]] 一直以为这段log说的是在“zip file “&#x2F;system&#x2F;app&#x2F;ApeDeskClock80&#x2F;ApeDeskClock80.apk”],nativeLibraryDirectories&#x3D;[&#x2F;system&#x2F;app&#x2F;ApeDeskClock80&#x2F;lib&#x2F;arm64, &#x2F;system&#x2F;app&#x2F;ApeDeskClock80&#x2F;ApeDeskClock80.apk!&#x2F;lib&#x2F;armeabi, &#x2F;system&#x2F;lib, &#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib, &#x2F;vendor&#x2F;lib”这些路径下找不到DeskClockApplication这个类，但实际上dex文件是在appname&#x2F;oat&#x2F;arm（64）下面的，即使不存下32和64位的问题，也应该找不到dex的，为什么能找到？ 后来问了同时才知道DexPathList[[zip file “&#x2F;system&#x2F;app&#x2F;ApeDeskClock80&#x2F;ApeDeskClock80.apk”],nativeLibraryDirectories&#x3D;[&#x2F;system&#x2F;app&#x2F;ApeDeskClock80&#x2F;lib&#x2F;arm64, &#x2F;system&#x2F;app&#x2F;ApeDeskClock80&#x2F;ApeDeskClock80.apk!&#x2F;lib&#x2F;armeabi, &#x2F;system&#x2F;lib, &#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib, &#x2F;vendor&#x2F;lib]]描述的是一系列的dex文件，[zip file “&#x2F;system&#x2F;app&#x2F;ApeDeskClock80&#x2F;ApeDeskClock80.apk”],nativeLibraryDirectories&#x3D;[&#x2F;system&#x2F;app&#x2F;ApeDeskClock80&#x2F;lib&#x2F;arm64, &#x2F;system&#x2F;app&#x2F;ApeDeskClock80&#x2F;ApeDeskClock80.apk!&#x2F;lib&#x2F;armeabi, &#x2F;system&#x2F;lib, &#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib, &#x2F;vendor&#x2F;lib]是其中一个dex文件的描述信息。这部分还有待了解。 以上的内容时关于首次开机时应用ABI的确定的，关于应用其他安装方式中ABI的确定在了解应用安装过程时再做了解。","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"},{"name":"应用安装","slug":"Android/应用安装","permalink":"https://mouzishuo.github.io/categories/Android/%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"PKMS","slug":"PKMS","permalink":"https://mouzishuo.github.io/tags/PKMS/"},{"name":"PackageManagerService","slug":"PackageManagerService","permalink":"https://mouzishuo.github.io/tags/PackageManagerService/"},{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"},{"name":"ABI","slug":"ABI","permalink":"https://mouzishuo.github.io/tags/ABI/"}]},{"title":"应用安装-adb方式进行安装","slug":"adb安装应用","date":"2018-07-28T06:21:08.000Z","updated":"2019-01-16T01:14:47.564Z","comments":true,"path":"2018/07/28/adb安装应用/","link":"","permalink":"https://mouzishuo.github.io/2018/07/28/adb%E5%AE%89%E8%A3%85%E5%BA%94%E7%94%A8/","excerpt":"","text":"adb方式进行安装adb 相关代码在system&#x2F;core&#x2F;adb&#x2F;中，入口在&#x2F;system&#x2F;core&#x2F;adb&#x2F;client&#x2F;main.cpp的main方法中： 1234int main(int argc, char** argv) &#123; adb_trace_init(argv); return adb_commandline(argc - 1, const_cast&lt;const char**&gt;(argv + 1));&#125; 命令的处理在system&#x2F;core&#x2F;adb&#x2F;commandline.cpp中，与安装相关的代码也在其中,经过参数解析调到下面的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static int install_app(int argc, const char** argv) &#123; // The last argument must be the APK file const char* file = argv[argc - 1]; if (!android::base::EndsWithIgnoreCase(file, &quot;.apk&quot;)) &#123; return syntax_error(&quot;filename doesn&#x27;t end .apk: %s&quot;, file); &#125; struct stat sb; if (stat(file, &amp;sb) == -1) &#123; fprintf(stderr, &quot;adb: failed to stat %s: %s\\n&quot;, file, strerror(errno)); return 1; &#125; int localFd = adb_open(file, O_RDONLY); if (localFd &lt; 0) &#123; fprintf(stderr, &quot;adb: failed to open %s: %s\\n&quot;, file, strerror(errno)); return 1; &#125; std::string error; std::string cmd = &quot;exec:cmd package&quot;; // don&#x27;t copy the APK name, but, copy the rest of the arguments as-is while (argc-- &gt; 1) &#123; cmd += &quot; &quot; + escape_arg(std::string(*argv++)); &#125; // add size parameter [required for streaming installs] // do last to override any user specified value cmd += &quot; &quot; + android::base::StringPrintf(&quot;-S %&quot; PRIu64, static_cast&lt;uint64_t&gt;(sb.st_size)); int remoteFd = adb_connect(cmd, &amp;error); if (remoteFd &lt; 0) &#123; fprintf(stderr, &quot;adb: connect error for write: %s\\n&quot;, error.c_str()); adb_close(localFd); return 1; &#125; char buf[BUFSIZ]; copy_to_file(localFd, remoteFd); read_status_line(remoteFd, buf, sizeof(buf)); adb_close(localFd); adb_close(remoteFd); if (!strncmp(&quot;Success&quot;, buf, 7)) &#123; fputs(buf, stdout); return 0; &#125; fprintf(stderr, &quot;adb: failed to install %s: %s&quot;, file, buf); return 1;&#125; 其实是通过adb shell cmd package（包管理命令）进行安装，安装后adb 断开。也就是说在adb shell中通过cmd也可以调用各种adb的命令。但是不能用cmd package install 安装手机上的apk。通过cmd -l可以查看cmd支持的命令： 1234520|k400_o:/data/data # cmd -l Currently running services: AAL //省略 window 输出结果和adb shell dumpsys -l结果一致。cmd对应的可执行文件为&#x2F;system&#x2F;bin&#x2F;cmd，对应的源码为frameworks&#x2F;native&#x2F;cmds&#x2F;cmd&#x2F;cmd.cpp，入口方法如下： 1234567891011121314151617181920212223242526272829303132333435int main(int argc, char* const argv[])&#123; //…… sp&lt;IServiceManager&gt; sm = defaultServiceManager(); fflush(stdout); //…… if ((argc == 2) &amp;&amp; (strcmp(argv[1], &quot;-l&quot;) == 0)) &#123;//对应adb shell cmd -l命令 Vector&lt;String16&gt; services = sm-&gt;listServices(); services.sort(sort_func); aout &lt;&lt; &quot;Currently running services:&quot; &lt;&lt; endl; for (size_t i=0; i&lt;services.size(); i++) &#123; sp&lt;IBinder&gt; service = sm-&gt;checkService(services[i]); if (service != NULL) &#123; aout &lt;&lt; &quot; &quot; &lt;&lt; services[i] &lt;&lt; endl; &#125; &#125; return 0; &#125; Vector&lt;String16&gt; args; for (int i=2; i&lt;argc; i++) &#123; args.add(String16(argv[i])); &#125; String16 cmd = String16(argv[1]);//cmd:package sp&lt;IBinder&gt; service = sm-&gt;checkService(cmd); //…… sp&lt;MyShellCallback&gt; cb = new MyShellCallback(); sp&lt;MyResultReceiver&gt; result = new MyResultReceiver(); // TODO: block until a result is returned to MyResultReceiver. status_t err = IBinder::shellCommand(service, STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO, args, cb, result); //…… return res;&#125; PKMS在启动后会注册到ServiceManager中，所以这里的package服务应该就是PKMS了，看下c++层Binder的shellCommand方法： 123456789101112131415161718status_t IBinder::shellCommand(const sp&lt;IBinder&gt;&amp; target, int in, int out, int err, Vector&lt;String16&gt;&amp; args, const sp&lt;IShellCallback&gt;&amp; callback, const sp&lt;IResultReceiver&gt;&amp; resultReceiver)&#123; Parcel send; Parcel reply; send.writeFileDescriptor(in); send.writeFileDescriptor(out); send.writeFileDescriptor(err); const size_t numArgs = args.size(); send.writeInt32(numArgs); for (size_t i = 0; i &lt; numArgs; i++) &#123; send.writeString16(args[i]); &#125; send.writeStrongBinder(callback != NULL ? IInterface::asBinder(callback) : NULL); send.writeStrongBinder(resultReceiver != NULL ? IInterface::asBinder(resultReceiver) : NULL); return target-&gt;transact(SHELL_COMMAND_TRANSACTION, send, &amp;reply);&#125; 只需要关心其中一句return target-&gt;transact(SHELL_COMMAND_TRANSACTION, send, &amp;reply);即可。这里的target不难推测应该就是PKMS，但是PKMS中并没用处理SHELL_COMMAND_TRANSACTION，transact的第一个参数从C++ 层到java层一般是不会变的，不停地往父类查找，发现该消息是在Binder.java中处理的。PKMS是Binder的间接子类，不难推测PKMS肯定覆写了Binder的某个方法，而在SHELL_COMMAND_TRANSACTION的后续处理中会调用到该方法，然后流程进入到PKMS中。来看下java层的Binder，看看收到SHELL_COMMAND_TRANSACTION消息会做些什么： 1234567891011121314151617181920212223242526272829303132333435363738protected boolean onTransact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException &#123; if (code == INTERFACE_TRANSACTION) &#123; reply.writeString(getInterfaceDescriptor()); return true; &#125; else if (code == DUMP_TRANSACTION) &#123;对应adb shell dumpsys???? ParcelFileDescriptor fd = data.readFileDescriptor(); String[] args = data.readStringArray(); if (fd != null) &#123; try &#123; dump(fd.getFileDescriptor(), args); &#125; finally &#123; IoUtils.closeQuietly(fd); &#125; &#125; // Write the StrictMode header. if (reply != null) &#123; reply.writeNoException(); &#125; else &#123; StrictMode.clearGatheredViolations(); &#125; return true; &#125; else if (code == SHELL_COMMAND_TRANSACTION) &#123; //…… try &#123; if (out != null) &#123; shellCommand(in != null ? in.getFileDescriptor() : null, out.getFileDescriptor(), err != null ? err.getFileDescriptor() : out.getFileDescriptor(), args, shellCallback, resultReceiver); &#125; &#125; finally &#123; //…… &#125; return true; &#125; return false;&#125; shellCommand方法： 1234567public void shellCommand(@Nullable FileDescriptor in, @Nullable FileDescriptor out, @Nullable FileDescriptor err, @NonNull String[] args, @Nullable ShellCallback callback, @NonNull ResultReceiver resultReceiver) throws RemoteException &#123; onShellCommand(in, out, err, args, callback, resultReceiver);&#125; onShellCommander方法： 12345678910public void onShellCommand(@Nullable FileDescriptor in, @Nullable FileDescriptor out, @Nullable FileDescriptor err, @NonNull String[] args, @Nullable ShellCallback callback, @NonNull ResultReceiver resultReceiver) throws RemoteException &#123; FileOutputStream fout = new FileOutputStream(err != null ? err : out); PrintWriter pw = new FastPrintWriter(fout); pw.println(&quot;No shell command implementation.&quot;); pw.flush(); resultReceiver.send(0, null);&#125; 上面是Binder.java实现的onShellCommand方法，而PKMS覆写了该方法，所以这里调用的应该是PKMS的onShellCommand方法： 1234567@Overridepublic void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ShellCallback callback, ResultReceiver resultReceiver) &#123; (new PackageManagerShellCommand(this)).exec( this, in, out, err, args, callback, resultReceiver);&#125; onShellCommand调用了PackageManagerShellCommand的exec方法来执行命令行获取的命令，PackageManagerShellCommand继承自抽象类ShellCommand，而该类是用来辅助实现Binder.onShellCommand方法的。 1234567891011121314151617public int exec(Binder target, FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ShellCallback callback, ResultReceiver resultReceiver) &#123; String cmd; //…… mCmd = cmd; mResultReceiver = resultReceiver; int res = -1; try &#123; res = onCommand(mCmd); &#125; catch (SecurityException e) &#123;//…… &#125; catch (Throwable e) &#123;//…… &#125; finally &#123; //…… &#125; if (DEBUG) Slog.d(TAG, &quot;Finished command &quot; + mCmd + &quot; on &quot; + mTarget); return res; &#125; onCommand方法： 1234567891011121314151617181920@Override public int onCommand(String cmd) &#123; if (cmd == null) &#123; return handleDefaultCommands(cmd); &#125; final PrintWriter pw = getOutPrintWriter(); try &#123; switch(cmd) &#123; case &quot;install&quot;: return runInstall(); //省略代码 default: return handleDefaultCommands(cmd); &#125; &#125; catch (RemoteException e) &#123; pw.println(&quot;Remote exception: &quot; + e); &#125; return -1; &#125; 支持的命令很多，这里只关心install，该命令对应runInstall()方法，runInstall()方法可以分为以下几个部分： 参数解析 123final InstallParams params = makeInstallParams();final String inPath = getNextArg();setParamsSize(params, inPath); 这部分较简单，就是对前面安装命令中参数的解析并根据参数设置installFlags的标志位。 创建应用安装会话 12final int sessionId = doCreateSession(params.sessionParams, params.installerPackageName, params.userId);//adb安装，userid为0 123456789101112private int doCreateSession(SessionParams params, String installerPackageName, int userId) throws RemoteException &#123; userId = translateUserId(userId, &quot;runInstallCreate&quot;); if (userId == UserHandle.USER_ALL) &#123; userId = UserHandle.USER_SYSTEM; params.installFlags |= PackageManager.INSTALL_ALL_USERS; &#125; final int sessionId = mInterface.getPackageInstaller() .createSession(params, installerPackageName, userId); return sessionId;&#125; 然后调用到PackageInstallerService的createSession()方法： 12345678@Overridepublic int createSession(SessionParams params, String installerPackageName, int userId) &#123; try &#123; return createSessionInternal(params, installerPackageName, userId); &#125; catch (IOException e) &#123; throw ExceptionUtils.wrap(e); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114 private int createSessionInternal(SessionParams params, String installerPackageName, int userId) throws IOException &#123;//userid为0 final int callingUid = Binder.getCallingUid();//adb的linux uid为0 mPm.enforceCrossUserPermission(callingUid, userId, true, true, &quot;createSession&quot;); if (mPm.isUserRestricted(userId, UserManager.DISALLOW_INSTALL_APPS)) &#123; throw new SecurityException(&quot;User restriction prevents installing&quot;); &#125; if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID/*0*/)) &#123; params.installFlags |= PackageManager.INSTALL_FROM_ADB; &#125; else &#123; mAppOps.checkPackage(callingUid, installerPackageName); params.installFlags &amp;= ~PackageManager.INSTALL_FROM_ADB; params.installFlags &amp;= ~PackageManager.INSTALL_ALL_USERS; params.installFlags |= PackageManager.INSTALL_REPLACE_EXISTING; if ((params.installFlags &amp; PackageManager.INSTALL_VIRTUAL_PRELOAD) != 0 &amp;&amp; !mPm.isCallerVerifier(callingUid)) &#123; params.installFlags &amp;= ~PackageManager.INSTALL_VIRTUAL_PRELOAD; &#125; &#125; // Only system components can circumvent runtime permissions when installing. if ((params.installFlags &amp; PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0 &amp;&amp; mContext.checkCallingOrSelfPermission(Manifest.permission .INSTALL_GRANT_RUNTIME_PERMISSIONS) == PackageManager.PERMISSION_DENIED) &#123; throw new SecurityException(&quot;You need the &quot; + &quot;android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS permission &quot; + &quot;to use the PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS flag&quot;); &#125; if ((params.installFlags &amp; PackageManager.INSTALL_FORWARD_LOCK) != 0 || (params.installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0) &#123; throw new IllegalArgumentException( &quot;New installs into ASEC containers no longer supported&quot;); &#125; // Defensively resize giant app icons if (params.appIcon != null) &#123; final ActivityManager am = (ActivityManager) mContext.getSystemService( Context.ACTIVITY_SERVICE); final int iconSize = am.getLauncherLargeIconSize(); if ((params.appIcon.getWidth() &gt; iconSize * 2) || (params.appIcon.getHeight() &gt; iconSize * 2)) &#123; params.appIcon = Bitmap.createScaledBitmap(params.appIcon, iconSize, iconSize, true); &#125; &#125; switch (params.mode) &#123; case SessionParams.MODE_FULL_INSTALL: case SessionParams.MODE_INHERIT_EXISTING: break; default: throw new IllegalArgumentException(&quot;Invalid install mode: &quot; + params.mode); &#125; // If caller requested explicit location, sanity check it, otherwise // resolve the best internal or adopted location. if ((params.installFlags &amp; PackageManager.INSTALL_INTERNAL) != 0) &#123; //…… &#125; else if ((params.installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0) &#123;//…… &#125; else if ((params.installFlags &amp; PackageManager.INSTALL_FORCE_VOLUME_UUID) != 0) &#123; // For now, installs to adopted media are treated as internal from // an install flag point-of-view. params.setInstallFlagsInternal(); &#125; else &#123; //adb 安装走这里 // For now, installs to adopted media are treated as internal from // an install flag point-of-view. params.setInstallFlagsInternal(); // Resolve best location for install, based on combination of // requested install flags, delta size, and manifest settings. final long ident = Binder.clearCallingIdentity(); try &#123; params.volumeUuid = PackageHelper.resolveInstallVolume(mContext, params); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125; final int sessionId; final PackageInstallerSession session; synchronized (mSessions) &#123; // Sanity check that installer isn&#x27;t going crazy //…… sessionId = allocateSessionIdLocked(); &#125; final long createdMillis = System.currentTimeMillis(); // We&#x27;re staging to exactly one location File stageDir = null; String stageCid = null; if ((params.installFlags &amp; PackageManager.INSTALL_INTERNAL) != 0) &#123; final boolean isInstant = (params.installFlags &amp; PackageManager.INSTALL_INSTANT_APP) != 0; stageDir = buildStageDir(params.volumeUuid, sessionId, isInstant); &#125; else &#123; stageCid = buildExternalStageCid(sessionId); &#125; session = new PackageInstallerSession(mInternalCallback, mContext, mPm, mInstallThread.getLooper(), sessionId, userId, installerPackageName, callingUid, params, createdMillis, stageDir, stageCid, false, false); synchronized (mSessions) &#123; mSessions.put(sessionId, session); &#125; mCallbacks.notifySessionCreated(session.sessionId, session.userId); writeSessionsAsync(); return sessionId; &#125; 上面方法的主要作用是创建PackageInstallerSession并添加到mSessions中，并将sessionId返回，该Session在安装结束或失败后都会被销毁。里面涉及到Binder的两种用法，因为和这里的主题关系不大，以后另作了解。 1final int callingUid = Binder.getCallingUid();// 12final long ident = Binder.clearCallingIdentity();Binder.restoreCallingIdentity(ident); 上段代码里有个对安装流程比较关键的地方： 1stageDir = buildStageDir(params.volumeUuid, sessionId, isInstant); 该目录为&#x2F;data&#x2F;app&#x2F;vmdl×××××.tmp（之前了解开机扫描app的过程中好像看到过，这种目录在扫描中会被跳过），从adb读取的apk文件会暂时存放到该目录下，然后apk中的so文件也会提取到该目录。 session的具体创建过程就不了解了，只看下session创建时的参数： 123session = new PackageInstallerSession(mInternalCallback, mContext, mPm, mInstallThread.getLooper(), sessionId, userId, installerPackageName, callingUid, params, createdMillis, stageDir, stageCid, false, false); mInternalCallback封装了Session生命周期中的回调； mContext：Session的上下文 mPm：PackageManagerService的实例； mInstallThread.getLooper()安装线程的looper，mInstallThread为HandlerThread实例，从这里可以推断应用安装是在子线程中进行的，该子线程是在PackageInstallerService初始化方法中创建的，而PackageInstallerService的初始化方法是在PKMS的初始化方法中调用的。 sessionId作为session的标示； userId这里为0； installerPackageName对应packageInstaller的包名，比如com.android.packageinstaller; callingUid为0 params：安装参数； stageDir:apk暂存目录； 把apk复制到临时目录 1234if (doWriteSplit(sessionId, inPath, params.sessionParams.sizeBytes, &quot;base.apk&quot;, false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) &#123;//把base.apk拷贝到/data/app/vmdl1025879988.tmp目录下 return 1;&#125; 前面已经构建了应用安装的session信息，接下来这一步会根据sessionId获取session信息（SessionInfo类），然后从标准输入流读入apk文件并写入到&#x2F;data&#x2F;app&#x2F;vmdl×××××.tmp&#x2F;base.apk. 通过打断点的方式可以看到临时目录的信息： nativeLib的复制会在下一步进行。 提交会话 1234if (doCommitSession(sessionId, false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) &#123;//提取lib到/data/app/vmdl1025879988.tmp目录下??? return 1;&#125; 1234567891011121314151617181920212223242526private int doCommitSession(int sessionId, boolean logSuccess) throws RemoteException &#123; final PrintWriter pw = getOutPrintWriter(); PackageInstaller.Session session = null; try &#123; session = new PackageInstaller.Session( mInterface.getPackageInstaller().openSession(sessionId)); final LocalIntentReceiver receiver = new LocalIntentReceiver(); session.commit(receiver.getIntentSender()); final Intent result = receiver.getResult(); final int status = result.getIntExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE); if (status == PackageInstaller.STATUS_SUCCESS) &#123; if (logSuccess) &#123; pw.println(&quot;Success&quot;); &#125; &#125; else &#123; pw.println(&quot;Failure [&quot; + result.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE) + &quot;]&quot;); &#125; return status; &#125; finally &#123; IoUtils.closeQuietly(session); &#125;&#125; 调用PackageInstaller.Session#commit()提交installersession，然后把执行的结果写到receiver中，并在标准输出输出结果。再来看下session.commit的具体实现： 12345678910111213141516171819/** * Attempt to commit everything staged（暂存） in this session. This may require * user intervention（介入）, and so it may not happen immediately. The final * result of the commit will be reported through the given callback. * &lt;p&gt; * Once this method is called, the session is sealed and no additional * mutations may be performed on the session. If the device reboots * before the session has been finalized, you may commit the session again. * * @throws SecurityException if streams opened through * &#123;@link #openWrite(String, long, long)&#125; are still open. */public void commit(@NonNull IntentSender statusReceiver) &#123; try &#123; mSession.commit(statusReceiver, false); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 该方法一旦调用该installersession就会封存起来，不再允许进行改变。mSession为IPackageInstallerSession类型，具体类型为PackageInstallerSession，其commit方法实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Overridepublic void commit(@NonNull IntentSender statusReceiver, boolean forTransfer) &#123; Preconditions.checkNotNull(statusReceiver); final boolean wasSealed; synchronized (mLock) &#123; //Check if the caller is the owner of this session. Otherwise throw a //SecurityException. assertCallerIsOwnerOrRootLocked(); assertPreparedAndNotDestroyedLocked(&quot;commit&quot;); final PackageInstallObserverAdapter adapter = new PackageInstallObserverAdapter( mContext, statusReceiver, sessionId, isInstallerDeviceOwnerLocked(), userId); mRemoteObserver = adapter.getBinder(); if (forTransfer) &#123;//adb安装forTransfer值为false mContext.enforceCallingOrSelfPermission(Manifest.permission.INSTALL_PACKAGES, null); if (mInstallerUid == mOriginalInstallerUid) &#123; throw new IllegalArgumentException(&quot;Session has not been transferred&quot;); &#125; &#125; else &#123; if (mInstallerUid != mOriginalInstallerUid) &#123; throw new IllegalArgumentException(&quot;Session has been transferred&quot;); &#125; &#125; wasSealed = mSealed; if (!mSealed) &#123; try &#123; //Seal the session to prevent further modification and validate the contents of it. sealAndValidateLocked(); &#125; catch (IOException e) &#123; throw new IllegalArgumentException(e); &#125; catch (PackageManagerException e) &#123; destroyInternal(); // Cannot call dispatchFinal synchronous as this might be called from inside the // system server on the main thread. Hence the call back scheduled in // dispachFinal has to be scheduled on a different thread. mHandler.obtainMessage(MSG_SESSION_FINISHED_WITH_EXCEPTION, e).sendToTarget(); return; &#125; &#125; // Client staging is fully done at this point //更新callback中的进度，callback存在于Launcher和PackageInstaller中，本地安装 //时会回调到packageInstaller中 mClientProgress = 1f; computeProgressLocked(true); // This ongoing commit should keep session active, even though client // will probably close their end. mActiveCount.incrementAndGet(); mCommitted = true;//切换到安装线程，提交信息 mHandler.obtainMessage(MSG_COMMIT).sendToTarget(); &#125; if (!wasSealed) &#123; // Persist the fact that we&#x27;ve sealed ourselves to prevent // mutations of any hard links we create. We do this without holding // the session lock, since otherwise it&#x27;s a lock inversion. mCallback.onSessionSealedBlocking(this); &#125;&#125; 首先进行了一些检测工作，之后封存session，然后更新进度，该过程会调用一系列的回调方法，最终通知Launcher和PackageInstaller等应用安装进度，再然后从binder线程切换到安装线程，正式进行session的提交，最后将封存的session信息写到&#x2F;data&#x2F;system&#x2F;install_sessions.xml中，该文件的内容大致如下： 1234&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27; standalone=&#x27;yes&#x27; ?&gt;&lt;sessions&gt;&lt;session sessionId=&quot;23005909&quot; userId=&quot;0&quot; installerUid=&quot;0&quot; createdMillis=&quot;1533527321478&quot; sessionStageDir=&quot;/data/app/vmdl23005909.tmp&quot; prepared=&quot;true&quot; sealed=&quot;true&quot; mode=&quot;1&quot; installFlags=&quot;114&quot; installLocation=&quot;1&quot; sizeBytes=&quot;6003376&quot; originatingUid=&quot;-1&quot; installRason=&quot;0&quot; /&gt;&lt;/sessions&gt; 下面就该了解下MSG_COMMIT这个消息是怎么处理的了，该message是在Handler的callback中处理的，具体代码如下： 1234567891011121314case MSG_COMMIT: synchronized (mLock) &#123; try &#123; commitLocked(); &#125; catch (PackageManagerException e) &#123; final String completeMsg = ExceptionUtils.getCompleteMessage(e); Slog.e(TAG, &quot;Commit of session &quot; + sessionId + &quot; failed: &quot; + completeMsg); destroyInternal(); dispatchSessionFinished(e.error, completeMsg, null); &#125; &#125; break; 首先调用commitLocked()提交会话，如果出现异常则进行一些清理工作，删除安装过程中创建的文件，并将该session标记为destroyed,然后分发session提交失败的消息，该分发过程在安装成功的情况下再介绍，这里先不管。 接着继续看commit的过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 private void commitLocked() throws PackageManagerException &#123; //省略一些检测代码 if (needToAskForPermissionsLocked()) &#123;//请求安装权限，adb安装不需要申请权限 // User needs to accept permissions; give installer an intent they // can use to involve user. final Intent intent = new Intent(PackageInstaller.ACTION_CONFIRM_PERMISSIONS); intent.setPackage(mContext.getPackageManager().getPermissionControllerPackageName()); intent.putExtra(PackageInstaller.EXTRA_SESSION_ID, sessionId); try &#123; mRemoteObserver.onUserActionRequired(intent); &#125; catch (RemoteException ignored) &#123; &#125; // Commit was keeping session marked as active until now; release // that extra refcount so session appears idle. closeInternal(false); return; &#125;//…… // Inherit any packages and native libraries from existing install that // haven&#x27;t been overridden. if (params.mode == SessionParams.MODE_INHERIT_EXISTING) &#123; //常见的安装模式是MODE_FULL_INSTALL=1，安装时带-p参数时会将该标志位置为1， //MODE_INHERIT_EXISTING的情况先不管 &#125; // TODO: surface more granular state from dexopt mInternalProgress = 0.5f; computeProgressLocked(true);//更新进度 // Unpack native libraries extractNativeLibraries(mResolvedStageDir, params.abiOverride);//…… // We&#x27;ve reached point of no return; call into PMS to install the stage. // Regardless of success or failure we always destroy session. final IPackageInstallObserver2 localObserver = new IPackageInstallObserver2.Stub() &#123; //省略 &#125;; final UserHandle user; if ((params.installFlags &amp; PackageManager.INSTALL_ALL_USERS) != 0) &#123; user = UserHandle.ALL; &#125; else &#123; user = new UserHandle(userId); &#125; mRelinquished = true;//释放控制 mPm.installStage(mPackageName, stageDir, stageCid, localObserver, params, mInstallerPackageName, mInstallerUid, user, mCertificates); &#125; 首先是做一些检测，然后更新当前进度，之后调用extractNativeLibraries提取so文件到前面提过的临时目录，再然后构造观察者并传递给PKMS进行安装。 至此，会话的提交过程结束，PackageInstallerSession的用处也就到此为止了，接下来的过程会在PKMS中进行。 PKMS复制应用 接着上部分，来看下PKMS的installStage方法： 123456789101112 void installStage(String packageName, File stagedDir, String stagedCid, IPackageInstallObserver2 observer, PackageInstaller.SessionParams sessionParams, String installerPackageName, int installerUid, UserHandle user, Certificate[][] certificates) &#123;//…… final Message msg = mHandler.obtainMessage(INIT_COPY);//…… msg.obj = params; //…… mHandler.sendMessage(msg); &#125; 该方法大部分代码是在构造Message的obj对象，然后将message发送给消息循环进行处理。先来看下mHandler关联的looper是哪个，在PKMS的构造方法中找到mHandler的定义： mHandler = new PackageHandler(mHandlerThread.getLooper()); 再来看下mHandlerThread是什么： 12mHandlerThread = new ServiceThread(TAG, Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/); 再来看下ServiceThread的声明： 12345/** * Special handler thread that we create for system services that require their own loopers. */public class ServiceThread extends HandlerThread &#123;//……&#125; 从上面的注释可以知道，ServiceThread是专为需要自己的looper的系统服务创建的HandlerThread，比如说PKMS，应用安装是一种耗时操作，需要在子线程中进行，但是在安装的不同阶段有需要从外界获取信息，以提供不同的服务，所以就需要自己的消息循环。 言归正传，来看下上面发送的消息是什么含义，找到mHandler对INIT_COPY的处理： 12345678910111213141516171819202122232425262728293031323334353637case INIT_COPY: &#123; HandlerParams params = (HandlerParams) msg.obj; int idx = mPendingInstalls.size(); if (DEBUG_INSTALL) Slog.i(TAG, &quot;init_copy idx=&quot; + idx + &quot;: &quot; + params); // If a bind was already initiated we dont really // need to do anything. The pending install // will be processed later on. if (!mBound) &#123; Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;bindingMCS&quot;, System.identityHashCode(mHandler)); // If this is the only one pending we might // have to bind to the service again. if (!connectToService()) &#123; Slog.e(TAG, &quot;Failed to bind to media container service&quot;); params.serviceError(); Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, &quot;bindingMCS&quot;, System.identityHashCode(mHandler)); if (params.traceMethod != null) &#123; Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, params.traceMethod, params.traceCookie); &#125; return; &#125; else &#123; // Once we bind to the service, the first // pending request will be processed. mPendingInstalls.add(idx, params); &#125; &#125; else &#123; mPendingInstalls.add(idx, params); // Already bound to the service. Just make // sure we trigger off processing the first request. if (idx == 0) &#123; mHandler.sendEmptyMessage(MCS_BOUND); &#125; &#125; break; &#125; 上面的代码大致做了两件事：调用 connectToService方法绑定服务，然后将Message传递过来的params添加到mPendingInstalls中。来看下connectToService方法干了些什么： 1234567891011121314private boolean connectToService() &#123; if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;Trying to bind to&quot; + &quot; DefaultContainerService&quot;); Intent service = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT); Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT); if (mContext.bindServiceAsUser(service, mDefContainerConn, Context.BIND_AUTO_CREATE, UserHandle.SYSTEM)) &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); mBound = true; return true; &#125; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); return false;&#125; 主要就是绑定了下面这个component对应的服务，然后设定优先级： 12345static final String DEFAULT_CONTAINER_PACKAGE = &quot;com.android.defcontainer&quot;;static final ComponentName DEFAULT_CONTAINER_COMPONENT = new ComponentName( DEFAULT_CONTAINER_PACKAGE, &quot;com.android.defcontainer.DefaultContainerService&quot;); 来看下这是个什么服务，全局搜索com.android.defcontainer找到对应的AndroidManifest文件，进而找到该组件为frameworks&#x2F;base&#x2F;packages&#x2F;DefaultContainerService中的DefaultContainerService.java来看下这个类的注释： 123456/** * Service that offers to inspect and copy files that may reside on removable * storage. This is designed to prevent the system process from holding onto * open files that cause the kernel to kill it when the underlying device is * removed. */ 也就是说这个类是用来检测和copy可移除存储（从这里看应该也包括临时文件）的文件的。设计这个类的目的是防止持有这个文件的系统进程在存储设备被移除时被内核杀掉，好了，看来后面的copy操作这个类完成的，知道这么多就够了。 再来看下绑定服务时的ServiceConnection对象是怎么定义的，也就是说服务绑定后会发生什么： 1234567891011121314final private DefaultContainerConnection mDefContainerConn = new DefaultContainerConnection();class DefaultContainerConnection implements ServiceConnection &#123; public void onServiceConnected(ComponentName name, IBinder service) &#123; if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;onServiceConnected&quot;); final IMediaContainerService imcs = IMediaContainerService.Stub .asInterface(Binder.allowBlocking(service)); mHandler.sendMessage(mHandler.obtainMessage(MCS_BOUND, imcs)); &#125; public void onServiceDisconnected(ComponentName name) &#123; if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;onServiceDisconnected&quot;); &#125;&#125; 服务绑定后获得DefaultContainerService服务的本地对象，然后发送MCS_BOUND消息，该消息的obj为服务的对象imcs,该消息是在INIT_COPY消息之后放入消息队列的，所以该消息会在INIT_COPY处理完之后再进行处理，也就是说上面代码中的mPendingInstalls.add(idx, params);会在处理MCS_BOUND消息之前执行。 之后就是在MCS_BOUND消息的处理过程中调用HandlerParams的startCopy()方法开始apk以及lib文件的复制： 12345678910111213141516171819202122final boolean startCopy() &#123; boolean res; try &#123; if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy &quot; + mUser + &quot;: &quot; + this); if (++mRetries &gt; MAX_RETRIES) &#123; Slog.w(TAG, &quot;Failed to invoke remote methods on default container service. Giving up&quot;); mHandler.sendEmptyMessage(MCS_GIVE_UP); handleServiceError(); return false; &#125; else &#123; handleStartCopy(); res = true; &#125; &#125; catch (RemoteException e) &#123; if (DEBUG_INSTALL) Slog.i(TAG, &quot;Posting install MCS_RECONNECT&quot;); mHandler.sendEmptyMessage(MCS_RECONNECT); res = false; &#125; handleReturnCode(); return res;&#125; 从这些代码还看不出这里的copy到底是干吗的，再来看下handleStartCopy()方法的注释： 123456/* * Invoke remote method to get package information and install * location values. Override install location based on default * policy if needed and then create install arguments based * on the install location. */ 从上面的注释来看这里的copy是用来获取package信息和安装位置的信息的，如果有必要的话改变安装位置并根据安装位置创建安装参数。调试时发现并没有走copy的过程，结合DefaultContainerService的注释推测这部分的功能可能和SD的安装有关，handleStartCopy()会调用到FileInstallArgs 的copyApk()方法，最终借由DefaultContainerService完成apk的复制和重命名的过程，再借由NativeLibraryHelper完成native lib的复制。这部分代码量比较大，目前来看这部分对安装过程的理解帮助不大，所以暂时先不做了解了，目前只是推测可能和安装到sd卡有关系。复制完成后会发送MCS_UNBIND消息解除服务的绑定。 到此，PKMS对应用的复制操作告一段落，接下来进行真正的安装过程。 应用安装 上面了解了PKMS对apk的复制过程，在该过程结束后会返回安装成功与否（只是该阶段）的结果。上面还没有说这个结果是怎么处理的，这个结果是否成功关系着安装是否能继续下去，所以对结果的处理一就是下一步正式安装的开始。从上面的代码不难看出，该过程是在handleReturnCode()方法中进行的，该方法的实现在HandlerParams的子类InstallParams中： 123456789@Overridevoid handleReturnCode() &#123; // If mArgs is null, then MCS couldn&#x27;t be reached. When it // reconnects, it will try again to install. At that point, this // will succeed. if (mArgs != null) &#123; processPendingInstall(mArgs, mRet); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private void processPendingInstall(final InstallArgs args, final int currentStatus) &#123; // Queue up an async operation since the package installation may take a little while. mHandler.post(new Runnable() &#123; public void run() &#123; mHandler.removeCallbacks(this); // Result object to be returned PackageInstalledInfo res = new PackageInstalledInfo(); res.setReturnCode(currentStatus); res.uid = -1; res.pkg = null; res.removedInfo = null; if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123; args.doPreInstall(res.returnCode); synchronized (mInstallLock) &#123; installPackageTracedLI(args, res); &#125; args.doPostInstall(res.returnCode, res.uid); &#125; // A restore should be performed at this point if (a) the install // succeeded, (b) the operation is not an update, and (c) the new // package has not opted out of backup participation. final boolean update = res.removedInfo != null &amp;&amp; res.removedInfo.removedPackage != null; final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags; boolean doRestore = !update &amp;&amp; ((flags &amp; ApplicationInfo.FLAG_ALLOW_BACKUP) != 0); // Set up the post-install work request bookkeeping. This will be used // and cleaned up by the post-install event handling regardless of whether // there&#x27;s a restore pass performed. Token values are &gt;= 1. int token; if (mNextInstallToken &lt; 0) mNextInstallToken = 1; token = mNextInstallToken++; PostInstallData data = new PostInstallData(args, res); mRunningInstalls.put(token, data); if (DEBUG_INSTALL) Log.v(TAG, &quot;+ starting restore round-trip &quot; + token); if (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) &#123; // Pass responsibility to the Backup Manager. It will perform a // restore if appropriate, then pass responsibility back to the // Package Manager to run the post-install observer callbacks // and broadcasts. IBackupManager bm = IBackupManager.Stub.asInterface( ServiceManager.getService(Context.BACKUP_SERVICE)); if (bm != null) &#123; if (DEBUG_INSTALL) Log.v(TAG, &quot;token &quot; + token + &quot; to BM for possible restore&quot;); Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;restore&quot;, token); try &#123; // TODO: http://b/22388012 if (bm.isBackupServiceActive(UserHandle.USER_SYSTEM)) &#123; bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token); &#125; else &#123; doRestore = false; &#125; &#125; catch (RemoteException e) &#123; // can&#x27;t happen; the backup manager is local &#125; catch (Exception e) &#123; Slog.e(TAG, &quot;Exception trying to enqueue restore&quot;, e); doRestore = false; &#125; &#125; else &#123; Slog.e(TAG, &quot;Backup Manager not found!&quot;); doRestore = false; &#125; &#125; if (!doRestore) &#123; // No restore possible, or the Backup Manager was mysteriously not // available -- just fire the post-install work request directly. if (DEBUG_INSTALL) Log.v(TAG, &quot;No restore - queue post-install for &quot; + token); Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;postInstall&quot;, token); Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0); mHandler.sendMessage(msg); &#125; &#125; &#125;);&#125; 关键的地方有两个： installPackageTracedLI(args, res); POST_INSTALL消息 installPackageTracedLI进行应用的安装，而POST_INSTALL消息对应安装后的操作，比如发送广播告知其他角色进行相应的更新，例如launcher。 先来看下安装的过程： 12345678private void installPackageTracedLI(InstallArgs args, PackageInstalledInfo res) &#123; try &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;installPackage&quot;); installPackageLI(args, res); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125;&#125; 其中installPackageLI代码量较多就不全贴出来了，大致记录下这个方法做了些什么事： 确定scanFlags的值 包解析生成Package对象pkg = pp.parsePackage(tmpPackageFile, parseFlags); 更新pkg的信息，包括cpuAbiOverride，签名，证书，packageName，权限等内容，另外如果该应用已经存在，需要根据原有信息判断安装的apk是否与原apk兼容，包括包名以及是否是降级安装等，并将正在安装的应用包名改为和已有应用一致。 获取abi信息，更新sharedLibraries信息 12345678910111213141516171819202122232425262728if (args.move != null) &#123; //…… // We did an in-place move, so dex is ready to roll&#125; else if (!forwardLocked &amp;&amp; !pkg.applicationInfo.isExternalAsec()) &#123; // Enable SCAN_NO_DEX flag to skip dexopt at a later stage scanFlags |= SCAN_NO_DEX; try &#123; String abiOverride = (TextUtils.isEmpty(pkg.cpuAbiOverride) ? args.abiOverride : pkg.cpuAbiOverride); final boolean extractNativeLibs = !pkg.isLibrary(); derivePackageAbi(pkg, new File(pkg.codePath), abiOverride, extractNativeLibs, mAppLib32InstallDir); &#125; catch (PackageManagerException pme) &#123; Slog.e(TAG, &quot;Error deriving application ABI&quot;, pme); res.setError(INSTALL_FAILED_INTERNAL_ERROR, &quot;Error deriving application ABI&quot;); return; &#125; // Shared libraries for the package need to be updated. synchronized (mPackages) &#123; try &#123; updateSharedLibrariesLPr(pkg, null); &#125; catch (PackageManagerException e) &#123; Slog.e(TAG, &quot;updateAllSharedLibrariesLPw failed: &quot; + e.getMessage()); &#125; &#125;&#125; 应用文件夹重命名，并更新pkg中的相关信息 12345if (!args.doRename(res.returnCode, pkg, oldCodePath)) &#123; res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, &quot;Failed rename&quot;); return;&#125; 之后应用所在的文件夹更名为类似于“com.u17.comic.phone-u3tLbNr2Lkty3W30ltXxFQ&#x3D;&#x3D;”的形式，该目录仍位于&#x2F;data&#x2F;app&#x2F;下。 需要的话，进行odex优化 验证IntentFilterstartIntentFilterVerifications(args.user.getIdentifier(), replace, pkg); 杀掉对应应用（如果该应用存在），调用replacePackageLIF替换已有应用或者调用installNewPackageLIF安装新的应用。现在只关心新应用的安装： 1234567891011121314151617181920212223242526272829 private void installNewPackageLIF(PackageParser.Package pkg, final int policyFlags, int scanFlags, UserHandle user, String installerPackageName, String volumeUuid, PackageInstalledInfo res, int installReason) &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;installNewPackage&quot;); // Remember this for later, in case we need to rollback this install String pkgName = pkg.packageName;//检测是否是新应用，若不是则退出并保存错误信息 try &#123; PackageParser.Package newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags, System.currentTimeMillis(), user); updateSettingsLI(newPackage, installerPackageName, null, res, user, installReason); if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123; prepareAppDataAfterInstallLIF(newPackage); &#125; else &#123; // Remove package from internal structures, but keep around any // data that might have already existed deletePackageLIF(pkgName, UserHandle.ALL, false, null, PackageManager.DELETE_KEEP_DATA, res.removedInfo, true, null); &#125; &#125; catch (PackageManagerException e) &#123; res.setError(&quot;Package couldn&#x27;t be installed in &quot; + pkg.codePath, e); &#125; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; 关键的代码有三行： PackageParser.Package newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags, System.currentTimeMillis(), user);用来扫描pkg的信息，这部分在开机安装应用部分已经了解过了，主要就是更新PKMS中的PackageSetting等信息，并将包的信息添加到系统中，之后该包的信息就可以被查询和解析了。 updateSettingsLI(newPackage, installerPackageName, null, res, user, installReason);更新mSettings中的信息，并写入到packages.xml中，这样再次开机就可以直接从该文件读取应用信息。 prepareAppDataAfterInstallLIF(newPackage);准备应用的数据。 ​ 到这里installPackageTracedLI(args, res); 的工作就结束了，接下来要做的就是通知系统的其他角色应用已经安装完成，该工作是在对POST_INSTALL消息中进行处理的,为了节省控件就不贴这部分代码了，该消息的处理过程关键是调用handlePackagePostInstall方法。该方法的主要工作如下： 授予应用权限 12345678// Now that we successfully installed the package, grant runtime// permissions if requested before broadcasting the install. Also// for legacy apps in permission review mode we clear the permission// review flag which is used to emulate runtime permissions for// legacy apps.if (grantPermissions) &#123;//安装时带-g参数 grantRequestedRuntimePermissions(res.pkg, res.newUsers, grantedPermissions);&#125; 发送广播，其中包括ACTION_PACKAGE_ADDED和ACTION_PACKAGE_REPLACED等 调用installObserver的onPackageInstalled方法，installObserver是之前从InstallArgs中传递过来的，该回调中会发送ACTION_SESSION_COMMITTED广播，launcher会接受该广播，并更新应用的信息。 广播的处理涉及到Launcher和PackageInstall等应用，这里暂时不做了解了，等以后有机会再说～～～ adb安装应用大致过程： ​ adb命令解析 : cmd.cpp - PKMS - PackageManagerShellCommand ​ -&gt; 参数解析 ： InstallParams ​ -&gt; 创建session: PackageInstallerService - PackageInstallSession ​ -&gt; 应用复制到临时目录 ​ -&gt; 提交session： 更新进度，提取nativelib, 添加回调 ​ -&gt; 应用安装：文件夹重命名，添加&#x2F;更新应用信息到系统 ​ -&gt; 发送广播，调用回调，通知应用安装完成。","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"},{"name":"应用安装","slug":"Android/应用安装","permalink":"https://mouzishuo.github.io/categories/Android/%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"PKMS","slug":"PKMS","permalink":"https://mouzishuo.github.io/tags/PKMS/"},{"name":"PackageManagerService","slug":"PackageManagerService","permalink":"https://mouzishuo.github.io/tags/PackageManagerService/"},{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"}]},{"title":"Android “original-package” 机制解析","slug":"Android “original-package” 机制解析","date":"2018-07-26T09:13:55.000Z","updated":"2019-01-16T01:17:52.834Z","comments":true,"path":"2018/07/26/Android “original-package” 机制解析/","link":"","permalink":"https://mouzishuo.github.io/2018/07/26/Android%20%E2%80%9Coriginal-package%E2%80%9D%20%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Android “original-package” 机制解析原文：https://blog.csdn.net/hwy584624785/article/details/51774580 问题 之前项目上遇到一个问题：手机系统从版本 A 通过 FOTA 升级到版本 B 后，系统源码中的输入法（LatinIME.apk，下面称 LatinIME）不见了！也就是设置中语言和输入法选项没有 Android Keyboard 这一项，并且设置中的应用选项中也找不到。 问题情况 先了解了一下两个版本的情况：版本 A 是只有 LatinIME 的；版本 B 中除了 LatinIME 还新预制了 GMS 中的输入法（LatinImeGoogle.apk, 下面称 LatinImeGoogle）。升级后版本 B 的 LatinIME 输入法不见了，只剩下 LatinImeGoogle 输入法。 初步分析 分析的大概步骤如下： 首先确定升级后版本 LatinIME 虽然是看不见了，但 apk 包依然存在并且此情况是必现的，所以不可能是 FOTA 升级的某些意外导致的。 同时已经确定的情况： 直接 download B 版本，两个 App 是同时存在的。不管是 A 版本还是 B 版本通过 adb install 或 adb push 安装两个输入法应用，两个 App 都是同时存在的。通过 pm list package 命令查看 版本 A 信息如下 12package:/system/app/LatinImeGoogle.apk=com.google.android.inputmethod.latinpackage:/system/app/LatinIME.apk=com.android.inputmethod.latin 版本 B 的信息如下 1package:/system/app/LatinImeGoogle.apk=com.android.inputmethod.latin 版本 B 的输入法包名是变了的，而且是变成了 LatinIME 的包名了！ 反编译应用，在 LatinImeGoogle 的 manifest 文件中发现有 orignial-package 属性： 1&lt;original-package android:name=&quot;com.android.inputmethod.latin&quot; /&gt;1 看，与步骤 3 已经联系上了。所以这个属性应该就是问题所在。 接下来分析 original-package 属性。 源码中搜 original-package, PackageParser.java 中的 parsePackage() 方法对属性的处理： 123456789101112131415161718&#125; else if (tagName.equals(&quot;original-package&quot;)) &#123; sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestOriginalPackage); String orig =sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0); if (!pkg.packageName.equals(orig)) &#123; if (pkg.mOriginalPackages == null) &#123; pkg.mOriginalPackages = new ArrayList&lt;String&gt;(); pkg.mRealPackage = pkg.packageName; &#125; pkg.mOriginalPackages.add(orig); &#125; sa.recycle(); XmlUtils.skipCurrentTag(parser);&#125; 查 AndroidManifestOriginalPackage 的定义，在 attrs_manifest.xml 文件中： 123456789&lt;!-- Private tag to declare the original package name that this package is based on. Only used for packages installed in the system image. If given, and different than the actual package name, and the given original package was previously installed on the device but the new one was not, then the data for the old one will be renamed to be for the new package. &lt;p&gt;This appears as a child tag of the root &#123;@link #AndroidManifest manifest&#125; tag. --&gt;&lt;declare-styleable name=&quot;AndroidManifestOriginalPackage&quot; parent=&quot;AndroidManifest&quot;&gt; &lt;attr name=&quot;name&quot; /&gt;&lt;/declare-styleable&gt; 官方的解释很清楚了：之前安装的应用是系统应用，并且包名不同，之前应用的数据就会以新安装应用的名字保留下来。 这已经可以解释 LatinIME 消失的原因了。但是仅仅通过这个说明是不能完全解释步骤2中的现象的.为什么 adb push 和 adb install LatinImeGoogle 后的现象是两个应用并存呢？ 深入分析 original-package 机制 继续看源码。 上面 parsePackage() 方法中的 mOriginalPackages，查源码可知对 mOriginalPackages 的其余处理只在 PackageManagerServerice 中了。mOriginalPackages 在 PackageManagerService 中出现的次数并不多，但要搞清流程，简单有效的方法就是打 log。 打 log 这里有个小技巧。当时因为是 FOTA 升级上来的，总不可能添加一些 log 就去做一次升级抓 log 吧，很麻烦并且不能保证有用的 log 没有被冲刷掉。所以当时直接拿版本 B 的手机做 dumpsys 操作，查找有没有相关 package 信息。果然是有的： Package warning messages: 12341/1/14 12:08 AM: No settings file; creating initial state1/1/14 12:06 AM: New package com.google.android.inputmethod.latin renamed to replace old package com.android.inputmethod.latin1/1/14 12:47 AM: System package com.android.inputmethod.latin signature changed; retaining data.1/1/14 12:51 AM: System package com.android.inputmethod.latin signature changed; retaining data. 对应源码 scanPackageLI(pkg,…) 的代码： 1234// File a report about this.String msg = &quot;New package &quot; + pkgSetting.realName + &quot; renamed to replace old package &quot; + pkgSetting.name;reportSettingsProblem(Log.WARN, msg); reportSettingsProblem() 方法是既可以在 dumpsys 又可以在 logcat 中打印出来的，用此方法添加 log 发现 FOTA 升级上来走的流程是 if (pkg.mOriginalPackages.contains(renamed)) ,而 adb install 和 adb push 走的流程是它的 else 流程，是因为 renamed 为空，也就是 mSettings.mRenamedPackages 不包含 com.google.android.inputmethod.latin 。mRenamedPackages 的值添加是在 Settings.java (&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;pm&#x2F;Settings.java) 中，最终处理（具体调用过程不写了）在两个地方：上面提到的 if 语句下面调用的 getPackageLPw() 方法，这个显然不是原因。另一个是在 PackageManagerService 的构造函数调用 readLPw() 方法处理。我们知道 PackageManagerService 是 SystemServer 调用启动，SystemServer 又是 Zygote 启动，这就是原因：采用adb push 和 adb install时在PKMS的构造函数中会先清除已经不存在的应用，然后再扫描该应用 ，所以这样安装应用 “original-package” 机制是不起作用的，FOTA 当然是会走构造函数的，所以“original-package” 机制是有效的。到此问题已经解决，更详细的内容可以查看 PackageManagerService 源码。 总结 Android 的 “original-package” 运行机制： 之前已安装的应用是系统应用，并且新安装的应用与之前包名不同，那么定义有 original-package 属性的新应用就可以在走 PackageManagerService 构造函数的流程下（例如 FOTA 升级）实现应用替换，保持原有应用数据不变，但是以新安装应用的形式展现给用户。查看源码 &#x2F;packages&#x2F;apps&#x2F; 下的应用，会发现很多都有此属性，就是为了以后升级时应用数据共享。这一属性从 Android 的 Froyo 版本就有，可以看出主要是针对 Google 自己和 ROM 厂商而设置的，一般的开发者使用不到。 Android O PKMS中关于origin-package中的处理： scanPackageDirtyLI: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Check if we are renaming from an original package name. PackageSetting origPackage = null; String realName = null; if (pkg.mOriginalPackages != null) &#123; // This package may need to be renamed to a previously // installed name. Let&#x27;s check on that... final String renamed = mSettings.getRenamedPackageLPr(pkg.mRealPackage); if (pkg.mOriginalPackages.contains(renamed)) &#123; // This package had originally been installed as the // original name, and we have already taken care of // transitioning to the new one. Just update the new // one to continue using the old name. realName = pkg.mRealPackage; if (!pkg.packageName.equals(renamed)) &#123; // Callers into this function may have already taken // care of renaming the package; only do it here if // it is not already done. pkg.setPackageName(renamed); &#125; &#125; else &#123; for (int i=pkg.mOriginalPackages.size()-1; i&gt;=0; i--) &#123; if ((origPackage = mSettings.getPackageLPr( pkg.mOriginalPackages.get(i))) != null) &#123; // We do have the package already installed under its // original name... should we use it? if (!verifyPackageUpdateLPr(origPackage, pkg)) &#123; // New package is not compatible with original. origPackage = null; continue; &#125; else if (origPackage.sharedUser != null) &#123; // Make sure uid is compatible between packages. if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) &#123; Slog.w(TAG, &quot;Unable to migrate data from &quot; + origPackage.name + &quot; to &quot; + pkg.packageName + &quot;: old uid &quot; + origPackage.sharedUser.name + &quot; differs from &quot; + pkg.mSharedUserId); origPackage = null; continue; &#125; // TODO: Add case when shared user id is added [b/28144775] &#125; else &#123; if (DEBUG_UPGRADE) Log.v(TAG, &quot;Renaming new package &quot; + pkg.packageName + &quot; to old name &quot; + origPackage.name); &#125; break; &#125; &#125; &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"},{"name":"OTA","slug":"Android/OTA","permalink":"https://mouzishuo.github.io/categories/Android/OTA/"}],"tags":[{"name":"PKMS","slug":"PKMS","permalink":"https://mouzishuo.github.io/tags/PKMS/"},{"name":"PackageManagerService","slug":"PackageManagerService","permalink":"https://mouzishuo.github.io/tags/PackageManagerService/"},{"name":"original-package","slug":"original-package","permalink":"https://mouzishuo.github.io/tags/original-package/"},{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"}]},{"title":"应用安装-开机安装应用","slug":"应用安装-开机安装应用","date":"2018-07-22T07:25:08.000Z","updated":"2019-01-18T03:09:04.720Z","comments":true,"path":"2018/07/22/应用安装-开机安装应用/","link":"","permalink":"https://mouzishuo.github.io/2018/07/22/%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85-%E5%BC%80%E6%9C%BA%E5%AE%89%E8%A3%85%E5%BA%94%E7%94%A8/","excerpt":"","text":"一、应用安装类型1. 安装方式： 安装系统APK和预制APK时，通过PMS的构造函数中安装，即第一次开机时安装应用，没有安装界面。 网络下载安装，通过应用商店等，即调用PackageManager.installPackage()，有安装界面。 通过adb工具安装，没有安装界面，它通过启动pm脚本的形式，然后调用com.android.commands.pm.Pm类，之后调用到PMS.installStage()完成安装。 安装本地apk，有安装界面，由PackageInstaller系统应用安装。上述几种方式均通过PackageInstallObserver来监听安装是否成功。 2. 涉及到的路径应用安装涉及到如下几个目录： &#x2F;system&#x2F;app：系统自带的应用程序，获得adb root权限才能删除 data&#x2F;app —————用户程序安装的目录。安装时把apk文件复制到此目录 data&#x2F;data —————存放应用程序的数据 data&#x2F;dalvik-cache——–将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一) 安装过程中复制APK安装包到data&#x2F;app目录下，解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录，并data&#x2F;data目录下创建对应的应用数据目录。 卸载时删除安装过程中在上述几个目录下创建的文件及目录。 以上内容参考https://www.cnblogs.com/meizixiong/p/3551891.html。 二、安装过程https://www.cnblogs.com/z1987/p/8974719.html提供了四种安装方式的时序图。 https://www.jianshu.com/p/4f16421d5c7f系统讲解了PKMS。 首次开机安装该过程在PKMS的构造方法中进行，主要的工作是解析预置app的相关信息，写入到&#x2F;data&#x2F;system&#x2F;packages.xml中，并处理应用的数据。之后开机的扫描过程用于处理应用发生改变的情况，比如通过adb改变包，ota升级改变apk等。 首先是设置scanFlags: 1234int scanFlags = SCAN_BOOTING | SCAN_INITIAL;if (mIsUpgrade || mFirstBoot) &#123; scanFlags = scanFlags | SCAN_FIRST_BOOT_OR_UPGRADE;&#125; 收集系统目录下的app，包括以下几个目录： &#x2F;vendor&#x2F;overlay&#x2F;system&#x2F;framework&#x2F;system&#x2F;priv-app&#x2F;system&#x2F;app&#x2F;vendor&#x2F;priv-app&#x2F;vendor&#x2F;app&#x2F;oem&#x2F;app 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 // Collect vendor overlay packages. (Do this before scanning any apps.) // For security and version matching reason, only consider // overlay packages if they reside in the right directory. scanDirTracedLI(new File(VENDOR_OVERLAY_DIR), mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_TRUSTED_OVERLAY, scanFlags | SCAN_TRUSTED_OVERLAY, 0);//记录AndroidManifest文件的android:isStatic为true的package mParallelPackageParserCallback.findStaticOverlayPackages(); // Find base frameworks (resource packages without code). scanDirTracedLI(frameworkDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags | SCAN_NO_DEX, 0); // Collected privileged system packages. final File privilegedAppDir = new File(Environment.getRootDirectory(), &quot;priv-app&quot;); scanDirTracedLI(privilegedAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0); // Collect ordinary system packages. final File systemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;); scanDirTracedLI(systemAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all vendor packages. File vendorAppDir = new File(&quot;/vendor/app&quot;); try &#123; vendorAppDir = vendorAppDir.getCanonicalFile(); &#125; catch (IOException e) &#123; // failed to look up canonical path, continue with original one &#125; scanDirTracedLI(vendorAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all OEM packages. final File oemAppDir = new File(Environment.getOemDirectory(), &quot;app&quot;); scanDirTracedLI(oemAppDir, mDefParseFlags | PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); 几个目录下的扫描过程类似，&#x2F;vendor&#x2F;overay比较特殊，该目录下的app用于进行运行时资源替换（RRO）。该部分扫描只会处理framework-res.apk之外apk的rro，因为framework-res.apk比较特殊，必须在系统启动的时候就进行处理，该过程在native层进行，这里不做了解。&#x2F;vendor&#x2F;overay下的app扫描完之后，相比其他目录多了 mParallelPackageParserCallback.findStaticOverlayPackages();的操作，用于找出rro中的staticOverlay，staticOverlay是在Android O中才出现的，非static的overlay默认是disable的，但是可以在adb中进行enable，具体可以了解OverlayManagerService及其他资源管理相关内容。 ​ scanDirTracedLI的实现如下： 12345678private void scanDirTracedLI(File dir, final int parseFlags, int scanFlags, long currentTime) &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;scanDir [&quot; + dir.getAbsolutePath() + &quot;]&quot;); try &#123; scanDirLI(dir, parseFlags, scanFlags, currentTime); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) &#123; final File[] files = dir.listFiles(); if (ArrayUtils.isEmpty(files)) &#123; Log.d(TAG, &quot;No files in app dir &quot; + dir); return; &#125; if (DEBUG_PACKAGE_SCANNING) &#123; Log.d(TAG, &quot;Scanning app dir &quot; + dir + &quot; scanFlags=&quot; + scanFlags + &quot; flags=0x&quot; + Integer.toHexString(parseFlags)); &#125; ParallelPackageParser parallelPackageParser = new ParallelPackageParser( mSeparateProcesses, mOnlyCore, mMetrics, mCacheDir, mParallelPackageParserCallback); // Submit files for parsing in parallel int fileCount = 0; for (File file : files) &#123; final boolean isPackage = (isApkFile(file) || file.isDirectory()) &amp;&amp; !PackageInstallerService.isStageName(file.getName()); if (!isPackage) &#123; // Ignore entries which are not packages continue; &#125; parallelPackageParser.submit(file, parseFlags); fileCount++; &#125; // Process results one by one for (; fileCount &gt; 0; fileCount--) &#123; ParallelPackageParser.ParseResult parseResult = parallelPackageParser.take(); Throwable throwable = parseResult.throwable; int errorCode = PackageManager.INSTALL_SUCCEEDED; if (throwable == null) &#123; // Static shared libraries have synthetic package names if (parseResult.pkg.applicationInfo.isStaticSharedLibrary()) &#123; renameStaticSharedLibraryPackage(parseResult.pkg); &#125; try &#123; if (errorCode == PackageManager.INSTALL_SUCCEEDED) &#123; scanPackageLI(parseResult.pkg, parseResult.scanFile, parseFlags, scanFlags, currentTime, null); &#125; &#125; catch (PackageManagerException e) &#123; errorCode = e.error; Slog.w(TAG, &quot;Failed to scan &quot; + parseResult.scanFile + &quot;: &quot; + e.getMessage()); &#125; &#125; else if (throwable instanceof PackageParser.PackageParserException) &#123; PackageParser.PackageParserException e = (PackageParser.PackageParserException) throwable; errorCode = e.error; Slog.w(TAG, &quot;Failed to parse &quot; + parseResult.scanFile + &quot;: &quot; + e.getMessage()); &#125; else &#123; throw new IllegalStateException(&quot;Unexpected exception occurred while parsing &quot; + parseResult.scanFile, throwable); &#125; // Delete invalid userdata apps if ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp; errorCode == PackageManager.INSTALL_FAILED_INVALID_APK) &#123; logCriticalInfo(Log.WARN, &quot;Deleting invalid package at &quot; + parseResult.scanFile); removeCodePathLI(parseResult.scanFile); &#125; &#125; parallelPackageParser.close(); &#125; scanDirTracedLI调用了scanDirLI方法,该方法的逻辑很简单，扫描&#x2F;vendor&#x2F;overlay目录下的所有文件，将apk文件和文件夹提交给ParallelPackageParser进行解析，ParallelPackageParser中采用了线程池和BlockingQueue进行并发的解析，解析类为PackageParser，主要是解析app的AndroidManifest.xml文件&#x2F;解析结果放到BlockingQueue中，再通过take方法取出，关于ParallelPackageParser会另行总结，现在先关心主线 。解析正常的话，将结果传递给scanPackageLI方法进行进一步处理。 1234567891011121314151617181920212223242526272829303132333435private PackageParser.Package scanPackageLI(PackageParser.Package pkg, File scanFile, final int policyFlags, int scanFlags, long currentTime, @Nullable UserHandle user) throws PackageManagerException &#123; // If the package has children and this is the first dive in the function // we scan the package with the SCAN_CHECK_ONLY flag set to see whether all // packages (parent and children) would be successfully scanned before the // actual scan since scanning mutates internal state and we want to atomically // install the package and its children. if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123; if (pkg.childPackages != null &amp;&amp; pkg.childPackages.size() &gt; 0) &#123; scanFlags |= SCAN_CHECK_ONLY; &#125; &#125; else &#123; scanFlags &amp;= ~SCAN_CHECK_ONLY; &#125; // Scan the parent PackageParser.Package scannedPkg = scanPackageInternalLI(pkg, scanFile, policyFlags, scanFlags, currentTime, user); // Scan the children final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPackage = pkg.childPackages.get(i); scanPackageInternalLI(childPackage, scanFile, policyFlags, scanFlags, currentTime, user); &#125; if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123; return scanPackageLI(pkg, scanFile, policyFlags, scanFlags, currentTime, user); &#125; return scannedPkg; &#125; 这里有个问题，既然已经解析出了Package信息，为什么还要对得到的Package对象再次进行解析呢？这里主要是为了处理应用升级的情况。 关于children package还不清楚是什么，这里先不去了解，还是先关心主线再说。除去children package相关的内容，其实这个方法里只有一行关键代码： 12PackageParser.Package scannedPkg = scanPackageInternalLI(pkg, scanFile, policyFlags, scanFlags, currentTime, user); scanPackageInternalLI方法很长，里面包含很多和升级相关的代码，这里暂时只了解应用的安装过程，应用升级以后再做了解。 12PackageParser.Package scannedPkg = scanPackageLI(pkg, policyFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user); scanPackageLI方法中调用了scanPackageLI方法来实现package的扫描： 123456789101112131415private PackageParser.Package scanPackageLI(PackageParser.Package pkg, final int policyFlags, int scanFlags, long currentTime, @Nullable UserHandle user) throws PackageManagerException &#123; boolean success = false; try &#123; final PackageParser.Package res = scanPackageDirtyLI(pkg, policyFlags, scanFlags, currentTime, user); success = true; return res; &#125; finally &#123; if (!success &amp;&amp; (scanFlags &amp; SCAN_DELETE_DATA_ON_FAILURES) != 0) &#123; // DELETE_DATA_ON_FAILURES is only used by frozen paths //…… &#125;&#125; scanPackageDirtyLI的代码太多，一部分一部分的来看。 applyPolicy applyPolicy(pkg, policyFlags);该方法根据发起扫描时传递的parseFlags设置Package对象中的一些属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Applies policy to the parsed package based upon the given policy flags. * Ensures the package is in a good state. * &lt;p&gt; * Implementation detail: This method must NOT have any side effect. It would * ideally be static, but, it requires locks to read system state. */private void applyPolicy(PackageParser.Package pkg, int policyFlags) &#123; if ((policyFlags&amp;PackageParser.PARSE_IS_SYSTEM) != 0) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM; if (pkg.applicationInfo.isDirectBootAware()) &#123;//加密时不输入密码即可访问 // we&#x27;re direct boot aware; set for all components for (PackageParser.Service s : pkg.services) &#123; s.info.encryptionAware = s.info.directBootAware = true; &#125; for (PackageParser.Provider p : pkg.providers) &#123; p.info.encryptionAware = p.info.directBootAware = true; &#125; for (PackageParser.Activity a : pkg.activities) &#123; a.info.encryptionAware = a.info.directBootAware = true; &#125; for (PackageParser.Activity r : pkg.receivers) &#123; r.info.encryptionAware = r.info.directBootAware = true; &#125; &#125; if (compressedFileExists(pkg.codePath)) &#123; pkg.isStub = true; &#125; &#125; else &#123; // Only allow system apps to be flagged as core apps. pkg.coreApp = false;//也就是说不是systemapp设置了coreApp的属性也是没用的 // clear flags not applicable to regular apps pkg.applicationInfo.privateFlags &amp;= ~ApplicationInfo.PRIVATE_FLAG_DEFAULT_TO_DEVICE_PROTECTED_STORAGE; pkg.applicationInfo.privateFlags &amp;= ~ApplicationInfo.PRIVATE_FLAG_DIRECT_BOOT_AWARE; &#125; //表示/vendor/overlay下的app pkg.mTrustedOverlay = (policyFlags&amp;PackageParser.PARSE_TRUSTED_OVERLAY) != 0; if ((policyFlags&amp;PackageParser.PARSE_IS_PRIVILEGED) != 0) &#123; pkg.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED; &#125; if (!isSystemApp(pkg)) &#123; // Only system apps can use these features. pkg.mOriginalPackages = null;//关于origin-package可以参考另一个 pkg.mRealPackage = null; pkg.mAdoptPermissions = null; &#125;&#125; assertPackageIsValid assertPackageIsValid(pkg, policyFlags, scanFlags);验证pkg是否有效，如返回PackageManagerException异常会被scanDirLI方法捕获。该方法中进行了包名重复apk的检验、StaticSharedLibrary相关检验、child package检验、路径检测和content provider冲突检测等工作，逻辑比较简单但是代码比较多，就不贴出来了，需要的时候去看下代码就好。 变量初始化 1234567891011121314151617// Initialize package source and resource directoriesfinal File scanFile = new File(pkg.codePath);final File destCodeFile = new File(pkg.applicationInfo.getCodePath());final File destResourceFile = new File(pkg.applicationInfo.getResourcePath());SharedUserSetting suid = null;PackageSetting pkgSetting = null;// Getting the package setting may have a side-effect, so if we// are only checking if scan would succeed, stash a copy of the// old setting to restore at the end.PackageSetting nonMutatedPs = null;// We keep references to the derived CPU Abis from settings in oder to reuse// them in the case where we&#x27;re not upgrading or booting for the first time.String primaryCpuAbiFromSettings = null;String secondaryCpuAbiFromSettings = null; **之后的代码会锁mPackages.**该部分代码的分析直接添加在注释中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216 synchronized (mPackages) &#123; if (pkg.mSharedUserId != null) &#123; // SIDE EFFECTS; may potentially allocate a new shared user // 根据pkg中信息生成新的uid，不存在则创建一个 suid = mSettings.getSharedUserLPw( pkg.mSharedUserId, 0 /*pkgFlags*/, 0 /*pkgPrivateFlags*/, true /*create*/); &#125; // ……origin-package相关内容，该部分摘出去，单独了解 // See comments in nonMutatedPs declaration if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123; PackageSetting foundPs = mSettings.getPackageLPr(pkg.packageName); if (foundPs != null) &#123; nonMutatedPs = new PackageSetting(foundPs); &#125; &#125; // 如不是第一次启动或者升级，则直接从Settings中读取ABI信息 if ((scanFlags &amp; SCAN_FIRST_BOOT_OR_UPGRADE) == 0) &#123; PackageSetting foundPs = mSettings.getPackageLPr(pkg.packageName); if (foundPs != null) &#123; primaryCpuAbiFromSettings = foundPs.primaryCpuAbiString; secondaryCpuAbiFromSettings = foundPs.secondaryCpuAbiString; &#125; &#125; pkgSetting = mSettings.getPackageLPr(pkg.packageName); // pkg新扫描生成的uid和原本保存的不一致 if (pkgSetting != null &amp;&amp; pkgSetting.sharedUser != suid) &#123; //打印关键信息ｌｏｇ PackageManagerService.reportSettingsProblem(Log.WARN, &quot;Package &quot; + pkg.packageName + &quot; shared user changed from &quot; + (pkgSetting.sharedUser != null ? pkgSetting.sharedUser.name : &quot;&lt;nothing&gt;&quot;) + &quot; to &quot; + (suid != null ? suid.name : &quot;&lt;nothing&gt;&quot;) + &quot;; replacing with new&quot;); pkgSetting = null;//需要更新PackageSetting信息 &#125; //更新PackageSetting信息｛｛ final PackageSetting oldPkgSetting = pkgSetting == null ? null : new PackageSetting(pkgSetting); final PackageSetting disabledPkgSetting = mSettings.getDisabledSystemPkgLPr(pkg.packageName); String[] usesStaticLibraries = null; if (pkg.usesStaticLibraries != null) &#123; usesStaticLibraries = new String[pkg.usesStaticLibraries.size()]; pkg.usesStaticLibraries.toArray(usesStaticLibraries); &#125; //package的信息不存在（第一次扫描到该应用）或者uid发生改变 if (pkgSetting == null) &#123; final String parentPackageName = (pkg.parentPackage != null) ? pkg.parentPackage.packageName : null; final boolean instantApp = (scanFlags &amp; SCAN_AS_INSTANT_APP) != 0; final boolean virtualPreload = (scanFlags &amp; SCAN_AS_VIRTUAL_PRELOAD) != 0; // REMOVE SharedUserSetting from method; update in a separate call pkgSetting = Settings.createNewSetting(pkg.packageName, origPackage, disabledPkgSetting, realName, suid, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryRootDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.mVersionCode, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, user, true /*allowInstall*/, instantApp, virtualPreload, parentPackageName, pkg.getChildPackageNames(), UserManagerService.getInstance(), usesStaticLibraries, pkg.usesStaticLibrariesVersions); // SIDE EFFECTS; updates system state; move elsewhere if (origPackage != null) &#123; mSettings.addRenamedPackageLPw(pkg.packageName, origPackage.name); &#125; mSettings.addUserToSettingLPw(pkgSetting); &#125; else &#123; // REMOVE SharedUserSetting from method; update in a separate call. // // TODO(narayan): This update is bogus. nativeLibraryDir &amp; primaryCpuAbi, // secondaryCpuAbi are not known at this point so we always update them // to null here, only to reset them at a later point. Settings.updatePackageSetting(pkgSetting, disabledPkgSetting, suid, destCodeFile, pkg.applicationInfo.nativeLibraryDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, pkg.getChildPackageNames(), UserManagerService.getInstance(), usesStaticLibraries, pkg.usesStaticLibrariesVersions); &#125; // SIDE EFFECTS; persists system state to files on disk; move elsewhere // 写入信息到/data/system/users/下的文件 mSettings.writeUserRestrictionsLPw(pkgSetting, oldPkgSetting); //更新PackageSetting信息｝｝ // SIDE EFFECTS; modifies system state; move elsewhere if (pkgSetting.origPackage != null) &#123; pkg.setPackageName(origPackage.name); // File a report about this. String msg = &quot;New package &quot; + pkgSetting.realName + &quot; renamed to replace old package &quot; + pkgSetting.name; reportSettingsProblem(Log.WARN, msg); // Make a note of it. if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123; mTransferedPackages.add(origPackage.name); &#125; // No longer need to retain this. pkgSetting.origPackage = null; &#125; // SIDE EFFECTS; modifies system state; move elsewhere if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0 &amp;&amp; realName != null) &#123; // Make a note of it. mTransferedPackages.add(pkg.packageName); &#125; if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP; &#125; if ((scanFlags &amp; SCAN_BOOTING) == 0 &amp;&amp; (policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; // Check all shared libraries and map to their actual file path. // We only do this here for apps not on a system dir, because those // are the only ones that can fail an install due to this. We // will take care of the system apps by updating all of their // library paths after the scan is done. Also during the initial // scan don&#x27;t update any libs as we do this wholesale after all // apps are scanned to avoid dependency based scanning. updateSharedLibrariesLPr(pkg, null); &#125; if (mFoundPolicyFile) &#123; SELinuxMMAC.assignSeInfoValue(pkg); &#125; pkg.applicationInfo.uid = pkgSetting.appId; pkg.mExtras = pkgSetting; //获取签名信息（代码细节未了解）ＢＥＧＩＮ // Static shared libs have same package with different versions where // we internally use a synthetic package name to allow multiple versions // of the same package, therefore we need to compare signatures against // the package setting for the latest library version. PackageSetting signatureCheckPs = pkgSetting; if (pkg.applicationInfo.isStaticSharedLibrary()) &#123; SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg); if (libraryEntry != null) &#123; signatureCheckPs = mSettings.getPackageLPr(libraryEntry.apk); &#125; &#125; if (shouldCheckUpgradeKeySetLP(signatureCheckPs, scanFlags)) &#123; if (checkUpgradeKeySetLP(signatureCheckPs, pkg)) &#123; // We just determined the app is signed correctly, so bring // over the latest parsed certs. pkgSetting.signatures.mSignatures = pkg.mSignatures; &#125; else &#123; if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, &quot;Package &quot; + pkg.packageName + &quot; upgrade keys do not match the &quot; + &quot;previously installed version&quot;); &#125; else &#123; pkgSetting.signatures.mSignatures = pkg.mSignatures; String msg = &quot;System package &quot; + pkg.packageName + &quot; signature changed; retaining data.&quot;; reportSettingsProblem(Log.WARN, msg); &#125; &#125; &#125; else &#123; try &#123; // SIDE EFFECTS; compareSignaturesCompat() changes KeysetManagerService verifySignaturesLP(signatureCheckPs, pkg); // We just determined the app is signed correctly, so bring // over the latest parsed certs. pkgSetting.signatures.mSignatures = pkg.mSignatures; &#125; catch (PackageManagerException e) &#123; if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123; throw e; &#125; // The signature has changed, but this package is in the system // image... let&#x27;s recover! pkgSetting.signatures.mSignatures = pkg.mSignatures; // However... if this package is part of a shared user, but it // doesn&#x27;t match the signature of the shared user, let&#x27;s fail. // What this means is that you can&#x27;t change the signatures // associated with an overall shared user, which doesn&#x27;t seem all // that unreasonable. if (signatureCheckPs.sharedUser != null) &#123; if (compareSignatures(signatureCheckPs.sharedUser.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) &#123; throw new PackageManagerException( INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES, &quot;Signature mismatch for shared user: &quot; + pkgSetting.sharedUser); &#125; &#125; // File a report about this. String msg = &quot;System package &quot; + pkg.packageName + &quot; signature changed; retaining data.&quot;; reportSettingsProblem(Log.WARN, msg); &#125; &#125; //获取签名信息END //更新权限的所有者，更新mSettings中的权限信息 if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0 &amp;&amp; pkg.mAdoptPermissions != null) &#123; // This package wants to adopt ownership of permissions from // another package. for (int i = pkg.mAdoptPermissions.size() - 1; i &gt;= 0; i--) &#123; final String origName = pkg.mAdoptPermissions.get(i); final PackageSetting orig = mSettings.getPackageLPr(origName); if (orig != null) &#123; if (verifyPackageUpdateLPr(orig, pkg)) &#123; Slog.i(TAG, &quot;Adopting permissions from &quot; + origName + &quot; to &quot; + pkg.packageName); // SIDE EFFECTS; updates permissions system state; move elsewhere mSettings.transferPermissionsLPw(origName, pkg.packageName); &#125; &#125; &#125; &#125;&#125; 总结一下加锁的代码里做了哪些事：更新uid、origin-package处理、ABI初始值、更新或者生成新的PackageSetting对象、处理签名信息、权限继承。 Package中ApplicationInfo对象属性设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121pkg.applicationInfo.processName = fixProcessName( pkg.applicationInfo.packageName, pkg.applicationInfo.processName);if (pkg != mPlatformPackage) &#123; // Get all of our default paths setup pkg.applicationInfo.initForUser(UserHandle.USER_SYSTEM);&#125;final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);if ((scanFlags &amp; SCAN_NEW_INSTALL) == 0) &#123; if ((scanFlags &amp; SCAN_FIRST_BOOT_OR_UPGRADE) != 0) &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;derivePackageAbi&quot;); final boolean extractNativeLibs = !pkg.isLibrary(); derivePackageAbi(pkg, scanFile, cpuAbiOverride, extractNativeLibs, mAppLib32InstallDir); Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); // Some system apps still use directory structure for native libraries // in which case we might end up not detecting abi solely based on apk // structure. Try to detect abi based on directory structure. if (isSystemApp(pkg) &amp;&amp; !pkg.isUpdatedSystemApp() &amp;&amp; pkg.applicationInfo.primaryCpuAbi == null) &#123; setBundledAppAbisAndRoots(pkg, pkgSetting); setNativeLibraryPaths(pkg, mAppLib32InstallDir); &#125; &#125; else &#123; // This is not a first boot or an upgrade, don&#x27;t bother deriving the // ABI during the scan. Instead, trust the value that was stored in the // package setting. pkg.applicationInfo.primaryCpuAbi = primaryCpuAbiFromSettings; pkg.applicationInfo.secondaryCpuAbi = secondaryCpuAbiFromSettings; setNativeLibraryPaths(pkg, mAppLib32InstallDir); if (DEBUG_ABI_SELECTION) &#123; Slog.i(TAG, &quot;Using ABIS and native lib paths from settings : &quot; + pkg.packageName + &quot; &quot; + pkg.applicationInfo.primaryCpuAbi + &quot;, &quot; + pkg.applicationInfo.secondaryCpuAbi); &#125; &#125;&#125; else &#123; if ((scanFlags &amp; SCAN_MOVE) != 0) &#123; // We haven&#x27;t run dex-opt for this move (since we&#x27;ve moved the compiled output too) // but we already have this packages package info in the PackageSetting. We just // use that and derive the native library path based on the new codepath. pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString; pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString; &#125; // Set native library paths again. For moves, the path will be updated based on the // ABIs we&#x27;ve determined above. For non-moves, the path will be updated based on the // ABIs we determined during compilation, but the path will depend on the final // package path (after the rename away from the stage path). setNativeLibraryPaths(pkg, mAppLib32InstallDir);&#125;// This is a special case for the &quot;system&quot; package, where the ABI is// dictated by the zygote configuration (and init.rc). We should keep track// of this ABI so that we can deal with &quot;normal&quot; applications that run under// the same UID correctly.if (mPlatformPackage == pkg) &#123; pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];&#125;// If there&#x27;s a mismatch between the abi-override in the package setting// and the abiOverride specified for the install. Warn about this because we// would&#x27;ve already compiled the app without taking the package setting into// account.if ((scanFlags &amp; SCAN_NO_DEX) == 0 &amp;&amp; (scanFlags &amp; SCAN_NEW_INSTALL) != 0) &#123; if (cpuAbiOverride == null &amp;&amp; pkgSetting.cpuAbiOverrideString != null) &#123; Slog.w(TAG, &quot;Ignoring persisted ABI override &quot; + cpuAbiOverride + &quot; for package &quot; + pkg.packageName); &#125;&#125;pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;pkgSetting.cpuAbiOverrideString = cpuAbiOverride;// Copy the derived override back to the parsed package, so that we can// update the package settings accordingly.pkg.cpuAbiOverride = cpuAbiOverride;if (DEBUG_ABI_SELECTION) &#123; Slog.d(TAG, &quot;Resolved nativeLibraryRoot for &quot; + pkg.applicationInfo.packageName + &quot; to root=&quot; + pkg.applicationInfo.nativeLibraryRootDir + &quot;, isa=&quot; + pkg.applicationInfo.nativeLibraryRootRequiresIsa);&#125;// Push the derived path down into PackageSettings so we know what to// clean up at uninstall time.pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;if (DEBUG_ABI_SELECTION) &#123; Log.d(TAG, &quot;Abis for package[&quot; + pkg.packageName + &quot;] are&quot; + &quot; primary=&quot; + pkg.applicationInfo.primaryCpuAbi + &quot; secondary=&quot; + pkg.applicationInfo.secondaryCpuAbi);&#125;// SIDE EFFECTS; removes DEX files from disk; move elsewhereif ((scanFlags &amp; SCAN_BOOTING) == 0 &amp;&amp; pkgSetting.sharedUser != null) &#123; // We don&#x27;t do this here during boot because we can do it all // at once after scanning all existing packages. // // We also do this *before* we perform dexopt on this package, so that // we can avoid redundant dexopts, and also to make sure we&#x27;ve got the // code and package path correct. adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg);&#125;if (mFactoryTest &amp;&amp; pkg.requestedPermissions.contains( android.Manifest.permission.FACTORY_TEST)) &#123; pkg.applicationInfo.flags |= ApplicationInfo.FLAG_FACTORY_TEST;&#125;if (isSystemApp(pkg)) &#123; pkgSetting.isOrphaned = true;&#125; 首先是设置ApplicationInfo中的进程名，然后调用ApplicationInfo#initForUser初始化System用户(0)下的应用相关路径： 1234567891011121314151617181920212223/** &#123;@hide&#125; */public void initForUser(int userId) &#123; uid = UserHandle.getUid(userId, UserHandle.getAppId(uid)); if (&quot;android&quot;.equals(packageName)) &#123;//路径：/data/system/ dataDir = Environment.getDataSystemDirectory().getAbsolutePath(); return; &#125; deviceProtectedDataDir = Environment .getDataUserDePackageDirectory(volumeUuid, userId, packageName) .getAbsolutePath();// 路径：/data/user_de/0(或其他用户id，比如1000)/packageName credentialProtectedDataDir = Environment .getDataUserCePackageDirectory(volumeUuid, userId, packageName) .getAbsolutePath();//路径：/data/user/0(或其他用户id，比如1000)/packageName if ((privateFlags &amp; PRIVATE_FLAG_DEFAULT_TO_DEVICE_PROTECTED_STORAGE) != 0 &amp;&amp; PackageManager.APPLY_DEFAULT_TO_DEVICE_PROTECTED_STORAGE) &#123; dataDir = deviceProtectedDataDir; &#125; else &#123; dataDir = credentialProtectedDataDir; &#125;&#125; 然后主要就是确定cpuAbi的过程，该过程在ABI确定过程中有详细介绍，这里就不再多说了。 设置时间戳 12345678910111213141516171819// Take care of first install / last update times.final long scanFileTime = getLastModifiedTime(pkg, scanFile);if (currentTime != 0) &#123; if (pkgSetting.firstInstallTime == 0) &#123; pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = currentTime; &#125; else if ((scanFlags &amp; SCAN_UPDATE_TIME) != 0) &#123; pkgSetting.lastUpdateTime = currentTime; &#125;&#125; else if (pkgSetting.firstInstallTime == 0) &#123; // We need *something*. Take time time stamp of the file. pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = scanFileTime;&#125; else if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) != 0) &#123; if (scanFileTime != pkgSetting.timeStamp) &#123; // A package on the system image has changed; consider this // to be an update. pkgSetting.lastUpdateTime = scanFileTime; &#125;&#125;pkgSetting.setTimeStamp(scanFileTime); 设置第一次安装时间&#x2F;上次更新时间，以及时间戳。 提交Package信息到Settings中 123456789101112131415if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123; if (nonMutatedPs != null) &#123;//仅用于检测扫描是否能成功 synchronized (mPackages) &#123; mSettings.mPackages.put(nonMutatedPs.name, nonMutatedPs); &#125; &#125;&#125; else &#123; final int userId = user == null ? 0 : user.getIdentifier(); // Modify state for the given package setting commitPackageSettings(pkg, pkgSetting, user, scanFlags, (policyFlags &amp; PackageParser.PARSE_CHATTY) != 0 /*chatty*/); if (pkgSetting.getInstantApp(userId)) &#123;//Instant app以后专门了解下 mInstantAppRegistry.addInstantAppLPw(userId, pkgSetting.appId); &#125;&#125; 前面提过scanFlags只有在存在child package的情况下&amp; SCAN_CHECK_ONLY才不为0，这种情况上面跳过了，这里继续跳过…… 前面说了那么多内容，其实都是在往PackageSetting里面填东西，最终还是要解析得到的信息吧保存到mSettings和mPackages里，该过程是在commitPackageSettings中进行的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491/** * Adds a scanned package to the system. When this method is finished, the package will * be available for query, resolution, etc... */ private void commitPackageSettings(PackageParser.Package pkg, PackageSetting pkgSetting, UserHandle user, int scanFlags, boolean chatty) throws PackageManagerException &#123; final String pkgName = pkg.packageName; //自定义的ResolverActivity，可以在xml资源中配置 if (mCustomResolverComponentName != null &amp;&amp; mCustomResolverComponentName.getPackageName().equals(pkg.packageName)) &#123; setUpCustomResolverActivity(pkg); &#125; if (pkg.packageName.equals(&quot;android&quot;)) &#123; synchronized (mPackages) &#123; if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123; // Set up information for our fall-back user intent resolution activity. mPlatformPackage = pkg; pkg.mVersionCode = mSdkVersion; mAndroidApplication = pkg.applicationInfo; if (!mResolverReplaced) &#123; mResolveActivity.applicationInfo = mAndroidApplication; //系统默认的ResolverActivity，用于在存在多个匹配Activity的情况下 //显示，让用户选择 mResolveActivity.name = ResolverActivity.class.getName(); //从这里看出来包名为android的不一定就是framework-res.apk mResolveActivity.packageName = mAndroidApplication.packageName; mResolveActivity.processName = &quot;system:ui&quot;; mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE; mResolveActivity.documentLaunchMode = ActivityInfo.DOCUMENT_LAUNCH_NEVER; mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS; mResolveActivity.theme = R.style.Theme_Material_Dialog_Alert; mResolveActivity.exported = true; mResolveActivity.enabled = true; mResolveActivity.resizeMode = ActivityInfo.RESIZE_MODE_RESIZEABLE; mResolveActivity.configChanges = ActivityInfo.CONFIG_SCREEN_SIZE | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE | ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_ORIENTATION | ActivityInfo.CONFIG_KEYBOARD | ActivityInfo.CONFIG_KEYBOARD_HIDDEN; mResolveInfo.activityInfo = mResolveActivity; mResolveInfo.priority = 0; mResolveInfo.preferredOrder = 0; mResolveInfo.match = 0; mResolveComponentName = new ComponentName( mAndroidApplication.packageName, mResolveActivity.name); &#125; &#125; &#125; &#125; ArrayList&lt;PackageParser.Package&gt; clientLibPkgs = null; // writer synchronized (mPackages) &#123; boolean hasStaticSharedLibs = false; // Any app can add new static shared libraries if (pkg.staticSharedLibName != null) &#123; // Static shared libs don&#x27;t allow renaming as they have synthetic package // names to allow install of multiple versions, so use name from manifest. if (addSharedLibraryLPw(null, pkg.packageName, pkg.staticSharedLibName, pkg.staticSharedLibVersion, SharedLibraryInfo.TYPE_STATIC, pkg.manifestPackageName, pkg.mVersionCode)) &#123; hasStaticSharedLibs = true; &#125; else &#123; Slog.w(TAG, &quot;Package &quot; + pkg.packageName + &quot; library &quot; + pkg.staticSharedLibName + &quot; already exists; skipping&quot;); &#125; // Static shared libs cannot be updated once installed since they // use synthetic package name which includes the version code, so // not need to update other packages&#x27;s shared lib dependencies. &#125; if (!hasStaticSharedLibs &amp;&amp; (pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) &#123; // Only system apps can add new dynamic shared libraries. if (pkg.libraryNames != null) &#123; for (int i = 0; i &lt; pkg.libraryNames.size(); i++) &#123; String name = pkg.libraryNames.get(i); boolean allowed = false; if (pkg.isUpdatedSystemApp()) &#123; // New library entries can only be added through the // system image. This is important to get rid of a lot // of nasty edge cases: for example if we allowed a non- // system update of the app to add a library, then uninstalling // the update would make the library go away, and assumptions // we made such as through app install filtering would now // have allowed apps on the device which aren&#x27;t compatible // with it. Better to just have the restriction here, be // conservative, and create many fewer cases that can negatively // impact the user experience. final PackageSetting sysPs = mSettings .getDisabledSystemPkgLPr(pkg.packageName); if (sysPs.pkg != null &amp;&amp; sysPs.pkg.libraryNames != null) &#123; for (int j = 0; j &lt; sysPs.pkg.libraryNames.size(); j++) &#123; if (name.equals(sysPs.pkg.libraryNames.get(j))) &#123; allowed = true; break; &#125; &#125; &#125; &#125; else &#123; allowed = true; &#125; if (allowed) &#123; if (!addSharedLibraryLPw(null, pkg.packageName, name, SharedLibraryInfo.VERSION_UNDEFINED, SharedLibraryInfo.TYPE_DYNAMIC, pkg.packageName, pkg.mVersionCode)) &#123; Slog.w(TAG, &quot;Package &quot; + pkg.packageName + &quot; library &quot; + name + &quot; already exists; skipping&quot;); &#125; &#125; else &#123; Slog.w(TAG, &quot;Package &quot; + pkg.packageName + &quot; declares lib &quot; + name + &quot; that is not declared on system image; skipping&quot;); &#125; &#125; if ((scanFlags &amp; SCAN_BOOTING) == 0) &#123; // If we are not booting, we need to update any applications // that are clients of our shared library. If we are booting, // this will all be done once the scan is complete. clientLibPkgs = updateAllSharedLibrariesLPw(pkg); &#125; &#125; &#125; &#125; if ((scanFlags &amp; SCAN_BOOTING) != 0) &#123; // No apps can run during boot scan, so they don&#x27;t need to be frozen &#125; else if ((scanFlags &amp; SCAN_DONT_KILL_APP) != 0) &#123; // Caller asked to not kill app, so it&#x27;s probably not frozen &#125; else if ((scanFlags &amp; SCAN_IGNORE_FROZEN) != 0) &#123; // Caller asked us to ignore frozen check for some reason; they // probably didn&#x27;t know the package name &#125; else &#123; // We&#x27;re doing major surgery on this package, so it better be frozen // right now to keep it from launching checkPackageFrozen(pkgName); &#125; // Also need to kill any apps that are dependent on the library. if (clientLibPkgs != null) &#123; for (int i=0; i&lt;clientLibPkgs.size(); i++) &#123; PackageParser.Package clientPkg = clientLibPkgs.get(i); killApplication(clientPkg.applicationInfo.packageName, clientPkg.applicationInfo.uid, &quot;update lib&quot;); &#125; &#125; // writer Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;updateSettings&quot;); synchronized (mPackages) &#123; // We don&#x27;t expect installation to fail beyond this point // Add the new setting to mSettings mSettings.insertPackageSettingLPw(pkgSetting, pkg); // Add the new setting to mPackages mPackages.put(pkg.applicationInfo.packageName, pkg); // Make sure we don&#x27;t accidentally delete its data. final Iterator&lt;PackageCleanItem&gt; iter = mSettings.mPackagesToBeCleaned.iterator(); while (iter.hasNext()) &#123; PackageCleanItem item = iter.next(); if (pkgName.equals(item.packageName)) &#123; iter.remove(); &#125; &#125; // Add the package&#x27;s KeySets to the global KeySetManagerService KeySetManagerService ksms = mSettings.mKeySetManagerService; ksms.addScannedPackageLPw(pkg); int N = pkg.providers.size(); StringBuilder r = null; int i; for (i=0; i&lt;N; i++) &#123; PackageParser.Provider p = pkg.providers.get(i); p.info.processName = fixProcessName(pkg.applicationInfo.processName, p.info.processName); mProviders.addProvider(p); p.syncable = p.info.isSyncable; if (p.info.authority != null) &#123; String names[] = p.info.authority.split(&quot;;&quot;); p.info.authority = null; for (int j = 0; j &lt; names.length; j++) &#123; if (j == 1 &amp;&amp; p.syncable) &#123; // We only want the first authority for a provider to possibly be // syncable, so if we already added this provider using a different // authority clear the syncable flag. We copy the provider before // changing it because the mProviders object contains a reference // to a provider that we don&#x27;t want to change. // Only do this for the second authority since the resulting provider // object can be the same for all future authorities for this provider. p = new PackageParser.Provider(p); p.syncable = false; &#125; if (!mProvidersByAuthority.containsKey(names[j])) &#123; mProvidersByAuthority.put(names[j], p); if (p.info.authority == null) &#123; p.info.authority = names[j]; &#125; else &#123; p.info.authority = p.info.authority + &quot;;&quot; + names[j]; &#125; if (DEBUG_PACKAGE_SCANNING) &#123; if (chatty) Log.d(TAG, &quot;Registered content provider: &quot; + names[j] + &quot;, className = &quot; + p.info.name + &quot;, isSyncable = &quot; + p.info.isSyncable); &#125; &#125; else &#123; PackageParser.Provider other = mProvidersByAuthority.get(names[j]); Slog.w(TAG, &quot;Skipping provider name &quot; + names[j] + &quot; (in package &quot; + pkg.applicationInfo.packageName + &quot;): name already used by &quot; + ((other != null &amp;&amp; other.getComponentName() != null) ? other.getComponentName().getPackageName() : &quot;?&quot;)); &#125; &#125; &#125; if (chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(&#x27; &#x27;); &#125; r.append(p.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, &quot; Providers: &quot; + r); &#125; N = pkg.services.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Service s = pkg.services.get(i); s.info.processName = fixProcessName(pkg.applicationInfo.processName, s.info.processName); mServices.addService(s); if (chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(&#x27; &#x27;); &#125; r.append(s.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, &quot; Services: &quot; + r); &#125; N = pkg.receivers.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.receivers.get(i); a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName); mReceivers.addActivity(a, &quot;receiver&quot;); if (chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(&#x27; &#x27;); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, &quot; Receivers: &quot; + r); &#125; N = pkg.activities.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.activities.get(i); a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName); mActivities.addActivity(a, &quot;activity&quot;); if (chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(&#x27; &#x27;); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, &quot; Activities: &quot; + r); &#125; N = pkg.permissionGroups.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.PermissionGroup pg = pkg.permissionGroups.get(i); PackageParser.PermissionGroup cur = mPermissionGroups.get(pg.info.name); final String curPackageName = cur == null ? null : cur.info.packageName; // Dont allow ephemeral apps to define new permission groups. if ((scanFlags &amp; SCAN_AS_INSTANT_APP) != 0) &#123; Slog.w(TAG, &quot;Permission group &quot; + pg.info.name + &quot; from package &quot; + pg.info.packageName + &quot; ignored: instant apps cannot define new permission groups.&quot;); continue; &#125; final boolean isPackageUpdate = pg.info.packageName.equals(curPackageName); if (cur == null || isPackageUpdate) &#123; mPermissionGroups.put(pg.info.name, pg); if (chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(&#x27; &#x27;); &#125; if (isPackageUpdate) &#123; r.append(&quot;UPD:&quot;); &#125; r.append(pg.info.name); &#125; &#125; else &#123; Slog.w(TAG, &quot;Permission group &quot; + pg.info.name + &quot; from package &quot; + pg.info.packageName + &quot; ignored: original from &quot; + cur.info.packageName); if (chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(&#x27; &#x27;); &#125; r.append(&quot;DUP:&quot;); r.append(pg.info.name); &#125; &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, &quot; Permission Groups: &quot; + r); &#125; N = pkg.permissions.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Permission p = pkg.permissions.get(i); // Dont allow ephemeral apps to define new permissions. if ((scanFlags &amp; SCAN_AS_INSTANT_APP) != 0) &#123; Slog.w(TAG, &quot;Permission &quot; + p.info.name + &quot; from package &quot; + p.info.packageName + &quot; ignored: instant apps cannot define new permissions.&quot;); continue; &#125; // Assume by default that we did not install this permission into the system. p.info.flags &amp;= ~PermissionInfo.FLAG_INSTALLED; // Now that permission groups have a special meaning, we ignore permission // groups for legacy apps to prevent unexpected behavior. In particular, // permissions for one app being granted to someone just because they happen // to be in a group defined by another app (before this had no implications). if (pkg.applicationInfo.targetSdkVersion &gt; Build.VERSION_CODES.LOLLIPOP_MR1) &#123; p.group = mPermissionGroups.get(p.info.group); // Warn for a permission in an unknown group. if (DEBUG_PERMISSIONS &amp;&amp; p.info.group != null &amp;&amp; p.group == null) &#123; Slog.i(TAG, &quot;Permission &quot; + p.info.name + &quot; from package &quot; + p.info.packageName + &quot; in an unknown group &quot; + p.info.group); &#125; &#125; ArrayMap&lt;String, BasePermission&gt; permissionMap = p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions; BasePermission bp = permissionMap.get(p.info.name); // Allow system apps to redefine non-system permissions if (bp != null &amp;&amp; !Objects.equals(bp.sourcePackage, p.info.packageName)) &#123; final boolean currentOwnerIsSystem = (bp.perm != null &amp;&amp; isSystemApp(bp.perm.owner)); if (isSystemApp(p.owner)) &#123; if (bp.type == BasePermission.TYPE_BUILTIN &amp;&amp; bp.perm == null) &#123; // It&#x27;s a built-in permission and no owner, take ownership now bp.packageSetting = pkgSetting; bp.perm = p; bp.uid = pkg.applicationInfo.uid; bp.sourcePackage = p.info.packageName; p.info.flags |= PermissionInfo.FLAG_INSTALLED; &#125; else if (!currentOwnerIsSystem) &#123; String msg = &quot;New decl &quot; + p.owner + &quot; of permission &quot; + p.info.name + &quot; is system; overriding &quot; + bp.sourcePackage; reportSettingsProblem(Log.WARN, msg); bp = null; &#125; &#125; &#125; if (bp == null) &#123; bp = new BasePermission(p.info.name, p.info.packageName, BasePermission.TYPE_NORMAL); permissionMap.put(p.info.name, bp); &#125; if (bp.perm == null) &#123; if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) &#123; BasePermission tree = findPermissionTreeLP(p.info.name); if (tree == null || tree.sourcePackage.equals(p.info.packageName)) &#123; bp.packageSetting = pkgSetting; bp.perm = p; bp.uid = pkg.applicationInfo.uid; bp.sourcePackage = p.info.packageName; p.info.flags |= PermissionInfo.FLAG_INSTALLED; if (chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(&#x27; &#x27;); &#125; r.append(p.info.name); &#125; &#125; else &#123; Slog.w(TAG, &quot;Permission &quot; + p.info.name + &quot; from package &quot; + p.info.packageName + &quot; ignored: base tree &quot; + tree.name + &quot; is from package &quot; + tree.sourcePackage); &#125; &#125; else &#123; Slog.w(TAG, &quot;Permission &quot; + p.info.name + &quot; from package &quot; + p.info.packageName + &quot; ignored: original from &quot; + bp.sourcePackage); &#125; &#125; else if (chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(&#x27; &#x27;); &#125; r.append(&quot;DUP:&quot;); r.append(p.info.name); &#125; if (bp.perm == p) &#123; bp.protectionLevel = p.info.protectionLevel; &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, &quot; Permissions: &quot; + r); &#125; N = pkg.instrumentation.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Instrumentation a = pkg.instrumentation.get(i); a.info.packageName = pkg.applicationInfo.packageName; a.info.sourceDir = pkg.applicationInfo.sourceDir; a.info.publicSourceDir = pkg.applicationInfo.publicSourceDir; a.info.splitNames = pkg.splitNames; a.info.splitSourceDirs = pkg.applicationInfo.splitSourceDirs; a.info.splitPublicSourceDirs = pkg.applicationInfo.splitPublicSourceDirs; a.info.splitDependencies = pkg.applicationInfo.splitDependencies; a.info.dataDir = pkg.applicationInfo.dataDir; a.info.deviceProtectedDataDir = pkg.applicationInfo.deviceProtectedDataDir; a.info.credentialProtectedDataDir = pkg.applicationInfo.credentialProtectedDataDir; a.info.nativeLibraryDir = pkg.applicationInfo.nativeLibraryDir; a.info.secondaryNativeLibraryDir = pkg.applicationInfo.secondaryNativeLibraryDir; mInstrumentation.put(a.getComponentName(), a); if (chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(&#x27; &#x27;); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, &quot; Instrumentation: &quot; + r); &#125; if (pkg.protectedBroadcasts != null) &#123; N = pkg.protectedBroadcasts.size(); synchronized (mProtectedBroadcasts) &#123; for (i = 0; i &lt; N; i++) &#123; mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i)); &#125; &#125; &#125; &#125; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; 方法又很长，但是做的事大致就这么几件： 设置PKMS中mPlatformPackage 、mAndroidApplication、mResolveActivity、mResolveInfo及mResolveComponentName等成员的值； 填充mSharedLibraries和mStaticLibsByDeclaringPackage这两个ArrayMap； Add the new setting to mSettings：mSettings.insertPackageSettingLPw(pkgSetting, pkg); Add the new setting to mPackages： mPackages.put(pkg.applicationInfo.packageName, pkg); 往下面四个解析器中添加解析后的组件： 12345678910111213// All available activities, for your resolving pleasure.final ActivityIntentResolver mActivities = new ActivityIntentResolver();// All available receivers, for your resolving pleasure.final ActivityIntentResolver mReceivers = new ActivityIntentResolver();// All available services, for your resolving pleasure.final ServiceIntentResolver mServices = new ServiceIntentResolver();// All available providers, for your resolving pleasure.final ProviderIntentResolver mProviders = new ProviderIntentResolver(); 从名字上就可以看出来四大组件的解析肯定和这四个Resolver有关。组件解析过程之后再做了解。 更新权限信息； 更新mInstrumentation，Instrumentation印象中是用来调试的，暂不了解； 填充mProtectedBroadcasts： 123// Broadcast actions that are only available to the system.@GuardedBy(&quot;mProtectedBroadcasts&quot;)final ArraySet&lt;String&gt; mProtectedBroadcasts = new ArraySet&lt;&gt;(); 进过上面一系列的扫描过程一个apk就解析完了，不断重复该过程直到一个目录下的apk全部解析完成。六个目录下的apk解析过程类似，将所有的apk解析完之后mSetting和mPackage等信息也就构建完成了，之后就可以通过PKMS进行组件的查询和解析了。 生成data 首先是通过reconcileAppsDataLI生成coreApp的data（在&#x2F;data&#x2F;user&#x2F;0下面），该方法返回跳过的非coreApp列表： 123List&lt;String&gt; deferPackages = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, UserHandle.USER_SYSTEM, storageFlags, true /* migrateAppData */, true /* onlyCoreApps */); 而reconcileAppsDataLI内部又调用了prepareAppDataAndMigrateLIF来准备应用的数据。 之后再通过prepareAppDataAndMigrateLIF方法逐个生成deferPackages中package的数据： 123456789101112131415161718192021222324252627282930313233343536mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(() -&gt; &#123; TimingsTraceLog traceLog = new TimingsTraceLog(&quot;SystemServerTimingAsync&quot;, Trace.TRACE_TAG_PACKAGE_MANAGER); traceLog.traceBegin(&quot;AppDataFixup&quot;); try &#123; mInstaller.fixupAppData(StorageManager.UUID_PRIVATE_INTERNAL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE); &#125; catch (InstallerException e) &#123; Slog.w(TAG, &quot;Trouble fixing GIDs&quot;, e); &#125; traceLog.traceEnd(); traceLog.traceBegin(&quot;AppDataPrepare&quot;); if (deferPackages == null || deferPackages.isEmpty()) &#123; return; &#125; int count = 0; for (String pkgName : deferPackages) &#123; PackageParser.Package pkg = null; synchronized (mPackages) &#123; PackageSetting ps = mSettings.getPackageLPr(pkgName); if (ps != null &amp;&amp; ps.getInstalled(UserHandle.USER_SYSTEM)) &#123; pkg = ps.pkg; &#125; &#125; if (pkg != null) &#123; synchronized (mInstallLock) &#123; prepareAppDataAndMigrateLIF(pkg, UserHandle.USER_SYSTEM, storageFlags, true /* maybeMigrateAppData */); &#125; count++; &#125; &#125; traceLog.traceEnd(); Slog.i(TAG, &quot;Deferred reconcileAppsData finished &quot; + count + &quot; packages&quot;); &#125;, &quot;prepareAppData&quot;); 以上代码将一个Runnable和对该Runnable对象的描述作为参数传递给了SystemServerInitThreadPool，然后在线程池中执行Runnable，通过prepareAppDataAndMigrateLIF方法准备data,并最终返回一个Future对象。 也就是说，coreApp和非coreApp最终都是通过prepareAppDataAndMigrateLIF来为app准备数据的。 12345678910private void prepareAppDataAndMigrateLIF(PackageParser.Package pkg, int userId, int flags, boolean maybeMigrateAppData) &#123; prepareAppDataLIF(pkg, userId, flags); if (maybeMigrateAppData &amp;&amp; maybeMigrateAppDataLIF(pkg, userId)) &#123; // We may have just shuffled around app data directories, so // prepare them one more time prepareAppDataLIF(pkg, userId, flags); &#125;&#125; 上面的方法会通过Installer对象的createAppData方法来进行数据的准备工作，之后会到native层（frameworks&#x2F;native&#x2F;cmds&#x2F;installd&#x2F;InstalldNativeService.cpp），该过程就不了解了。 再回过头来看一下上面提到的SystemServerInitThreadPool，源码中的注释如下： 12345678/** * Thread pool used during initialization of system server. * &lt;p&gt;System services can &#123;@link #submit(Runnable)&#125; tasks for execution during boot. * The pool will be shut down after &#123;@link SystemService#PHASE_BOOT_COMPLETED&#125;. * New tasks &lt;em&gt;should not&lt;/em&gt; be submitted afterwards. * * @hide */ 该类是在System server创建过程中用到的线程池，在启动过程中系统服务可以通过submit方法向线程池中提交任务，SystemService#PHASE_BOOT_COMPLETED之后线程池会关闭。来看下该类的关键代码： 12345678910111213141516171819202122232425262728293031private static SystemServerInitThreadPool sInstance;private ExecutorService mService = ConcurrentUtils.newFixedThreadPool(4, &quot;system-server-init-thread&quot;, Process.THREAD_PRIORITY_FOREGROUND);public static synchronized SystemServerInitThreadPool get() &#123; if (sInstance == null) &#123; sInstance = new SystemServerInitThreadPool(); &#125; Preconditions.checkState(sInstance.mService != null, &quot;Cannot get &quot; + TAG + &quot; - it has been shut down&quot;); return sInstance;&#125;public Future&lt;?&gt; submit(Runnable runnable, String description) &#123; if (IS_DEBUGGABLE) &#123; return mService.submit(() -&gt; &#123; Slog.d(TAG, &quot;Started executing &quot; + description); try &#123; runnable.run(); &#125; catch (RuntimeException e) &#123; Slog.e(TAG, &quot;Failure in &quot; + description + &quot;: &quot; + e, e); throw e; &#125; Slog.d(TAG, &quot;Finished executing &quot; + description); &#125;); &#125; return mService.submit(runnable);&#125; 该类采用了单例单例模式，内部维护了一个FixedThreadPool引用mServices,提交的任务实际上是提交给mServices。mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit返回的对象仅在一处用到了： 12345678//PKMSpublic void waitForAppDataPrepared() &#123; if (mPrepareAppDataFuture == null) &#123; return; &#125; ConcurrentUtils.waitForFutureNoInterrupt(mPrepareAppDataFuture, &quot;wait for prepareAppData&quot;); mPrepareAppDataFuture = null;&#125; 而该方法会在System server的startOtherService中传递给AMS的runnable中调用，用来等待数据准备完成。 总结：首次开机过程中应用的安装设计的代码很多，但是做的事情并不多，主要就是通过解析apk更新PKMS的成员变量的内容，例如mSettings、mPackages以及权限相关成员、lib库相关成员，以及更重要的四大组件的解析器信息，并准备apk的数据。","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"},{"name":"应用安装","slug":"Android/应用安装","permalink":"https://mouzishuo.github.io/categories/Android/%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"PKMS","slug":"PKMS","permalink":"https://mouzishuo.github.io/tags/PKMS/"},{"name":"PackageManagerService","slug":"PackageManagerService","permalink":"https://mouzishuo.github.io/tags/PackageManagerService/"},{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"}]},{"title":"HashMap、LinkedHashMap、三级缓存","slug":"HashMap、LinkedHashMap、三级缓存","date":"2018-07-13T09:13:55.000Z","updated":"2019-01-16T01:14:47.488Z","comments":true,"path":"2018/07/13/HashMap、LinkedHashMap、三级缓存/","link":"","permalink":"https://mouzishuo.github.io/2018/07/13/HashMap%E3%80%81LinkedHashMap%E3%80%81%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/","excerpt":"","text":"HashMapHashMap在迭代器创建后，通过iterator的remove()方法之外的其他方式改变HashMap结构（增加或删除元素），都会抛出ConcurrentModificationException异常（fail-fast），因为HashMap不支持并发操作，预期在将来产生无法预料的后果，不如马上抛出错误。这种fail-fast的行为并不一定总是有效，因此在程序中不应该依赖这种行为。 HashMap中的树节点size是普通节点的两倍左右，所以在桶里的节点不多的时候（阈值为6，转换成树节点的阈值为8），会把树节点重新转换成普通节点。因为红黑树的平均查找长度是log（n），长度为8的时候，平均查找长度为3。。如果继续使用链表，平均查找长度为8&#x2F;2&#x3D;4。这才有转换为树的必要。。链表长度如果是6以内，6&#x2F;2&#x3D;3，速度也很快的。转化为树还有生成树的时间，并不明智。 红黑树和HashMap可以参考https://www.cnblogs.com/liwei2222/p/8013367.html，其实和算法这本书上说的差不多。 LinkedHashMap关于LinkedHashMap可以参考：https://www.cnblogs.com/xiaoxi/p/6170590.html。LinkedHashMap相当于HashMap和LinkedList（循环双向链表）的结合，可以选择按照插入顺序或者访问顺序记录节点顺序。 三级缓存使用缓存的好处： 加快数据的获取速度，降低开销； 减轻服务器的负担（访问网络地情况）； 在没网络的情况下获取数据； 关于LruCache参考：https://www.jianshu.com/p/b49a111147ee。LruCache采用LinkedHashMap实现，最新访问的节点放到尾部，头部的就是上次访问离现在最久的，缓存满的话删除头部的节点。 LinkedHashMap可以用来实现LruCache的关键两点： LinkedHashMap是按Key-Value存储内容的，和Cache一致； LinkedHashMap设置accessOrder为true时可以按照访问顺序记录元素的顺序，正好可以用来实现Lru算法。 Android的三级缓存： 网络缓存； 磁盘缓存DiskLruCache（Android不包含，需要到Github下载）； 内存缓存LruCache（Android 3.1支持）； 最重要的是后面两种。 LruCacheLruCache基本用法： 123456int cacheSize = 4 * 1024 * 1024; // 4MiBLruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; protected int sizeOf(String key, Bitmap value) &#123; return value.getByteCount(); &#125;&#125;&#125; cacheSize和sizeOf的单位要一致。 LruCache是线程安全的，比如get()方法中： 12345678synchronized (this) &#123; mapValue = map.get(key); if (mapValue != null) &#123; hitCount++; return mapValue; &#125; missCount++; &#125; 另外，该类不允许null作为key和value。get,put和remove方法返回null均表示不存在该元素。 LruCache的size属性表示的值和单位有关不一定时元素的个数，比如图片的缓存size表示的可能是多少M。 trim表示修剪，trimToSize方法就表示把Map修剪到多大，这里指的是最大的size。 LruCache的put，get方法都可能调用trimToSize方法，pu好理解，get方法中之所以会调用该方法是因为在缓存中不存在Key对应的entry时会调用create方法（默认实现返回null），如果create成功size就会发生改变，所以需要调用trimToSize以免超出最大size。remove方法是删除元素的，所以不不需要调用该方法。 entryRemove被调用的三种情况： 缓存满了，移除元素； 调用remove方法移除元素； put方法更新了元素； entryRemove默认实现为空，可以重写来进行资源的显式释放，比如回收Bitmap。 DiskLruCacheDiskLruCache用于实现磁盘缓存，通过将缓存对象写入磁盘实现缓存的效果。DiskLruCache的使用过程如下。 创建 DiskLruCache不能通过LruCache创建。它提供了open方法创建自身。这一点在AOSP源码的external&#x2F;glide&#x2F;third_party&#x2F;disklrucache&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;bumptech&#x2F;glide&#x2F;disklrucache&#x2F;DiskLruCache.java中确实是这样，但是在external&#x2F;okhttp&#x2F;okhttp&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;squareup&#x2F;okhttp&#x2F;internal&#x2F;DiskLruCache.java中未找到该方法，暂时就按glide中的来。open方法的声明如下： 1234567891011 /** * Opens the cache in &#123;@code directory&#125;, creating a cache if none exists * there. * @param directory 应用的缓存目录，或者其他指定的目录，区别在于应用卸载后缓存会不会清空 * @param appVersion 应用的版本，如前后版本改变，缓存会被清空，一般为1即可 * @param valueCount 每个entry中value的个数，一般为1 * @param maxSize 缓存总大下，比如50M * @throws IOException if reading or writing the cache directory fails */public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize) throws IOException ​ 典型的缓存创建过程如下： 123456privata static final long DISK_CACHE_SIZE = 1024 * 0124 * 50;//50MFile diskCahceDir = getDiskCacheDir(mContext, &quot;bitmap&quot;);if (!diskCacheDir.exists())&#123; diskCacheDir.mkdirs();&#125;mDiskLruCache = DiskLruCache.open(diskCacheDir, 1, 1, DISK_CACHE_SIZE); 缓存添加 DiskLruCache的缓存添加是通过Editor完成的，Editor是一个缓存对象的编辑器对象（类似于SharedPreferences值得editor）。仍然以图片为例，添加缓存要经过以下步骤： url转化成key，因为url中可能存在一些特殊字符，可能会影响url的使用，一般采用url的md5值； 获取Editor对象，如下所示： 123456String key = hashKeyFromUrl(url);DiskLruCache.Editor editor = mDiskLruCache.edit(key);if (editir != null) &#123; //之前设置了一个节点只有一个数据，所以DISK_CACHE_INDEX为0即可 OutputStream outputStream = editor.newOutputStream(DISK_CACHE_INDEX);&#125; 将数据写入editor的输出流； 使用editor的commit()方法提交数据，或者在出现问题时用abort()方法回退整个操作： 1234567OutputStream outputStream = editor.newOutputStream(DISK_CACHE_INDEX);if(downloadUrlToStream(url, outputStream))&#123; editor.commit();&#125; else &#123; editor.abort();&#125;mDiskLruCache.flush; 缓存查找 和缓存的添加类似，先将url转化成key,然后通过DiskLruCache的get方法得到一个SnapShot对象，接着再通过SnapShot对象得到缓存文件的输入流，有了输入流就可以得到Bitmap了。为了避免oom，一般不直接加载原图，通过BitmapFactory.Options对象可以加载缩放后的对象，但是该方法对FileInputStream的缩放存在问题，因为FileInputStream是一种有序的文件流，而两次的decodeStream的调用会影响文件流的位置属性，导致第二次decodeStream得到的时null。为了解决这个问题，可以通过文件流来的到对应的文件描述符（getFD方法），然后通过BitmapFactory.decodeFileDescriptor方法来加载缩放后的图片。 DiskLruCahce的内容来自《Android开发艺术探索》12.2.2小节，相关代码可以参考该书内容。","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://mouzishuo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"缓存","slug":"缓存","permalink":"https://mouzishuo.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"LruCache","slug":"LruCache","permalink":"https://mouzishuo.github.io/tags/LruCache/"},{"name":"DiskLruCache","slug":"DiskLruCache","permalink":"https://mouzishuo.github.io/tags/DiskLruCache/"},{"name":"HashMap","slug":"HashMap","permalink":"https://mouzishuo.github.io/tags/HashMap/"},{"name":"LinkedHashMap","slug":"LinkedHashMap","permalink":"https://mouzishuo.github.io/tags/LinkedHashMap/"}]},{"title":"LeakCanary原理","slug":"LeakCanary","date":"2018-07-10T02:13:55.000Z","updated":"2019-01-16T01:14:47.492Z","comments":true,"path":"2018/07/10/LeakCanary/","link":"","permalink":"https://mouzishuo.github.io/2018/07/10/LeakCanary/","excerpt":"","text":"LeakCanary参考：https://github.com/square/leakcanary/wiki/FAQ#how-does-it-work ​ https://blog.csdn.net/xinzhou201/article/details/78637700 GitHub上关于LeakCanary的原理： RefWatcher.watch() creates a KeyedWeakReference to the watched object. Later, in a background thread, it checks if the reference has been cleared and if not it triggers a GC. If the reference is still not cleared, it then dumps the heap into a .hprof file stored on the file system. HeapAnalyzerService is started in a separate process and HeapAnalyzer parses the heap dump using HAHA. HeapAnalyzer finds the KeyedWeakReference in the heap dump thanks to a unique reference key and locates the leaking reference. HeapAnalyzer computes the shortest strong reference path to the GC Roots to determine if there is a leak, and then builds the chain of references causing the leak. The result is passed back to DisplayLeakService in the app process, and the leak notification is shown. 这个涉及到弱引用的概念，可以参考https://blog.csdn.net/mazhimazh/article/details/19752475， 其中关于四四种的概念和使用场景进行了清除的介绍。单拿弱引用来说，弱引用不管内存是否够用，在GC的是时候都会被回收，主要用于引用的对象有自己的生命周期，而我们又不想影响对象生命周期的情况下，用于检测Activity&#x2F;Fragment的内存泄露再合适不过。","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"}],"tags":[{"name":"弱引用","slug":"弱引用","permalink":"https://mouzishuo.github.io/tags/%E5%BC%B1%E5%BC%95%E7%94%A8/"},{"name":"LeakCanary","slug":"LeakCanary","permalink":"https://mouzishuo.github.io/tags/LeakCanary/"},{"name":"性能","slug":"性能","permalink":"https://mouzishuo.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"内存泄露","slug":"内存泄露","permalink":"https://mouzishuo.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"}]},{"title":"SharedPreferences中commit与apply的区别","slug":"SharePreferences中commit与apply的区别","date":"2018-07-10T02:13:55.000Z","updated":"2019-01-16T01:14:47.540Z","comments":true,"path":"2018/07/10/SharePreferences中commit与apply的区别/","link":"","permalink":"https://mouzishuo.github.io/2018/07/10/SharePreferences%E4%B8%ADcommit%E4%B8%8Eapply%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"SharedPreferences中commit与apply的区别 apply（）写入文件的操作是异步的，会把Runnable放到线程池中执行，而commit（）的写入文件的操作是在当前线程同步执行的。 因此当两者都可以使用的时候还是推荐使用apply（），因为apply（）写入文件操作是异步执行的，不会占用主线程资源。 commit（）有返回值，apply（）没有返回值。apply（）失败了是不会报错的。 另外： 1、如果先后apply（）了几次，那么会以最后一次apply（）的为准。2、commit（）是把内容同步提交到硬盘的。而apply（）先立即把修改提交到内存，然后开启一个异步的线程提交到硬盘，并且如果提交失败，你不会收到任何通知。3、如果当一个apply（）的异步提交还在进行的时候，执行commit（）操作，那么commit（）是会阻塞的。而如果commit（）的时候，前面的commit（）还未结束，这个commit（）还是会阻塞的。（所以引起commit阻塞会有这两种原因）4、由于SharePreferences在一个程序中的实例一般都是单例的，所以如果你不是很在意返回值的话，你使用apply（）代替commit（）是无所谓的。","categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"}],"tags":[{"name":"SharedPreferences","slug":"SharedPreferences","permalink":"https://mouzishuo.github.io/tags/SharedPreferences/"}]},{"title":"Pixel折腾","slug":"Pixel折腾","date":"2018-07-03T07:25:08.000Z","updated":"2018-08-30T06:44:40.866Z","comments":true,"path":"2018/07/03/Pixel折腾/","link":"","permalink":"https://mouzishuo.github.io/2018/07/03/Pixel%E6%8A%98%E8%85%BE/","excerpt":"","text":"拿到手里是Android 7.1的系统，忍不住翻了墙升级到了最新的8.1版本，然后就开始不停地踩坑了…… 手机到手当然要先测试下，装了翻墙软件（Turbo），登陆了Google账号，下了下东西，运行没问题。然后试了指纹解锁，也没问题，然后就升级吧！接着悲剧就开始了，刚开始升级包时而能下载，时而下载不了，后来搜了下发现是因为升级了Google play 服务造成的（印象中是这个），卸载后下载正常，然后顺利更新。 升级8.1最新版本后，开机，发现图案解锁错误，不清楚什么原因，可能是Google的bug，没办法只能进入Recovery模式（Power + 音量下键）双清（清除数据和缓存）。 双清后问题又来了，前面说了登陆了Google的账号，然后开机向导跳不过去了，必须登陆Google账号才行，但是手机双清后还在开机向导，显然连不了VPN，尝试用另一台翻墙的手机共享热点，失败。一番百度发现CSDN上有个叫VPN中继的东西，地址：https://blog.csdn.net/tty521/article/details/79492030。里面有个VPN Ethernet工具可以共享VPN热点，但是需要手机Root，没办法把自己的小米手机解锁刷了个开发版……最后终于成功登陆了Google账号。升级到8.1的手机也可以正常使用了。 之后要继续折腾，自己编译AOSP代码然后刷到手机里。第一步需要解锁手机的bootloader,但是一番搜索之后发现我自己买的是个运营商版本，也就是所谓的V版（ro.boot.cid: VZW__001），这个版本的bootloader是锁的，没办法直接通过fastboot解锁。搜了一下网上的教程，解锁方法大致有三类： 淘宝，150RMB，需要用到一个叫二代金卡的东西，自己也没办法搞，pass； dePixel8，老外搞的一个解锁工具，参考http://theroot.ninja/depixel8.html，但是该方法好像只对Android 7.1.1及以下版本有效。而我已经升级到了8.1最新版，尝试降级，发现现在的Android加了降级保护，无果，只能另想他法。 多番百度无果，然后翻墙取Google继续搜，发现一种有效的方法。相关网址： https://forum.xda-developers.com/pixel-xl/how-to/how-to-unlock-bootloader-verizon-pixel-t3796030 https://www.reddit.com/r/GooglePixel/comments/8mg7x3/howto_unlock_bootloader_on_verizon_pixelxl/?sort=qa 具体步骤： Remove Google account and any kind of screen lock (fingerprint, PIN, pattern, etc.) from your device. Eject sim card from your device. Reset your device. In setup wizard, skip everything, don’t connect to WiFi, don’t add fingerprint or any kind of screen lock. Go to Developer Options and enable USB debugging. Connect your phone to PC. Open CMD in adb directory and type 1adb shell pm uninstall --user 0 com.android.phone Restart your device. Connect to WiFi, open Chrome and go to google.com (or any website really). Go to Developer Options and enable OEM unlocking. Reboot into bootloader and via CMD run 1fastboot oem unlock or 1fastboot flashing unlock 上面的方法尝试几次后成功解锁bootloader. 之后就是编译刷机的问题了，在https://source.android.google.cn/setup/build-numbers#source-code-tags-and-builds找到Pixel能刷的版本的代号和所对应的分支，然后通过repo init后再同步切换到想要的分支。然后在https://developers.google.cn/android/drivers#walleyeopm1.171019.011下载版本对应的驱动，然后放到aosp根目录解压运行。之后就可以开始编译了，编译后通过fastboot刷机即可。编译过程很顺利没有遇到什么问题。 刷机问题： android@dzb:~&#x2F;workdir&#x2F;AOSP&#x2F;aosp&#x2F;out&#x2F;target&#x2F;product&#x2F;sailfish$ fastboot flash boot boot.imgtarget reported max download size of 536870912 bytessending ‘bootb’ (28949 KB)…OKAY [ 0.743s]writing ‘bootb’…(bootloader) Flashing active slot “_b”FAILED (remote: partition [bootb] doesn’t exist)finished. total time: 0.802s 解决方案：在google上找到的答案，网站reddit.com,解决办法是更换adb和fastboot.跟换到Android O编译出的工具后该问题解决。 原生的系统太难看，所以把一些原生的apk删掉了，然后装了一些感觉还好的apk，其中一些是从pixel的镜像中提取的，提取过程参考https://blog.csdn.net/zhenguo26/article/details/80369503。 把Pixel的动态壁纸apk推到手机里后，选择动态地球崩溃，动态地球对应apk为WallpapersBReel,后来发现时该apk里引用了两个so，而这两个so在aosp的镜像里是没有的，在Pixel镜像提取出的文件里找到这两个so，push到&#x2F;system&#x2F;lib64后正常。 刷入google全家桶： 刷入TWRP，下载地址https://dl.twrp.me/sailfish/，开始下载的是[twrp-3.2.1-2-sailfish.img](https://dl.twrp.me/sailfish/twrp-3.2.1-2-sailfish.img.html)但是用fastboot boot twrp.img命令刷入的时候报错 : 123456~/Desktop ❯❯❯ fastboot boot twrp.img ✘ 1 creating boot image...creating boot image - 10240 bytesDownloading &#x27;boot.img&#x27; OKAY [ 0.070s]booting FAILED (status read failed (No such device))Finished. Total time: 5.124s 之后改用twrp-3.1.1-1-fastboot-sailfish.img顺利刷入。 刷入opengapps,下载地址：https://opengapps.org/，选择合适的版本，最开始选的stock版本，刷入失败Error code:70.原因是system分区空间不够，改用小的包刷入，或者选用aroma版本，选择要安装的app，失败的话重启再试刷。 参考:http://www.oneplusbbs.com/thread-1118962-1-10.html 刷入opengapps后google play service老是crash，Google play商店无法登陆，从log上看是找不到so文件，解压GmsCore把里面的so文件推到手机里，play商店可以正常登陆。 Pixel相机下载地址： http://www.downcc.com/soft/320404.html（能用的，和Pixel本身的比较像，需要安装Google框架才能用） https://www.pipipan.com/dir/15204535-24613031-01ad80/（这里下的安装无法正常使用，没全试） 相机直接push到手机里会出现找不到so库的情况，可以找不到的so文件push到手机里，或者再adb install 一下。 截屏apk push到手机里马赛克进不去，找不到so文件，两种解决办法，一是push一份so文件到手机里，另一种方法是删除&#x2F;data&#x2F;system&#x2F;packages.xml，再次开机会重新扫描应用，但是这种方式会导致安装在data分区的应用消失。","categories":[{"name":"折腾","slug":"折腾","permalink":"https://mouzishuo.github.io/categories/%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"Pixel","slug":"Pixel","permalink":"https://mouzishuo.github.io/tags/Pixel/"},{"name":"刷机","slug":"刷机","permalink":"https://mouzishuo.github.io/tags/%E5%88%B7%E6%9C%BA/"},{"name":"gapps","slug":"gapps","permalink":"https://mouzishuo.github.io/tags/gapps/"}]}],"categories":[{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/categories/Android/"},{"name":"tool","slug":"tool","permalink":"https://mouzishuo.github.io/categories/tool/"},{"name":"debug","slug":"debug","permalink":"https://mouzishuo.github.io/categories/debug/"},{"name":"Android基础","slug":"Android基础","permalink":"https://mouzishuo.github.io/categories/Android%E5%9F%BA%E7%A1%80/"},{"name":"kernel panic","slug":"kernel-panic","permalink":"https://mouzishuo.github.io/categories/kernel-panic/"},{"name":"编译","slug":"编译","permalink":"https://mouzishuo.github.io/categories/%E7%BC%96%E8%AF%91/"},{"name":"GMS","slug":"Android/GMS","permalink":"https://mouzishuo.github.io/categories/Android/GMS/"},{"name":"数据结构","slug":"Android基础/数据结构","permalink":"https://mouzishuo.github.io/categories/Android%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"AMS","slug":"AMS","permalink":"https://mouzishuo.github.io/categories/AMS/"},{"name":"Tools","slug":"Tools","permalink":"https://mouzishuo.github.io/categories/Tools/"},{"name":"PackageManagerService","slug":"Android/PackageManagerService","permalink":"https://mouzishuo.github.io/categories/Android/PackageManagerService/"},{"name":"PKMS","slug":"Android/PackageManagerService/PKMS","permalink":"https://mouzishuo.github.io/categories/Android/PackageManagerService/PKMS/"},{"name":"Android","slug":"AMS/Android","permalink":"https://mouzishuo.github.io/categories/AMS/Android/"},{"name":"应用安装","slug":"应用安装","permalink":"https://mouzishuo.github.io/categories/%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85/"},{"name":"应用安装","slug":"Android/应用安装","permalink":"https://mouzishuo.github.io/categories/Android/%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85/"},{"name":"OTA","slug":"Android/OTA","permalink":"https://mouzishuo.github.io/categories/Android/OTA/"},{"name":"折腾","slug":"折腾","permalink":"https://mouzishuo.github.io/categories/%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"PKMS","slug":"PKMS","permalink":"https://mouzishuo.github.io/tags/PKMS/"},{"name":"hexo","slug":"hexo","permalink":"https://mouzishuo.github.io/tags/hexo/"},{"name":"Android","slug":"Android","permalink":"https://mouzishuo.github.io/tags/Android/"},{"name":"debug","slug":"debug","permalink":"https://mouzishuo.github.io/tags/debug/"},{"name":"ANR","slug":"ANR","permalink":"https://mouzishuo.github.io/tags/ANR/"},{"name":"SWT","slug":"SWT","permalink":"https://mouzishuo.github.io/tags/SWT/"},{"name":"Linux","slug":"Linux","permalink":"https://mouzishuo.github.io/tags/Linux/"},{"name":"消息机制","slug":"消息机制","permalink":"https://mouzishuo.github.io/tags/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"name":"权限","slug":"权限","permalink":"https://mouzishuo.github.io/tags/%E6%9D%83%E9%99%90/"},{"name":"高通","slug":"高通","permalink":"https://mouzishuo.github.io/tags/%E9%AB%98%E9%80%9A/"},{"name":"数据结构","slug":"数据结构","permalink":"https://mouzishuo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"AMS","slug":"AMS","permalink":"https://mouzishuo.github.io/tags/AMS/"},{"name":"Intent","slug":"Intent","permalink":"https://mouzishuo.github.io/tags/Intent/"},{"name":"PackageManagerService","slug":"PackageManagerService","permalink":"https://mouzishuo.github.io/tags/PackageManagerService/"},{"name":"兼容性","slug":"兼容性","permalink":"https://mouzishuo.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"Ubuntu Samba","slug":"Ubuntu-Samba","permalink":"https://mouzishuo.github.io/tags/Ubuntu-Samba/"},{"name":"PackageInstaller","slug":"PackageInstaller","permalink":"https://mouzishuo.github.io/tags/PackageInstaller/"},{"name":"SystemUI","slug":"SystemUI","permalink":"https://mouzishuo.github.io/tags/SystemUI/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"https://mouzishuo.github.io/tags/ActivityManagerService/"},{"name":"Android系统服务","slug":"Android系统服务","permalink":"https://mouzishuo.github.io/tags/Android%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"},{"name":"ABI","slug":"ABI","permalink":"https://mouzishuo.github.io/tags/ABI/"},{"name":"original-package","slug":"original-package","permalink":"https://mouzishuo.github.io/tags/original-package/"},{"name":"缓存","slug":"缓存","permalink":"https://mouzishuo.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"LruCache","slug":"LruCache","permalink":"https://mouzishuo.github.io/tags/LruCache/"},{"name":"DiskLruCache","slug":"DiskLruCache","permalink":"https://mouzishuo.github.io/tags/DiskLruCache/"},{"name":"HashMap","slug":"HashMap","permalink":"https://mouzishuo.github.io/tags/HashMap/"},{"name":"LinkedHashMap","slug":"LinkedHashMap","permalink":"https://mouzishuo.github.io/tags/LinkedHashMap/"},{"name":"弱引用","slug":"弱引用","permalink":"https://mouzishuo.github.io/tags/%E5%BC%B1%E5%BC%95%E7%94%A8/"},{"name":"LeakCanary","slug":"LeakCanary","permalink":"https://mouzishuo.github.io/tags/LeakCanary/"},{"name":"性能","slug":"性能","permalink":"https://mouzishuo.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"内存泄露","slug":"内存泄露","permalink":"https://mouzishuo.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"},{"name":"SharedPreferences","slug":"SharedPreferences","permalink":"https://mouzishuo.github.io/tags/SharedPreferences/"},{"name":"Pixel","slug":"Pixel","permalink":"https://mouzishuo.github.io/tags/Pixel/"},{"name":"刷机","slug":"刷机","permalink":"https://mouzishuo.github.io/tags/%E5%88%B7%E6%9C%BA/"},{"name":"gapps","slug":"gapps","permalink":"https://mouzishuo.github.io/tags/gapps/"}]}